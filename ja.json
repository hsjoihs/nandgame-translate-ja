{
  "missions": {
    "RELAY_NAND": {
      "title": "Nand",
      "splash": "<p><b>Nand Game</b>へようこそ！</p>\n<p>このゲームでは、基本的な部品（コンポーネント）からスタートして、コンピュータを組み上げていきます。\n  <div><p>このゲームは、順番にステージをこなす構成となっています。\n 各ステージでは、仕様に従って動作するコンポーネントを作成することが求められます。\n 作成したコンポーネントは、以降のステージで、新たに物を組み立てるための部品として使用できます。\n\n<p>このゲームでは、コンピュータアーキテクチャやソフトウェアについての事前知識は<b>一切</b>必要ありませんし、足し算や引き算以外の数学的なスキルも必要ありません。\n （ただし、解くのに結構時間がかかりそうなタスクもそこそこあるので、忍耐力は必要ですよ～）\n\n </div> <p>最初のタスクは、<b>nand</b>という部品を作成することです。\n <p>図の左側に、このタスクで作り上げるべき部品の厳密な仕様が載っています。\n 「ステージのヒント」をクリックすると、追加のお役立ち情報を見ることができます。",
      "specification": "<p>今回のタスクは、入力 <b>a</b> と <b>b</b> が両方とも 1 のときに出力が 0 になるように、入力を出力へとワイヤーやリレーで接続することです。</p>\n\n<p><b>1</b> は電流が流れていることを表し、<b>0</b> は電流が流れていないことを表します。</p>\n<p><b>V</b> 入力は常に電流が流れている状態です。つまり、常に 1 を保っています。</p>\n<p>厳密な仕様は以下の通りです。",
      "elaboration": "<p><b>nand</b>コンポーネント（nand ゲートともいう）は、論理回路を構成する上で根幹をなす部品です。nand ゲートだけを使って、あらゆる計算をこなす論理回路を構築することができます。だからこそ、まず nand ゲートを作成することから始めるのです。</p>\n\n<p><b>リレー</b>は、電気で制御されるスイッチで、制御信号によってスイッチのオンとオフが切り替わります。制御電流が電磁石に流れたり流れなかったりすることで、その電磁石の力で接点がオンやオフの位置へと動きます。</p>\n\n<p>初期の電子計算機は電磁リレーで作られていましたが、今日のコンピュータはトランジスタで作られています。トランジスタは、リレーと同様、スイッチとして振る舞う装置です。ただし、トランジスタにはリレーと違い物理的・機械的に動くパーツが一切ないため、リレーよりも（はるかに）小型で、安価で、しかも高速に動作することができます。\n\nリレーの方が仕組みを説明しやすいので、Nandgameではリレーを使用していますが、機能としてはリレーとトランジスタは同様のものです。一度 nand コンポーネントを作成してしまえば、それがリレーで作られているかトランジスタで作られているかは気にしなくて良くなるのです。\n",
      "spoilers": {
        "0": "リレーを使って 2 段階の処理を行います。最初のリレーでは、入力 a と b が両方とも 1 のときに 1 を出力します。次に、2 つ目のリレーで最初のリレーの出力を反転させ、1 を 0 に、0 を 1 に変えます。"
      },
      "hints": {
        "drag": "<b>ステップ1:</b> ツールボックスからコンポーネントをドラッグして、青いエリアに配置します。\n",
        "tap": "<b>ステップ2:</b> 配線を繋げるには、三角形をタップまたはドラッグしましょう。",
        "tap-end": "コンポーネントの（丸い）端子をタップすると、配線が繋がります。",
        "truth": "作成すべきコンポーネントの仕様: <p>どの入力に対しても、正しい出力をすること。",
        "toggle": "チェックボックスをクリックして入力信号を切り替え、回路にどのように影響するかを確認しましょう。",
        "verify": "コンポーネントが正しく設計できたと思ったら、ここをクリックしてください。"
      },
      "debriefing": "<b>nand</b>コンポーネントがツールボックスに追加され、次のステージで組み立ての部品として使用できるようになりました。"
    },
    "INV": {
      "title": "反転",
      "splash": "<p>次のタスクは、<b>nand</b>コンポーネントを使って<b>インバータ</b>（否定回路）コンポーネントを作成することです。</p>\n<p></p> \n<p>このステージからは、根底にあるスイッチの仕組みを考慮する必要はありません。物理的な nand ゲートでは電源への接続が必要ですが、図にこれを示す必要はありません。すべてのコンポーネントは暗黙のうちに電源に接続されているものとします。これからは、論理的な入力と出力に集中しましょう。</p>\n",
      "specification": "<p>次のタスクは、否定回路（インバータ、<b>inv</b>) コンポーネントを作成することです。</p>\n\n<p><b>inv</b>コンポーネントは、単一の入力と単一の出力を持ちます。\n<p>出力は入力の反対になるようにしてください。つまり、1 の場合は 0 を、0 の場合は 1 を出力しましょう。\n",
      "hints": {
        "0": "<b>nand</b>コンポーネントがツールボックスに追加されました。"
      }
    },
    "AND": {
      "title": "AND",
      "splash": "<p>次のタスクは、<b>nand</b>コンポーネントと<b>inv</b>コンポーネントだけを使って<b>AND</b>ゲートを作成することです。\n （このタスクは、どちらか一方のコンポーネントだけで解けるかもしれません。）",
      "specification": "<p><b>AND</b>ゲートの出力は、両方の入力が 1 のときに 1 になります。",
      "spoilers": {
        "0": "実は、\"NAND\" は \"NOT AND\" の略です。\n\n（訳注：原文は「\"NAND\" は \"Negative AND\" の略である」と主張していますが、Oxford English Dictionary によると not + and が語源とのことです。）"
      }
    },
    "OR": {
      "title": "OR",
      "specification": "<p><b>OR</b>ゲートの出力は、少なくとも1つの入力が1のときに1になります。</p>"
    },
    "XOR": {
      "title": "XOR",
      "specification": "<p><b>XOR</b>ゲートの出力は、2つの入力が異なるときに1になります。</p>",
      "elaboration": "XOR は <u>Exclusive OR</u> の略です。Exclusive とは「排他的」という意味です。<u>a または b のどちらか一方が 1 であり（これが「OR」）、両方が 1 というわけでない（これが「排他的」）</u>ことを意味します。"
    },
    "HALFADD": {
      "title": "半加算器",
      "splash": "<p>おめでとうございます。基本となる論理ゲートを作成できました。</p>\n<p>次のステップは、算術演算です。プロセッサは、数値を加算および減算できる必要があります。</p>\n\n<p>最初のタスクは、1ビットの数値を2つ足し合わせることです。結果は2ビットの数値になります。</p>\n<p>これを解くには、2進法の仕組みを理解している必要があります。</p>",
      "specification": "<p>2つのビットを足し合わせて2ビットの値を出力する<b>加算（add）</b>コンポーネントです。</p>\n<p><b>h</b>出力は上位 (high) ビット、<b>l</b>は下位 (low) ビットです。</p>",
      "elaboration": "<div class=subject>\n\n <h3>2進法</h3>\n\n <p>コンピュータは<b>2進法</b>を使用して算術演算を行います。</p>\n\n <p>我々が普段慣れ親しんでいる、0 から 9 の数字を使って数を書く通常の書き方と異なり、2進法では、すべての数値が 0 と 1 という数字だけを使って表されます。</p>\n\n <p>例:</p>\n\n <table class=data>\n <tr><th>2進法</th><th>10進法</th></tr>\n <tr><td>00</td><td>0</td></tr>\n <tr><td>01</td><td>1</td></tr>\n <tr><td>10</td><td>2</td></tr>\n <tr><td>11</td><td>3</td></tr>\n </table>\n\n2進法を理解するには、まず10進法の仕組みを考えてみましょう。10種類の異なる数字がありますが、桁の位置を調整することで任意の大きな数字を表現できます。3桁の数では、一番右の桁が1の位、右から2番目が10の位、右から3番目が100の位、というように続きます。\nということで、たとえば 273 は 2 × 100 + 7 × 10 + 3 × 1 です。各桁は 10 の累乗に対応しているので、これは「<u>10進法</u>」で数を表現している、と言います。\n\n<p>2進法では、0 と 1 の2つの数字だけが使用されます。2進法では各桁が 2 の累乗に対応しており、1の位、2の位、4の位、8の位、と続きます。\nということで、たとえば 2進法で 101 と書いたら 10進法でいう 5 に相当します（1 × 4 + 0 × 2 + 1 × 1）。離散的システムにおける2種類の状態を数字の 0 と 1 に対応するようにさせることができるので、2進法はデジタル回路に最適なのです。</p>\n\n<p><a href=\"https://www.mathsisfun.com/binary-number-system.html\">詳しくはこちら（英語）</a></p>\n<p><a href=\"https://www.cc.kyoto-su.ac.jp/~kbys/kiso/number/number1.html\">詳しくはこちら（日本語）</a></p>\n\n</div>\n",
      "spoilers": {
        "0": "2つの出力に対応する列をそれぞれ個別に見て、何かパターンが見えてくるか確認してみましょう。"
      }
    },
    "FULLADD": {
      "title": "全加算器",
      "splash": "<p>これで、2つのビットを足し合わせる加算器を作成できました。</p>\n<p>しかし、より大きな数値を加算するには、下の桁の加算からの「繰り上がり」を考慮する必要があります。</p>\n<p>このミッションでは、3つのビット a、b、c を加算する加算器コンポーネントを作成します。ここで、c は繰り上がり (carry) ビットです。</p>\n",
      "specification": "<p>3つのビット、<b>a</b>、<b>b</b>、<b>c</b> を加算する<b>加算器（add）</b>コンポーネントです。</p>\n<p>出力は2ビットの値になります。<b>h</b>出力は上位 (high) ビット、<b>l</b>は下位 (low) ビットです。</p>\n",
      "elaboration": "目的は、どれだけ大きい数値でも加算できるようにすることです。まず a と b という 2 つのビットで足し算を行い、もし繰り上がりビットがあればそれも考慮してもう一度足し算を行います。\n"
    },
    "ADD2": {
      "title": "多ビット加算器",
      "splash": "<p>次に、2ビットの数 2 つ（と、1ビットの繰り上がり）を加算する加算器を作成しましょう。</p>\n<p>2ビット加算器は、繰り返し使用することで、より大きな数に対応する加算器を作ることができます。</p>",
      "specification": "<p>2ビットの数 2 つと、1 ビットの繰り上がりを加算する加算器を作成しましょう。</p>\n<h3>入力</h3>\n<p><b>a1 a0</b> は2ビットの数値です。</p>\n<p><b>b1 b0</b> は2ビットの数値です。</p>\n<p><b>c</b>（繰り上がり入力）は1ビットの数値です。</p>\n\n<h3>出力</h3>\n<p>入力された数値を加算し、3ビットの数値 <b>c s1 s0</b> を出力します。ここで、<b>c</b> は上位ビットです。</p>\n\n<h3>例</h3>\n\n<table class='data'>\n<colgroup class=input><col><col></colgroup>\n<colgroup class=input><col><col></colgroup>\n<colgroup class=input><col></colgroup>\n<colgroup class=output><col><col><col></colgroup>\n<colgroup class=output><col></colgroup>\n<tr><th colspan=5>入力</th><th colspan=3>出力</th></tr>\n<tr><th>a1</th><th>a0</th><th>b1</th><th>b0</th><th>c</th><th>c</th><th>s1</th><th>s0</th></tr>\n<tr><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td><td>2+2+1=5</td></tr>\n</table>\n",
      "debriefing": "<p>2桁の2進数を加算するコンポーネントの設計を繰り返し適用することで、任意の大きさの数を加算することができます。</p>\n\n<p>我々は 16 ビットプロセッサを構築しようとしているので、今回のコンポーネントを繰り返し使用して 16 ビット加算器コンポーネントを作成し、<b>add 16</b>という名前でツールボックスに追加しておきますね。</p>\n"
    },
    "INC": {
      "title": "インクリメント\n",
      "splash": "<p>これで、16ビットの数値を扱う準備が整いました。</p>\n\n<p>今回のミッションは、16ビットの数値に 1 を加算する<b>インクリメント</b>コンポーネントを作成することです。</p>\n\n<p>16ビットの数値を扱うことになるため、図上での表現を簡略化しました。16本のバラバラの配線と16個の端子を描くのではなく、それらをまとめて1つの端子として表示し、小さな「<b>16</b>」ラベルで示しています。</p>\n",
      "specification": "<p>16ビットの数値に<b>1</b>を加算しましょう。</p>\n<p>結果が16ビットを超える場合は、繰り上がりを無視してください。</p>\n",
      "hints": {
        "0": "16ビットの出力を1つのかたまりとして扱い、出力は16進数と符号付き10進数で表示されます。\n",
        "1": "16ビットの入力を1つのかたまりとして扱い、値は16進数または10進数で入力できます。"
      },
      "elaboration": "<p><b>インクリメント</b>とは、数値を1増やすことを意味します。<a href=\"https://ja.wikipedia.org/wiki/%E6%95%B0%E5%8F%96%E5%99%A8\">ボタンを押すたびに数が 1 増えるカウンター</a>をイメージすると分かりやすいでしょう。</p>\n\n<h3>16ビット</h3>\n\n<p>プロセッサは常に複数のビットを同時に処理します。いま構築していっているプロセッサは<b>16ビットプロセッサ</b>であり、16ビットのまとまりを一度に処理します。</p>\n\n<p>現代のプロセッサ（コンピュータやスマートフォンに搭載されているもの）は通常32ビットまたは64ビットです。電子レンジのような組み込みプロセッサは、8ビットや4ビットだったりするかもしれません。16ビットは実用的なことをするのに十分なサイズであるため、ここでは16ビットを選択しています。</p>\n\n<h3>ワードとバイト</h3>\n<p>16ビットのまとまりは<b>ワード</b>と呼ばれます。ワードのサイズはプロセッサによって異なります。<b>バイト</b>は常に8ビットで、どの機械を使っているのかに依存しない単位です。</p>\n\n<div>\n<h3>バス</h3>\n<p>接続のまとまりを1つの単位として扱うものは<b>バス</b>と呼ばれます。入力と出力はそれぞれ16ビットのバスです。16ビット加算器の<b>A</b>入力と<b>B</b>入力もそれぞれ16ビットのバスです。</p>\n</div>\n\n<div>\n<h3>16進数</h3>\n<p>大きな2進数は、人間にとって読み書きが不便です。そのため、より短くて扱いやすい<b>16進数</b>が使われます。16進数では、A, B, C, D, E, F の文字が10から15を表します。</p>\n<p>16進数（hexadecimal、略して<u>hex</u>と呼ばれる）は、2進データを表現するのに便利です。なぜなら、16進数の1桁は常に4ビットに対応するからです。16ビットのワードは16進数では4桁になります。一方、10進数は2進数の桁と直接対応しないため、2進データを扱うのにはあまり便利ではありません。</p>\n\n<p>例:</p>\n<table class='data numbers'>\n<tr><th>hex</th><th>符号なし10進数</th><th>2進数</th></tr>\n<tr><td>1</td><td>1</td><td>0000000000000001</td></tr>\n<tr><td>F</td><td>15</td><td>0000000000001111</td></tr>\n<tr><td>10</td><td>16</td><td>0000000000010000</td></tr>\n<tr><td>2A</td><td>42</td><td>0000000000101010</td></tr>\n<tr><td>0100</td><td>256</td><td>0000000100000000</td></tr>\n<tr><td>FFFF</td><td>65535</td><td>1111111111111111</td></tr>\n</table>\n\n<p>便利機能として、16ビットの入力端子と出力端子では、数値が2進数と並んで16進数でも表示されるようにしておきました。16進数の値を入力すると、自動的に2進数に変換されます。</p>\n\n<p><a href=\"https://www.mathsisfun.com/hexadecimals.html\">16進数のチュートリアル（英語）</a>（おすすめのチュートリアルがある場合は原作者にお伝えください。）</p>\n<p><a href=\"https://zenn.dev/masahiro_toba/books/b42ef6fe522b38/viewer/72dbdd\">16進数のチュートリアル（日本語）</a>（おすすめのチュートリアルがある場合は、このチュートリアルを翻訳した <a href=\"https://github.com/hsjoihs\">hsjoihs</a> までお知らせください。）</p>\n\n\n</div>\n",
      "spoilers": {
        "0": "入力端子は何にも接続されていなくても構いません。接続されていない入力は常に0です。",
        "1": "入力に何も接続されていない<b>inv</b>ゲートは、常に1を出力します。",
        "2": "<b>add</b>コンポーネントの繰り上がり入力<b>c</b>は、1ビットの入力であり、0または1の2進数を受け付けます。"
      }
    },
    "SUB": {
      "title": "減算",
      "splash": "<p>次に、16ビットの数から16ビットの数を<b>減算</b>するコンポーネントを作成しましょう。",
      "specification": "<p>A から B を引いた結果を16ビットの数値として出力します。</p>\n<p>結果が0未満（つまり、マイナスの数）の場合、65536を足した値で表現されます。</p>\n<p>例:</p>\n\n<table class='data numbers'>\n<tr><th>結果</th><th>16ビット2進数</th><th>符号なし10進数</th></tr>\n<tr><td>1</td><td>0000000000000001</td><td>1</td></tr>\n<tr><td>0</td><td>0000000000000000</td><td>0</td></tr>\n<tr><td>-1</td><td>1111111111111111</td><td>65535</td></tr>\n<tr><td>-2</td><td>1111111111111110</td><td>65534</td></tr>\n<tr><td>-3</td><td>1111111111111101</td><td>65533</td></tr>\n</table>\n\n<p>（これは2の補数表現に相当します）</p>",
      "elaboration": "<div class=subject>\n\n <h3>2の補数</h3>\n <p>2の補数は、符号付き（正および負）の数を2進数で表現する標準的な方法です。</p>\n <p>右から15番目のビット（一番左のビット）は符号を示します。\n右から15番目のビットが0ならその数は正の数、1なら負の数です。負の数は、65536からその数を引いた値として表されます。\n 例えば、-127 なら 65536 - 127 = 65409 と計算することで符号なしの数値 65409に対応することが分かります。</p>\n\n <p>いくつかの例を示します。</p>\n <table class='data numbers'>\n <tr><th>符号付き10進数</th><th>符号なし10進数</th><th>16ビット2進数</th><th>16進数</th></tr>\n <tr><td>32767</td><td>32767</td><td>0111111111111111</td><td>7FFF</td></tr>\n <tr><td>1</td><td>1</td><td>0000000000000001</td><td>0001</td></tr>\n <tr><td>0</td><td>0</td><td>0000000000000000</td><td>0000</td></tr>\n <tr><td>-1</td><td>65535</td><td>1111111111111111</td><td>FFFF</td></tr>\n <tr><td>-2</td><td>65534</td><td>1111111111111110</td><td>FFFE</td></tr>\n <tr><td>-3</td><td>65533</td><td>1111111111111101</td><td>FFFD</td></tr>\n <tr><td>-32768</td><td>32768</td><td>1000000000000000</td><td>8000</td></tr>\n </table>\n\n <p>\n </div>\n",
      "spoilers": {
        "0": "ビットごとの反転（<b>inv16</b>）が数値にどのような影響を与えるか調べてみましょう。\n\n\n\n",
        "1": "数値をビット反転したものは、65535からその数を引いた値と同じです。負の数は、65536からその数を引いた値として表されます。",
        "2": "A - B = A + INV(B) + 1"
      },
      "debriefing": "おめでとうございます。基本となる算術演算を行うためのコンポーネントを作成できました。\n<p>現代のプロセッサは、乗算や除算、浮動小数点数など、はるかに複雑な算術演算をサポートしていますが、このゲームでは、動作するプロセッサを作成するために必要最低限のものだけを作成します。</p>"
    },
    "ISZERO": {
      "title": "ゼロであるかどうかの判定",
      "splash": "<p>次に、数値がゼロであるかどうかを示すコンポーネントを作成しましょう。まず、4ビットの数値に対してこれを実装します。</p>",
      "specification": "<p>入力されたすべてのビットが0の場合に限り、1を出力するようにします。</p>",
      "debriefing": "このアプローチは簡単に16ビットに拡張できるので、16ビットの数値がゼロであるかどうかを確認するコンポーネントを作成しておきます。"
    },
    "SIGN": {
      "title": "ゼロより小さいかどうかの判定",
      "splash": "<p>次に、16ビットの数値が負であるかどうかを示すコンポーネントを設計しましょう。</p>",
      "specification": "<p>16ビットの数値の入力が負の場合は1を出力します。</p>\n\n<p>仕様:</p>\n<table class='data'>\n<colgroup class=input><col></colgroup>\n<colgroup class=output><col></colgroup>\n<tr><th>入力</th><th>出力</th></tr>\n<tr><td>入力 ≧ 0</td><td>0</td></tr>\n<tr><td>入力 < 0</td><td>1</td></tr>\n</table>\n\n第15ビットが1であれば、その数値はゼロ未満とみなされます。\n\n<h3>ビットの番号付け</h3>\nビットは右から左に向かって番号が付けられ、右端のビットを0として数えます。したがって、16ビットのワードでは第15ビットが左端のビットです。\n",
      "elaboration": "このコンポーネントにおいては、16ビットの値を符号付き整数として解釈し、左端のビットを符号とみなします。\n\n<p>ツールボックスに<b>スプリッタ</b>を追加しました。スプリッタは16ビットのバスを16個の個別の端子に分割します。\nスプリッタを使用すると、16ビットの入力の個々のビットを確認できます。スプリッタには内部ロジックは一切ありません。\n\n<div class=subject>\n<h3>符号付きと符号なしの数値</h3>\n\n<p>16ビットの値は、符号付き整数としても符号なし整数としても解釈できます。0付近のいくつかの数値の例を示します：</p>\n\n<table class='data numbers'>\n<tr><th>16ビット2進数</th><th>16進数</th><th>符号なし10進数</th><th>符号付き10進数</th></tr>\n<tr><td>0000000000000001</td><td>0001</td><td>1</td><td>1</td></tr>\n<tr><td>0000000000000000</td><td>0000</td><td>0</td><td>0</td></tr>\n<tr><td>1111111111111111</td><td>FFFF</td><td>65535</td><td>-1</td></tr>\n<tr><td>1111111111111110</td><td>FFFE</td><td>65534</td><td>-2</td></tr>\n<tr><td>1111111111111101</td><td>FFFD</td><td>65533</td><td>-3</td></tr>\n</table>\n\n<p>便利なことに、数値を符号付きとして解釈しても符号なしとして解釈しても、加算と減算はまったく同じように動作します。\nこれはつまり、プロセッサは実際には符号付きかどうかを知らなくてよいということです。</p>\n\n<a href=\"https://gihyo.jp/assets/files/book/2017/978-4-7741-8523-1/download/P027.pdf\">2 の補数のチュートリアル（日本語）</a>\n</div>\n",
      "spoilers": {
        "0": "このコンポーネントにおいては、論理コンポーネントは必要なく、スプリッタだけで十分です。"
      }
    },
    "MULTIPLEXER": {
      "title": "セレクタ",
      "specification": "<p><b>セレクト</b>コンポーネントは、2つの入力ビットのうち1つを選んで出力します。</p>\n\n<p>どちらの入力が選ばれるかを示すのが、<b>s</b>（セレクト）ビットです。\n0の場合は<b>d0</b>が選ばれ、1の場合は<b>d1</b>が選ばれます。</p>",
      "elaboration": "<p>このコンポーネントは、<b>マルチプレクサ</b>（multiplexer）としても知られています。</p>"
    },
    "DEMUX": {
      "title": "スイッチ",
      "splash": "次に、データビットを2つの出力チャネルのどちらかに通す<b>スイッチ</b>を作成しましょう。",
      "specification": "<p><b>スイッチ</b>コンポーネントは、データビットを2つの出力チャネルのどちらかに通します。</p>\n\n<p><b>s</b>（セレクタ）にどちらのビットが入ってくるかによって、<b>d</b>（データ）ビットが<b>c1</b>か<b>c0</b>のどちらを通るかが決まります。</p>"
    },
    "SR_LATCH": {
      "title": "SRラッチ",
      "splash": "<p>これまでに作成した回路にはメモリがありませんが、面白いことができるコンピュータを作るためにはメモリが必要です。</p>\n\n<p>今回のミッションは、1ビットを保持できる<b>ラッチ</b>というコンポーネントを作成することです。<p>これは最も簡単な形式のメモリですが、これを基にしてより大きなコンピュータメモリを作成していくことができます。</p>",
      "specification": "<p><b>SRラッチ</b>（セット/リセットラッチ）コンポーネントは、1ビットの出力を保持することができます。</p>\n<p><b>s</b>=1（セット）で出力を1に設定します。</p>\n<p><b>r</b>=1（リセット）で出力を0に設定します。</p>\n<p><b>s</b>と<b>r</b>が両方とも1の場合、出力は変更されず、事前にセット・リセットされた値がそのまま出力されます。</p>\n<p>最初のセットまたはリセット信号が来るまで、出力は未定義です（つまり、任意の出力が許容されます）。</p>\n<p>また、両方の入力が0のときの出力も未定義です。</p>\n\n<table class='data'>\n<colgroup class=input><col><col></colgroup>\n<colgroup class=input><col></colgroup>\n<colgroup class=output><col></colgroup>\n<tr><th colspan=2>入力</th><th>出力</th></tr>\n<tr><th>s</th><th>r</th><th></th></tr>\n<tr><td>1</td><td>0</td><td>1</td></tr>\n<tr><td>0</td><td>1</td><td>0</td></tr>\n<tr><td>1</td><td>1</td><td>以前の出力</td></tr>\n<tr><td>0</td><td>0</td><td><u>使用されません</u></td></tr>\n</table>\n",
      "spoilers": {
        "0": "回路が入力を保持するためには、配線接続を循環させる必要があります。"
      }
    },
    "LATCH": {
      "title": "Dラッチ",
      "splash": "<p>SRラッチは、1を保持するためのピンと0を保持するためのピンが別々であることや、(0, 0)の入力状態が「禁止されている」ことといった面倒があるため、メモリを構築するための部品としてはあまり実用的ではありません。<b>データラッチ</b>では、SRラッチを拡張し、「データ用の入力が 1 つ、そのデータを保持するかどうかを示す入力が 1 つ」というふうに、入力がもっと実用的になるようになっています。</p>\n",
      "specification": "<p><b>Dラッチ</b>（データラッチ）コンポーネントは、1ビットを保持します。</p>\n<p><b>st</b>（ストア）が1のとき、<b>d</b>の値が保持され、出力されます。</p>\n<p><b>st</b>が0のとき、<b>d</b>の値は無視され、以前に保持された値が引き続き出力されます。</p>\n\n<table class='data'>\n<colgroup class=input><col><col></colgroup>\n<colgroup class=input><col></colgroup>\n<colgroup class=output><col></colgroup>\n<tr><th colspan=2>入力</th><th>出力</th></tr>\n<tr><th>st</th><th>d</th><th></th><th></th></tr>\n<tr><td>1</td><td>0</td><td>0</td></tr>\n<tr><td>1</td><td>1</td><td>1</td></tr>\n<tr><td>0</td><td>1</td><td>前回と同じ</td></tr>\n<tr><td>0</td><td>0</td><td>前回と同じ</td></tr>\n</table>\n\n<p>初めて<b>st</b>がセットされるまでの出力（初期出力）は未定義であり、任意の値が許容されます。</p>"
    },
    "DFF": {
      "title": "データフリップフロップ",
      "splash": "<p>ラッチを使うことで、時間の経過に伴って状態が変わる回路を作成できます。</p>\n\n<p>しかし、困ったことに、状態変化のタイミングが回路全体で同期されていないため、状態変化が回路内を伝播する順序が予測できず、競合や、一般的に予測不可能な結果を引き起こします。</p>\n\n<p>その解決策が<b>クロック信号</b>です。これは、周期的に変化し、状態を持つすべてのコンポーネントに接続される1ビットの信号です。</p>\n\n<p>コンポーネントがクロック信号の変化時にのみ出力を変更するようにすれば、回路全体で変化が同時に発生し、同期の問題を回避できます。</p>\n\n<p>このタスクでは、<b>フリップフロップ</b>コンポーネントを作成します。フリップフロップは、クロック信号が1のときにビットを保持する一方で、その後クロック信号が0に変わって初めて、保持されたビットを出力し始める部品です。</p>\n",
      "specification": "\n<p>DFF（データフリップフロップ）コンポーネントは、1ビットを保持し出力します。入力が変わっても出力はすぐには更新されません。変更は段階的に、<b>cl</b>（クロック）信号が0と1の間で切り替わるタイミングで行われます。</p>\n\n<p><b>cl</b>=0<br>この段階では入力フラグ<b>st</b>と<b>d</b>を変更できます。</p>\n<p><b>cl</b>=1<br><b>cl</b>が1に変わるときに<b>st</b>=1であれば、現在の<b>d</b>の値が保持されます。ただし、保持された値はまだ出力されません。</p>\n<p><b>cl</b>=0<br><b>cl</b>が再び0に変わると、以前に保持された値が出力されます。</p>\n\n<p>cl=1のときの入力の影響:</p>\n\n<table class=truth>\n<colgroup class=input><col><col></colgroup>\n<colgroup class=input><col></colgroup>\n<tr><th colspan=2>入力</th><th>影響</th></tr>\n<tr><th>st</th><th>d</th><th></th></tr>\n<tr><td>1</td><td>0</td><td>次の出力 = 0</td></tr>\n<tr><td>1</td><td>1</td><td>次の出力 = 1</td></tr>\n<tr><td>0</td><td>0</td><td>変更なし</td></tr>\n<tr><td>0</td><td>1</td><td>変更なし</td></tr>\n</table>\n\n<p><b>st</b>がまだセットされていなかったり、クロックが 1 サイクル回っていなかったりする段階での出力は未規定です。cl=1 となっている最中に入力に変更がないことを前提とします。</p>",
      "elaboration": "<p>クロック信号はメトロノームのようなもので、すべてのコンポーネントが同時に変化するようにします。</p>\n\n<p><b>クロックサイクル</b>とは、クロック信号が0から1に変わり、次に1から0に戻るまでの時間のことです。</p>\n\n<p>実際のプロセッサでは、振動する水晶を用いてクロック信号を発生させます。このゲームでは、クロック信号は手動入力となっており、手動で回路をテストできるようになっています。</p>\n\n<p><b>クロックレート</b>とは、クロックがどれだけ速く変化するかを示します。クロックレートが高いほど、コンピュータの動作が速くなります。</p>\n\n<p>注意: 「クロック」という名前は「時計」という意味ですが、クロック自体は時間を計るわけではありません。あくまで、規則的なリズムにのった信号を送るだけです。しかし、カウンターと組み合わせることで、時間を計測するコンポーネントを作成することもできます。</p>\n",
      "spoilers": {
        "0": "<p>ラッチを2つ使用する必要があります。</p>",
        "1": "<p>1つ目のラッチはcl=1のときに書き込まれるようにしましょう。2つ目のラッチは、cl=0のときに1つ目のラッチから書き込まれるようにしましょう。</p>"
      }
    },
    "DFF2": {
      "title": "レジスタ",
      "splash": "<p>ここまでで、1ビットのデータを保存できるようになりました。</p>\n<p>このミッションでは、2つのデータフリップフロップ（DFF）を組み合わせて、<b>2</b>ビットのデータを一度に保持したり取得したり操作を行います。</p>\n<p>（最終的には16ビットのワードを一度に保持したり取得したりしたいと考えていますが、2ビットを保持する方法さえわかってしまえば、それより大きなものも保持する方法は考えるまでもなく明らかです。）</p>\n",
      "specification": "<p><b>2ビットDFF</b>コンポーネントは、通常のデータフリップフロップと同様に動作しますが、1ビットではなく2ビット（<b>d1</b>と<b>d0</b>）が保持され、出力されます。</p>",
      "elaboration": "今回の、2ビットを保持する部品の設計は、そのまま繰り返すことができます。\n これを繰り返して16ビットを保持する部品を作成します。このコンポーネントは<b>レジスタ</b>と呼ばれます。\n",
      "debriefing": "2ビットを保持する部品の設計を繰り返していくことで、8ビット、16ビット、32ビットを保持する部品を簡単に作成していけます。\n<p>ここでは16ビットコンピュータを作り上げようとしていっているので、16ビットの保存ユニット（<b>レジスタ</b>と呼ばれる）を作ってツールボックスに追加しておきました。</p>\n"
    },
    "COUNTER": {
      "title": "カウンター",
      "splash": "<p>次のタスクは、クロックサイクルごとに数値をインクリメントする「カウンター」を作成することです。</p>\n<p>カウンターはプロセッサの中核をなすコンポーネントであり、命令の実行を進める役割を担います。</p>\n",
      "specification": "<p><b>カウンター</b>コンポーネントは、クロックサイクルごとに16ビットの数値をインクリメントします。</p>\n\n<p><b>st</b>（ストア）が1の場合、入力値<b>X</b>が新しいカウンターの値として使用されます。</p>\n\n<p><b>st</b>が0の場合、前回のカウンター値に1を加算します。</p>\n<p>カウンターの出力は、<b>cl</b>（クロック信号）が0に変わるときに更新されます。</p>\n\n<table class=\"data\">\n <colgroup class=input><col><col></colgroup>\n <colgroup class=input><col></colgroup>\n\n<tr><th colspan=2>入力</th><th>効果</th></tr>\n<tr><th>st</th><th>cl</th><th></th></tr>\n<tr><td>0</td><td>0</td><td class=text><b>next</b>を<b>output</b> + 1に設定</td></tr>\n<tr><td>1</td><td>0</td><td class=text><b>next</b>を<b>X</b>に設定</td></tr>\n</table>\n\n<p><b>output</b>はコンポーネントの現在の出力です。<b>next</b>は、<b>cl</b>が0に変わったタイミングで、「現在の出力」となります。</p>",
      "spoilers": {
        "0": "レジスタのコンポーネントが 1 つ必要です。"
      }
    },
    "RAM": {
      "title": "RAM",
      "splash": "<p>これで、レジスタに16ビットのワードを保存できるようになりました。</p>\n<p>これらのレジスタを積み増していくだけで、もっとたくさんの情報を記憶していくことができます。</p>\n<p>しかし、プロセッサは1度に1つのワードのみを操作するのですから、積み増したものの中から適切なワードだけを選択してそれを変更する方法が必要です。</p>\n<p>このために使うのが、メモリアドレスです。</p>\n<p>メモリ内の各ワードに番号を割り当てることで、この番号を使用して特定のワードを取得したり、特定のワードを上書きしたりすることができます。</p>\n\n<p>このミッションでは、2つのレジスタを使用し、1ビットのアドレスを使ってそれらをアドレス指定します。</p>\n",
      "specification": "<p>1ビットのアドレスで指定でき、書き込み可能な2つの16ビットレジスタを持つメモリを作成しましょう。</p>\n\n<h3>入力</h3>\n<p><b>ad</b>（アドレス）は、どちらの記憶領域にアクセスしにいくのかを示します。</p>\n<p><b>st</b>（ストア）は、書き込みを行うかどうかを示します。</p>\n<ul>\n<li>1の場合、<b>X</b>の値が指定された記憶領域に書き込まれます。</li>\n<li>0の場合、<b>X</b>は無視されます。</li>\n</ul>\n<p><b>X</b>（データ）は16ビットの値です。</p>\n<p><b>cl</b>（クロック信号）は状態の変化を同期させます。<b>cl</b>=0のときに<b>X</b>が保存されますが、<b>cl</b>が1に変わるまで出力は行われません。</p>\n\n<h3>出力</h3>\n<p><b>ad</b>で指定された記憶領域に現在保存されている値。</p>",
      "elaboration": "<p>2ワード分のメモリではあまり多くはありません。しかし、これがうまく機能すれば、この設計を再帰的に繰り返して、4ワード、8ワード、16ワードと増やしていくことができます。</p>\n\n<h3>アドレス指定</h3>\n<p>メモリ内のデータワードには、0から順に番号が付けられます。このメモリワードの番号が<b>アドレス</b>と呼ばれるものです。\nメモリ上の各ワードを読み書きするときには、このアドレスを使ってアクセスします。</p>\n\n<p>メモリにワードが2つしかない場合、アドレスは2通りのみであり、1ビットで選択できます。しかし、我々が作ろうとしているのは16ビットのアーキテクチャですから、16ビットのアドレスまで対応でき、つまり65,536個のワードの中から選んでアクセスすることができるようになります。</p>\n\n<p>このようなメモリはRAM（ランダムアクセスメモリ）と呼ばれ、アドレスさえ知っていれば、どのワードにもアクセスして値を更新することができます。</p>\n\n<div class=subject>\n<h3>バイトとKB</h3>\n<p>メモリ容量（RAMおよびその他のストレージ）は<b>バイト</b>で測定されます。1バイトは8ビットです。\n16ビットのアーキテクチャでは、16ビットワードを一度に保存および取得するため、各ワードは2バイトです。\n16ビットで表現できる範囲は0から65535までなので、65,536個のワードを持つことができ、バイト単位で測定するとその2倍、つまり131,072バイトになります。これは通常、128KB（KB = キロバイト）と表記されます。</p>\n\n<p>バイトを測定する場合、Kは1000を意味するのではなく、1024を意味するということになっており、128 × 1024 = 131,072なので、131,072は128Kになります。</p>\n\n</div>\n",
      "debriefing": "<p>1ビットのアドレスを指定できるこのRAMの設計を再帰的に繰り返すことで、より大きなRAMユニットを構築できます。</p>"
    },
    "DISPLAY16": {
      "title": "ディスプレイ",
      "specification": "<p>LEDランプを5×3のグリッドに配置します。ランプはメモリとつながっており、16ビットの値を書き込むと、1クロックサイクル後にランプがそれに応じて点灯します。</p>\n<p>ランプは、ビットパターン<code>1111001101001000</code>が<p><code>● ● ●<br>●</br>● ●<br>●<br>●</code></p>と表示されるように配置されるべきです。</p>\n<p>（最後のビットは使用されません）</p>"
    },
    "ALU_PRESET": {
      "title": "一項演算ALU",
      "splash": "<p>これまでに作成したコンポーネントは、すべて特定の単一の操作を実行してきました。</p>\n<p>ALU（算術論理演算装置）は、加算、減算、ビット反転など、さまざまな論理および算術演算を実行できる中核的なコンポーネントです。</p>\n<p>複数の制御ビットを受け取り、それによってどの操作を実行するのかが決定されます。</p>\n<p>ここでは、ALUを2段階に分けて実装していきましょう。最初のステップは「一項演算ALU」で、入力をビット反転させるか、ゼロに置き換えます。</p>",
      "specification": "<p><b>一項演算ALU</b>は、単一の入力<b>X</b>を変更します。どの操作を適用するかを選択するための、2つのフラグがあります。</p>\n\n<p><b>z</b>（ゼロ）が1の場合、入力の代わりに0が出力されます。</p>\n<p><b>n</b>（否定）が1の場合、入力がビット反転されます。</p>\n<p>両方が1の場合、出力は0のビット反転になります。つまり、操作を適用する順序に気をつける必要があるということです。</p>\n\n<p>仕様:</p>\n<table class='data'>\n<colgroup class=input><col><col></colgroup>\n<colgroup class=output><col></colgroup>\n<tr><th colspan=2>入力</th><th>出力</th></tr>\n<tr><th>z</th><th>n</th><th></th><th></th></tr>\n<tr><td>0</td><td>0</td><td>Xのまま</td></tr>\n<tr><td>1</td><td>0</td><td>0</td></tr>\n<tr><td>0</td><td>1</td><td>Xをビット反転</td></tr>\n<tr><td>1</td><td>1</td><td>0をビット反転</td></tr>\n</table>\n",
      "elaboration": "<h3>算術論理演算装置 (ALU) の設計</h3>\n\n<p>ALUは、さまざまな算術および論理演算を実行できるコンポーネントです。\n今回のALUでは、入力はXとYの2つがあり、それに加えていくつかのオプション（フラグ）も入力として受け取り、オプションに応じてどの操作を実行するかが選択されます。</p>\n\n<p>ALUが実行できる操作には、加算（X+Y）、減算（X-Y または Y-X）、ビットAND（X and Y）、ビットOR（X or Y）などがあります。また、一方の入力に対してのみ操作を実行することもできます。例えば、インクリメント（X+1）、デクリメント（X-1）、Xのビット反転、マイナスX（0-X）といったものを計算できます。</p>\n\n<p>これらすべての操作をサポートするには非常に複雑なコンポーネントが必要に見えるかもしれませんが、実際には、各入力と出力に対して2つの変更をしたりしなかったりするようにする機能を組み合わせるだけで達成できます。</p>\n\n<p>例えば、「減算」ステージで確認したように、1つの入力と出力をビット反転することさえできれば、減算を加算の形で実装できます。\nまた、「インクリメント」ステージで見たように、インクリメント（Xに1を加える）はYを0に置き換えてからビット反転して減算することで実装できます。</p>\n<p>入力 2 つおよび出力の中から上手く選んでビット反転またはゼロにするだけで、かなり多くの算術演算を実装できます。</p>\n\n<p>ということで、ALUを2段階で実装していきます。まず、入力をビット反転またはゼロにできる一項演算コンポーネントを構築します。（「一項演算」とは、単一の数に対して操作を行うことを意味します）\nそして次の段階で、この入力/出力修飾子を二項演算と組み合わせて、ALUを完成させます。</p>"
    },
    "ALU": {
      "title": "ALU",
      "splash": "<p>これで、ALU自体を構築できるようになりました。</p>\n<p>2つの16ビット入力値と、入力に対してどの操作を実行するかを指示する6つのオプションがあります。</p>",
      "specification": "<p>ALU（算術論理演算装置）は、2つの入力値<b>X</b>と<b>Y</b>に対して1つまたは複数の操作を実行します。</p>\n\n<p>6つのフラグにより、どのような操作が実行されるのか決まります。各フラグは、1になっているときに以下の操作を引き起こします。</p>\n\n<table>\n<tr><th>zx</th><td>Xを0にする</td></tr>\n<tr><th>nx</th><td>Xをビット反転する</td></tr>\n<tr><th>zy</th><td>Yを0にする</td></tr>\n<tr><th>ny</th><td>Yをビット反転する</td></tr>\n<tr><th>f</th><td>操作を選択する。\n <br />0の場合：出力はX AND Y\n <br />1の場合：出力はX + Y</td></tr>\n<tr><th>no</th><td>出力をビット反転する</td></tr>\n</table>\n\n<p>フラグは組み合わせることができ、その際には順序が重要です。（訳注：上の表での掲載順に基づいて操作を適用するということ）</p>\n<p>例えば、<b>zx</b>と<b>nx</b>が両方とも1の場合、Xは0のビット反転となります。</p>",
      "elaboration": "<p>6つのフラグを組み合わせることで、幅広い算術操作を実行できます。</p>\n<p>いくつかの例を挙げると、こうなります。</p>\n<table class='data numbers'>\n<tr><th>zx</th><th>nx</th><th>zy</th><th>ny</th><th>f</th><th>no</th><th>結果</th></tr>\n<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>X + Y</td></tr>\n<tr><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>X - 1</td></tr>\n<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>X AND Y</td></tr>\n<tr><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>X - Y</td></tr>\n<tr><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>\n<tr><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr>\n</table>\n\n<p>特定のフラグの組み合わせが特定の結果を引き起こす理由がすぐにはわからないかもしれませんが、自分で試してみてその仕組みを確認してみてください。</p>\n\n<p>（このALUの設計は、<a href=\"https://www.nand2tetris.org/\">Nand to Tetrisコース</a>に基づいており、許可を得てここで使用しています。）</p>\n"
    },
    "ALU_LOGIC": {
      "title": "ビット演算装置",
      "splash": "<p>これで、さまざまな操作を利用できるようになりました。さて、プロセッサの本質的に重要な役割として、「入力に基づいて異なる操作を選択できる」というものがあります。まずは、4種類のビット演算の中から1つを選択できるコンポーネントを作ることから始めましょう。</p>",
      "specification": "<p>2つの16ビット入力<b>X</b>と<b>Y</b>に対して、指定されたビット演算を行います。以下の4種類のうちどのビット演算を行うかは、2つのビットフラグ<b>op0</b>と<b>op1</b>で指定します。</p> \n\n<table class=truth>\n<tr><th>op1</th><th>op0</th><th>出力</th></tr> \n<tr><td>0</td><td>0</td><td>X AND Y</td></tr> \n<tr><td>0</td><td>1</td><td>X OR Y</td></tr> \n<tr><td>1</td><td>0</td><td>X XOR Y</td></tr> \n<tr><td>1</td><td>1</td><td>Xをビット反転</td></tr>\n</table>\n"
    },
    "ALU_ARITHMETIC": {
      "title": "算術演算装置",
      "specification": "<p>2つの16ビット入力<b>X</b>と<b>Y</b>に対して、指定された算術演算を行います。以下の4種類のうちどの算術演算を行うかは、2つのビットフラグ<b>op0</b>と<b>op1</b>で指定します。</p> \n\n<table class=truth>\n<tr><th>op1</th><th>op0</th><th>出力</th></tr>\n<tr><td>0</td><td>0</td><td>X + Y</td></tr>\n<tr><td>1</td><td>0</td><td>X - Y</td></tr>\n<tr><td>0</td><td>1</td><td>X + 1</td></tr>\n<tr><td>1</td><td>1</td><td>X - 1</td></tr>\n</table>"
    },
    "ALU2": {
      "title": "ALU",
      "specification": "<p>ALU（算術論理演算装置）は、論理演算（ビット演算）をする装置と算術演算をする装置を組み合わせたものです。</p>\n<table class=truth>\n<colgroup class=input><col><col><col></colgroup>\n<colgroup class=output><col></colgroup>\n<tr><th colspan=3>入力</th><th>出力</th></tr>\n<tr><th>u</th><th>op1</th><th>op0</th><th></th></tr>\n<tr><td>0</td><td>0</td><td>0</td><td>X AND Y</td></tr>\n<tr><td>0</td><td>0</td><td>1</td><td>X OR Y</td></tr>\n<tr><td>0</td><td>1</td><td>0</td><td>X XOR Y</td></tr>\n<tr><td>0</td><td>1</td><td>1</td><td>Xをビット反転</td></tr>\n<tr><td>1</td><td>0</td><td>0</td><td>X + Y</td></tr>\n<tr><td>1</td><td>1</td><td>0</td><td>X - Y</td></tr>\n<tr><td>1</td><td>0</td><td>1</td><td>X + 1</td></tr>\n<tr><td>1</td><td>1</td><td>1</td><td>X - 1</td></tr>\n</table>\n<p></p>\n\n<p>オペランドに変更を加えるためのフラグがさらに2つあります。</p>\n<ul>\n<li><b>sw</b>フラグが1の場合、<b>X</b>入力と<b>Y</b>入力が交換されます。</li>\n<li><b>zx</b>フラグが1の場合、左のオペランドが<code>0</code>に置き換えられます。</li>\n</ul>\n\n<p>例えば<code>X - Y</code>の操作に対してはこれらのフラグは以下のような影響をもたらします。</p>\n<table class=truth>\n<colgroup class=input span=2><colgroup class=output span=1>\n<tbody>\n<tr><th>zx</th><th>sw</th><th>実際に起こる操作</th></tr>\n<tr><td>0</td><td>0</td><td>X - Y</td></tr>\n<tr><td>0</td><td>1</td><td>Y - X</td></tr>\n<tr><td>1</td><td>0</td><td>0 - Y</td></tr>\n<tr><td>1</td><td>1</td><td>0 - X</td></tr>\n</tbody>\n</table>"
    },
    "OPCODES1": {
      "title": "オペコード",
      "specification": "<p>オペコードの式に対応する、ALUのビットフラグの組み合わせを選択してください。</p>\n<p>ほとんどの式については説明不要かと思います。</p>\n<p><b>~</b>はビット反転を表します。入力のすべてのビットを反転させます。</p>\n<p><b>&</b>はビット<b>AND</b>、<b>|</b>はビット<b>OR</b>です。</p>\n<p>注意: いくつかの行には、複数の正解がある場合があります。</p>",
      "spoilers": {
        "0": "減算ステージで見たように、Xのビット反転はマイナスXから1を引いたものに等しいです。つまり、~X = -X-1 です。\n",
        "1": "<p>したがって、<b>nx</b>フラグにより -X-1 が、<b>ny</b>フラグにより -Y-1 が出てきます。</p>"
      },
      "elaboration": "<p>このステージによって、ビットフラグの組み合わせを変えるだけで様々なビット演算および算術演算が実行できることが明らかになったかと思います。さらに、<b>オペコード</b>がどんな役割を果たしているのかも見て取れたかと思います。オペコードは、対応するビットの集まりをテキストや記号として表現したものであり、そのままのビットの集まりだったり2進数だったりといった表現方法と比べて、人間にとってはるかに読みやすく理解しやすいものです。</p>\n"
    },
    "CONDITION": {
      "title": "条件",
      "specification": "<p>以下の3つのフラグで、数値<b>X</b>に対する3つの可能な条件を表します。</p>\n\n<table class='data text'>\n<tr><th>フラグ</th><th>条件</th></tr>\n<tr><td><b>lt</b></td><td>0未満</td></tr>\n<tr><td><b>eq</b></td><td>0と等しい</td></tr>\n<tr><td><b>gt</b></td><td>0より大きい</td></tr>\n</table>\n\n<p>今回作るコンポーネントでは、入力フラグで指定された条件のどれかを入力Xが満たしているときに1を出力するようにしてください。</p>\n<p>なお、フラグを組み合わせることで、以下のような条件を指定することができます。</p>\n\n<table class='data'>\n<tr><th colspan=3>フラグ</th><th>1を出力する条件</th></tr>\n<tr><th>lt</th><th>eq</th><th>gt</th><th></th></tr>\n<tr><td>0</td><td>0</td><td>0</td><td>決して出力されない</td></tr>\n<tr><td>0</td><td>0</td><td>1</td><td>X &gt; 0</td></tr>\n<tr><td>0</td><td>1</td><td>0</td><td>X = 0</td></tr>\n<tr><td>0</td><td>1</td><td>1</td><td>X ≧ 0</td></tr>\n<tr><td>1</td><td>0</td><td>0</td><td>X &lt; 0</td></tr>\n<tr><td>1</td><td>0</td><td>1</td><td>X ≠ 0</td></tr>\n<tr><td>1</td><td>1</td><td>0</td><td>X ≦ 0</td></tr>\n<tr><td>1</td><td>1</td><td>1</td><td>常に出力される</td></tr>\n</table>\n",
      "spoilers": {
        "0": "3つの条件のうち、同時に真となるのは1つだけです。",
        "1": "最初の2つの条件を判定するためのコンポーネントは既に作りましたね。",
        "2": "「X ≦ 0」とは、Xが0より小さい<i>または</i>0に等しいことを意味します。",
        "3": "<b>lt</b>=1かつX < 0の場合、または<b>eq</b>=1かつX = 0の場合、または<b>gt</b>=1かつX > 0の場合に、出力が1になります。"
      }
    },
    "CPU_STATE": {
      "specification": "<p>プロセッサの用いる記憶装置には、AとDという2つの16ビットレジスタと、RAMユニットがあります。</p>\n\n<p><b>a</b>、<b>d</b>、<b>*a</b>のフラグと<b>X</b>入力を使って、1つ以上のレジスタを更新します。</p>\n\n<table class='data text'>\n<tr><th>フラグ</th><th>操作</th></tr>\n<tr><td>a</td><td>AレジスタにXを書き込む</td></tr>\n<tr><td>d</td><td>DレジスタにXを書き込む</td></tr>\n<tr><td>*a</td><td>Aレジスタで指定されたアドレスのRAMにXを書き込む</td></tr>\n</table>\n\n<p>フラグは組み合わせることができ、<b>X</b>を複数のレジスタに同時に書き込むことができます。3つフラグがすべて0の場合、X入力は無視されます。</p>\n\n<p><b>cl</b>はクロック信号です。</p>\n\n<table class='data text'>\n<tr><th>出力</th><th>内容</th></tr>\n<tr><td>A</td><td>Aレジスタの現在の値</td></tr>\n<tr><td>D</td><td>Dレジスタの現在の値</td></tr>\n<tr><td>*A</td><td>Aレジスタで指定されたアドレスのRAMに現在保存されている値</td></tr>\n</table>",
      "title": "記憶装置を統合する",
      "splash": "プロセッサは、レジスタとRAMという2種類の記憶装置を使用します。\n<p>レジスタはプロセッサによって直接アクセスでき、一時的なデータの保存や計算処理に使われます。\nRAMは大量のデータを保存できますが、同時に読み書きできるのは一つのアドレスに対してのみです。</p>\n<p>このプロセッサには、<b>A</b>と<b>D</b>という2つのレジスタと1つのRAMバンクがあります。</p>\n<p>このミッションでは、2つのレジスタとRAMバンクを組み合わせます。</p>",
      "elaboration": "<p>このプロセッサには、レジスタとRAMという2段階の記憶装置があります。</p>\n<p>RAMは圧倒的に大きな容量を持っていますが、RAMからデータを読み取るためにはアドレスが必要なので、アドレスそのものを記憶する装置がほしくなります。また、処理の途中で使う一時的な値を記憶することも必要になります。これらの需要に応えるべく、このプロセッサにはA（アドレス用）とD（データ用）の2つのレジスタがあります。</p>\n\n\n<p>実際のプロセッサには、十数個やそれ以上の個数のレジスタがあることが多いですが、今回のプロセッサでは必要最小限として2つだけ用意することにします。</p>\n\n<h3>フラグ</h3>\n<p><i>フラグ</i>とは、特定のオプションを選択するための入力ビットを指す用語です。複数のフラグがある場合、それぞれを独立にオンオフできます。\n例えば、このコンポーネントでは、<b>a</b>、<b>d</b>、<b>*a</b>のフラグがあり、これらは任意の組み合わせで設定することができます。すべてオンにすることも、すべてオフにすることも可能です。</p>\n"
    },
    "ALU_INSTRUCTION": {
      "title": "命令（インストラクション）",
      "specification": "<p>入力<b>I</b>は、ALUコンポーネントと条件コンポーネントに対する命令を指定します。Iのそれぞれのビットが以下のような役割を持つようにしてください。</p>\n\n<table class='data'>\n<tr><th>入力</th><th colspan=2>出力</th><th></th></tr>\n<tr><th>何番目のビットか</th><th>グループ</th><th>フラグ</th></tr>\n\n<tr><td>10</td><td>ALU</td><td>u</td></tr>\n<tr><td>9</td><td>ALU</td><td>op1</td></tr>\n<tr><td>8</td><td>ALU</td><td>op0</td></tr>\n<tr><td>7</td><td>ALU</td><td>zx</td></tr>\n<tr><td>6</td><td>ALU</td><td>sw</td></tr>\n\n<tr><td>5</td><td>書き込み先</td><td>a</td></tr>\n<tr><td>4</td><td>書き込み先</td><td>d</td></tr>\n<tr><td>3</td><td>書き込み先</td><td>*a</td></tr>\n\n<tr><td>2</td><td>条件</td><td>lt</td></tr>\n<tr><td>1</td><td>条件</td><td>eq</td></tr>\n<tr><td>0</td><td>条件</td><td>gt</td></tr>\n</table>\n\n<p>入力A、入力D、および 入力*Aは、それぞれのレジスタの値です。</p>\n<p>ALUのX入力にはDを、Y入力には命令の第12ビットに応じてAまたは*Aを指定してください。第12ビットが0の場合はA、1の場合は*Aです。</p>\n<p><b>R</b>出力には、ALU操作の結果を出力してください。</p>\n<p><b>j</b>フラグでは、ALUの出力がビット0-2で指定された条件に一致するかどうかを示してください。</p>\n"
    }
  },
  "ui": {
    "donate": "寄付する",
    "about": "このサイトについて",
    "custom_components": "カスタムコンポーネント",
    "btn_reset_state": "状態をリセット",
    "btn_clear_levels": "全てのステージの進捗を削除",
    "btn_skip_level": "このステージを飛ばす",
    "btn_next_level": "次のステージ",
    "btn_ok": "OK",
    "btn_close": "閉じる",
    "stay": "このステージに留まる",
    "click_to_reveal": "(クリックして表示)",
    "about_translation": "翻訳文に修正すべき箇所を見つけた方は、お手数ですが <a href=\"https://github.com/hsjoihs/nandgame-translate-ja/issues/new\">https://github.com/hsjoihs/nandgame-translate-ja</a> までご報告ください。",
    "btn_level_complete": "正誤判定をする",
    "level_help": "ステージのヘルプ",
    "solve_level": "ステージを解く",
    "level_complete": "ステージクリア！",
    "confirm_clear_levels": "全進捗が消えることになります。全てのステージの解答を削除して本当に最初からやり直しますか？",
    "btn_clear_canvas": "盤面をリセット",
    "level_error_header": "正しくありません。",
    "level_error": "現状の解答は仕様を満たしていません。",
    "custom_components_start": "カスタムコンポーネントは、自由に設計できます。特定のステージを解くための部品として使用することもできますし、単に楽しんで試行錯誤するために使っても構いません。"
  },
  "texts": {
    "translation_credits": ""
  }
}