{
  "missions": {
    "RELAY_NAND": {
      "title": "Nand",
      "splash": "<p><b>Nand Game</b>へようこそ！</p>\n<p>このゲームでは、基本的な部品（コンポーネント）からスタートして、コンピュータを組み上げていきます。\n  <div><p>このゲームは、順番にステージをこなす構成となっています。\n 各ステージでは、仕様に従って動作するコンポーネントを作成することが求められます。\n 作成したコンポーネントは、以降のステージで、新たに物を組み立てるための部品として使用できます。\n\n<p>このゲームでは、コンピュータアーキテクチャやソフトウェアについての事前知識は<b>一切</b>必要ありませんし、足し算や引き算以外の数学的なスキルも必要ありません。\n （ただし、解くのに結構時間がかかりそうなタスクもそこそこあるので、忍耐力は必要ですよ～）\n\n </div> <p>最初のタスクは、<b>nand</b>という部品を作成することです。\n <p>図の左側に、このタスクで作り上げるべき部品の厳密な仕様が載っています。\n 「ステージのヒント」をクリックすると、追加のお役立ち情報を見ることができます。",
      "specification": "<p>今回のタスクは、入力 <b>a</b> と <b>b</b> が両方とも 1 のときに出力が 0 になるように、入力を出力へとワイヤーやリレーで接続することです。</p>\n\n<p><b>1</b> は電流が流れていることを表し、<b>0</b> は電流が流れていないことを表します。</p>\n<p><b>V</b> 入力は常に電流が流れている状態です。つまり、常に 1 を保っています。</p>\n<p>厳密な仕様は以下の通りです。",
      "elaboration": "<p><b>nand</b>コンポーネント（nand ゲートともいう）は、論理回路を構成する上で根幹をなす部品です。nand ゲートだけを使って、あらゆる計算をこなす論理回路を構築することができます。だからこそ、まず nand ゲートを作成することから始めるのです。</p>\n\n<p><b>リレー</b>は、電気で制御されるスイッチで、制御信号によってスイッチのオンとオフが切り替わります。制御電流が電磁石に流れたり流れなかったりすることで、その電磁石の力で接点がオンやオフの位置へと動きます。</p>\n\n<p>初期の電子計算機は電磁リレーで作られていましたが、今日のコンピュータはトランジスタで作られています。トランジスタは、リレーと同様、スイッチとして振る舞う装置です。ただし、トランジスタにはリレーと違い物理的・機械的に動くパーツが一切ないため、リレーよりも（はるかに）小型で、安価で、しかも高速に動作することができます。\n\nリレーの方が仕組みを説明しやすいので、Nandgameではリレーを使用していますが、機能としてはリレーとトランジスタは同様のものです。一度 nand コンポーネントを作成してしまえば、それがリレーで作られているかトランジスタで作られているかは気にしなくて良くなるのです。\n",
      "spoilers": {
        "0": "リレーを使って 2 段階の処理を行います。最初のリレーでは、入力 a と b が両方とも 1 のときに 1 を出力します。次に、2 つ目のリレーで最初のリレーの出力を反転させ、1 を 0 に、0 を 1 に変えます。"
      },
      "hints": {
        "drag": "<b>ステップ1:</b> ツールボックスからコンポーネントをドラッグして、青いエリアに配置します。\n",
        "tap": "<b>ステップ2:</b> 配線を繋げるには、三角形をタップまたはドラッグしましょう。",
        "tap-end": "コンポーネントの（丸い）端子をタップすると、配線が繋がります。",
        "truth": "作成すべきコンポーネントの仕様: <p>どの入力に対しても、正しい出力をすること。",
        "toggle": "チェックボックスをクリックして入力信号を切り替え、回路にどのように影響するかを確認しましょう。",
        "verify": "コンポーネントが正しく設計できたと思ったら、ここをクリックしてください。"
      },
      "debriefing": "<b>nand</b>コンポーネントがツールボックスに追加され、次のステージで組み立ての部品として使用できるようになりました。"
    },
    "INV": {
      "title": "反転",
      "splash": "<p>次のタスクは、<b>nand</b>コンポーネントを使って<b>インバータ</b>（否定回路）コンポーネントを作成することです。</p>\n<p></p> \n<p>このステージからは、根底にあるスイッチの仕組みを考慮する必要はありません。物理的な nand ゲートでは電源への接続が必要ですが、図にこれを示す必要はありません。すべてのコンポーネントは暗黙のうちに電源に接続されているものとします。これからは、論理的な入力と出力に集中しましょう。</p>\n",
      "specification": "<p>次のタスクは、否定回路（インバータ、<b>inv</b>) コンポーネントを作成することです。</p>\n\n<p><b>inv</b>コンポーネントは、単一の入力と単一の出力を持ちます。\n<p>出力は入力の反対になるようにしてください。つまり、1 の場合は 0 を、0 の場合は 1 を出力しましょう。\n",
      "hints": {
        "0": "<b>nand</b>コンポーネントがツールボックスに追加されました。"
      }
    },
    "AND": {
      "title": "AND",
      "splash": "<p>次のタスクは、<b>nand</b>コンポーネントと<b>inv</b>コンポーネントだけを使って<b>AND</b>ゲートを作成することです。\n （このタスクは、どちらか一方のコンポーネントだけで解けるかもしれません。）",
      "specification": "<p><b>AND</b>ゲートの出力は、両方の入力が 1 のときに 1 になります。",
      "spoilers": {
        "0": "実は、\"NAND\" は \"NOT AND\" の略です。\n\n（訳注：原文は「\"NAND\" は \"Negative AND\" の略である」と主張していますが、Oxford English Dictionary によると not + and が語源とのことです。）"
      }
    },
    "OR": {
      "title": "OR",
      "specification": "<p><b>OR</b>ゲートの出力は、少なくとも1つの入力が1のときに1になります。</p>"
    },
    "XOR": {
      "title": "XOR",
      "specification": "<p><b>XOR</b>ゲートの出力は、2つの入力が異なるときに1になります。</p>",
      "elaboration": "XOR は <u>Exclusive OR</u> の略です。Exclusive とは「排他的」という意味です。<u>a または b のどちらか一方が 1 であり（これが「OR」）、両方が 1 というわけでない（これが「排他的」）</u>ことを意味します。"
    },
    "HALFADD": {
      "title": "半加算器",
      "splash": "<p>おめでとうございます。基本となる論理ゲートを作成できました。</p>\n<p>次のステップは、算術演算です。プロセッサは、数値を加算および減算できる必要があります。</p>\n\n<p>最初のタスクは、1ビットの数値を2つ足し合わせることです。結果は2ビットの数値になります。</p>\n<p>これを解くには、2進法の仕組みを理解している必要があります。</p>",
      "specification": "<p>2つのビットを足し合わせて2ビットの値を出力する<b>加算（add）</b>コンポーネントです。</p>\n<p><b>h</b>出力は上位 (high) ビット、<b>l</b>は下位 (low) ビットです。</p>",
      "elaboration": "<div class=subject>\n\n <h3>2進法</h3>\n\n <p>コンピュータは<b>2進法</b>を使用して算術演算を行います。</p>\n\n <p>我々が普段慣れ親しんでいる、0 から 9 の数字を使って数を書く通常の書き方と異なり、2進法では、すべての数値が 0 と 1 という数字だけを使って表されます。</p>\n\n <p>例:</p>\n\n <table class=data>\n <tr><th>2進法</th><th>10進法</th></tr>\n <tr><td>00</td><td>0</td></tr>\n <tr><td>01</td><td>1</td></tr>\n <tr><td>10</td><td>2</td></tr>\n <tr><td>11</td><td>3</td></tr>\n </table>\n\n2進法を理解するには、まず10進法の仕組みを考えてみましょう。10種類の異なる数字がありますが、桁の位置を調整することで任意の大きな数字を表現できます。3桁の数では、一番右の桁が1の位、右から2番目が10の位、右から3番目が100の位、というように続きます。\nということで、たとえば 273 は 2 × 100 + 7 × 10 + 3 × 1 です。各桁は 10 の累乗に対応しているので、これは「<u>10進法</u>」で数を表現している、と言います。\n\n<p>2進法では、0 と 1 の2つの数字だけが使用されます。2進法では各桁が 2 の累乗に対応しており、1の位、2の位、4の位、8の位、と続きます。\nということで、たとえば 2進法で 101 と書いたら 10進法でいう 5 に相当します（1 × 4 + 0 × 2 + 1 × 1）。離散的システムにおける2種類の状態を数字の 0 と 1 に対応するようにさせることができるので、2進法はデジタル回路に最適なのです。</p>\n\n<p><a href=\"https://www.mathsisfun.com/binary-number-system.html\">詳しくはこちら（英語）</a></p>\n<p><a href=\"https://www.cc.kyoto-su.ac.jp/~kbys/kiso/number/number1.html\">詳しくはこちら（日本語）</a></p>\n\n</div>\n",
      "spoilers": {
        "0": "2つの出力に対応する列をそれぞれ個別に見て、何かパターンが見えてくるか確認してみましょう。"
      }
    },
    "FULLADD": {
      "title": "全加算器",
      "splash": "<p>これで、2つのビットを足し合わせる加算器を作成できました。</p>\n<p>しかし、より大きな数値を加算するには、下の桁の加算からの「繰り上がり」を考慮する必要があります。</p>\n<p>このミッションでは、3つのビット a、b、c を加算する加算器コンポーネントを作成します。ここで、c は繰り上がり (carry) ビットです。</p>\n",
      "specification": "<p>3つのビット、<b>a</b>、<b>b</b>、<b>c</b> を加算する<b>加算器（add）</b>コンポーネントです。</p>\n<p>出力は2ビットの値になります。<b>h</b>出力は上位 (high) ビット、<b>l</b>は下位 (low) ビットです。</p>\n",
      "elaboration": "目的は、どれだけ大きい数値でも加算できるようにすることです。まず a と b という 2 つのビットで足し算を行い、もし繰り上がりビットがあればそれも考慮してもう一度足し算を行います。\n"
    },
    "ADD2": {
      "title": "多ビット加算器",
      "splash": "<p>次に、2ビットの数 2 つ（と、1ビットの繰り上がり）を加算する加算器を作成しましょう。</p>\n<p>2ビット加算器は、繰り返し使用することで、より大きな数に対応する加算器を作ることができます。</p>",
      "specification": "<p>2ビットの数 2 つと、1 ビットの繰り上がりを加算する加算器を作成しましょう。</p>\n<h3>入力</h3>\n<p><b>a1 a0</b> は2ビットの数値です。</p>\n<p><b>b1 b0</b> は2ビットの数値です。</p>\n<p><b>c</b>（繰り上がり入力）は1ビットの数値です。</p>\n\n<h3>出力</h3>\n<p>入力された数値を加算し、3ビットの数値 <b>c s1 s0</b> を出力します。ここで、<b>c</b> は上位ビットです。</p>\n\n<h3>例</h3>\n\n<table class='data'>\n<colgroup class=input><col><col></colgroup>\n<colgroup class=input><col><col></colgroup>\n<colgroup class=input><col></colgroup>\n<colgroup class=output><col><col><col></colgroup>\n<colgroup class=output><col></colgroup>\n<tr><th colspan=5>入力</th><th colspan=3>出力</th></tr>\n<tr><th>a1</th><th>a0</th><th>b1</th><th>b0</th><th>c</th><th>c</th><th>s1</th><th>s0</th></tr>\n<tr><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td><td>2+2+1=5</td></tr>\n</table>\n",
      "debriefing": "<p>2桁の2進数を加算するコンポーネントの設計を繰り返し適用することで、任意の大きさの数を加算することができます。</p>\n\n<p>我々は 16 ビットプロセッサを構築しようとしているので、今回のコンポーネントを繰り返し使用して 16 ビット加算器コンポーネントを作成し、<b>add 16</b>という名前でツールボックスに追加しておきますね。</p>\n"
    },
    "INC": {
      "title": "インクリメント\n",
      "splash": "<p>これで、16ビットの数値を扱う準備が整いました。</p>\n\n<p>今回のミッションは、16ビットの数値に 1 を加算する<b>インクリメント</b>コンポーネントを作成することです。</p>\n\n<p>16ビットの数値を扱うことになるため、図上での表現を簡略化しました。16本のバラバラの配線と16個の端子を描くのではなく、それらをまとめて1つの端子として表示し、小さな「<b>16</b>」ラベルで示しています。</p>\n",
      "specification": "<p>16ビットの数値に<b>1</b>を加算しましょう。</p>\n<p>結果が16ビットを超える場合は、繰り上がりを無視してください。</p>\n",
      "hints": {
        "0": "16ビットの出力を1つのかたまりとして扱い、出力は16進数と符号付き10進数で表示されます。\n",
        "1": "16ビットの入力を1つのかたまりとして扱い、値は16進数または10進数で入力できます。"
      },
      "elaboration": "<p><b>インクリメント</b>とは、数値を1増やすことを意味します。<a href=\"https://ja.wikipedia.org/wiki/%E6%95%B0%E5%8F%96%E5%99%A8\">ボタンを押すたびに数が 1 増えるカウンター</a>をイメージすると分かりやすいでしょう。</p>\n\n<h3>16ビット</h3>\n\n<p>プロセッサは常に複数のビットを同時に処理します。いま構築していっているプロセッサは<b>16ビットプロセッサ</b>であり、16ビットのまとまりを一度に処理します。</p>\n\n<p>現代のプロセッサ（コンピュータやスマートフォンに搭載されているもの）は通常32ビットまたは64ビットです。電子レンジのような組み込みプロセッサは、8ビットや4ビットだったりするかもしれません。16ビットは実用的なことをするのに十分なサイズであるため、ここでは16ビットを選択しています。</p>\n\n<h3>ワードとバイト</h3>\n<p>16ビットのまとまりは<b>ワード</b>と呼ばれます。ワードのサイズはプロセッサによって異なります。<b>バイト</b>は常に8ビットで、どの機械を使っているのかに依存しない単位です。</p>\n\n<div>\n<h3>バス</h3>\n<p>接続のまとまりを1つの単位として扱うものは<b>バス</b>と呼ばれます。入力と出力はそれぞれ16ビットのバスです。16ビット加算器の<b>A</b>入力と<b>B</b>入力もそれぞれ16ビットのバスです。</p>\n</div>\n\n<div>\n<h3>16進数</h3>\n<p>大きな2進数は、人間にとって読み書きが不便です。そのため、より短くて扱いやすい<b>16進数</b>が使われます。16進数では、A, B, C, D, E, F の文字が10から15を表します。</p>\n<p>16進数（hexadecimal、略して<u>hex</u>と呼ばれる）は、2進データを表現するのに便利です。なぜなら、16進数の1桁は常に4ビットに対応するからです。16ビットのワードは16進数では4桁になります。一方、10進数は2進数の桁と直接対応しないため、2進データを扱うのにはあまり便利ではありません。</p>\n\n<p>例:</p>\n<table class='data numbers'>\n<tr><th>hex</th><th>符号なし10進数</th><th>2進数</th></tr>\n<tr><td>1</td><td>1</td><td>0000000000000001</td></tr>\n<tr><td>F</td><td>15</td><td>0000000000001111</td></tr>\n<tr><td>10</td><td>16</td><td>0000000000010000</td></tr>\n<tr><td>2A</td><td>42</td><td>0000000000101010</td></tr>\n<tr><td>0100</td><td>256</td><td>0000000100000000</td></tr>\n<tr><td>FFFF</td><td>65535</td><td>1111111111111111</td></tr>\n</table>\n\n<p>便利機能として、16ビットの入力端子と出力端子では、数値が2進数と並んで16進数でも表示されるようにしておきました。16進数の値を入力すると、自動的に2進数に変換されます。</p>\n\n<p><a href=\"https://www.mathsisfun.com/hexadecimals.html\">16進数のチュートリアル（英語）</a>（おすすめのチュートリアルがある場合は原作者にお伝えください。）</p>\n<p><a href=\"https://zenn.dev/masahiro_toba/books/b42ef6fe522b38/viewer/72dbdd\">16進数のチュートリアル（日本語）</a>（おすすめのチュートリアルがある場合は、このチュートリアルを翻訳した <a href=\"https://github.com/hsjoihs\">hsjoihs</a> までお知らせください。）</p>\n\n\n</div>\n",
      "spoilers": {
        "0": "入力端子は何にも接続されていなくても構いません。接続されていない入力は常に0です。",
        "1": "入力に何も接続されていない<b>inv</b>ゲートは、常に1を出力します。",
        "2": "<b>add</b>コンポーネントの繰り上がり入力<b>c</b>は、1ビットの入力であり、0または1の2進数を受け付けます。"
      }
    },
    "SUB": {
      "title": "減算",
      "splash": "<p>次に、16ビットの数から16ビットの数を<b>減算</b>するコンポーネントを作成しましょう。",
      "specification": "<p>A から B を引いた結果を16ビットの数値として出力します。</p>\n<p>結果が0未満（つまり、マイナスの数）の場合、65536を足した値で表現されます。</p>\n<p>例:</p>\n\n<table class='data numbers'>\n<tr><th>結果</th><th>16ビット2進数</th><th>符号なし10進数</th></tr>\n<tr><td>1</td><td>0000000000000001</td><td>1</td></tr>\n<tr><td>0</td><td>0000000000000000</td><td>0</td></tr>\n<tr><td>-1</td><td>1111111111111111</td><td>65535</td></tr>\n<tr><td>-2</td><td>1111111111111110</td><td>65534</td></tr>\n<tr><td>-3</td><td>1111111111111101</td><td>65533</td></tr>\n</table>\n\n<p>（これは2の補数表現に相当します）</p>",
      "elaboration": "<div class=subject>\n\n <h3>2の補数</h3>\n <p>2の補数は、符号付き（正および負）の数を2進数で表現する標準的な方法です。</p>\n <p>右から15番目のビット（一番左のビット）は符号を示します。\n右から15番目のビットが0ならその数は正の数、1なら負の数です。負の数は、65536からその数を引いた値として表されます。\n 例えば、-127 なら 65536 - 127 = 65409 と計算することで符号なしの数値 65409に対応することが分かります。</p>\n\n <p>いくつかの例を示します。</p>\n <table class='data numbers'>\n <tr><th>符号付き10進数</th><th>符号なし10進数</th><th>16ビット2進数</th><th>16進数</th></tr>\n <tr><td>32767</td><td>32767</td><td>0111111111111111</td><td>7FFF</td></tr>\n <tr><td>1</td><td>1</td><td>0000000000000001</td><td>0001</td></tr>\n <tr><td>0</td><td>0</td><td>0000000000000000</td><td>0000</td></tr>\n <tr><td>-1</td><td>65535</td><td>1111111111111111</td><td>FFFF</td></tr>\n <tr><td>-2</td><td>65534</td><td>1111111111111110</td><td>FFFE</td></tr>\n <tr><td>-3</td><td>65533</td><td>1111111111111101</td><td>FFFD</td></tr>\n <tr><td>-32768</td><td>32768</td><td>1000000000000000</td><td>8000</td></tr>\n </table>\n\n <p>\n </div>\n",
      "spoilers": {
        "0": "ビットごとの反転（<b>inv16</b>）が数値にどのような影響を与えるか調べてみましょう。\n\n\n\n",
        "1": "数値をビット反転したものは、65535からその数を引いた値と同じです。負の数は、65536からその数を引いた値として表されます。",
        "2": "A - B = A + INV(B) + 1"
      },
      "debriefing": "おめでとうございます。基本となる算術演算を行うためのコンポーネントを作成できました。\n<p>現代のプロセッサは、乗算や除算、浮動小数点数など、はるかに複雑な算術演算をサポートしていますが、このゲームでは、動作するプロセッサを作成するために必要最低限のものだけを作成します。</p>"
    },
    "ISZERO": {
      "title": "ゼロであるかどうかの判定",
      "splash": "<p>次に、数値がゼロであるかどうかを示すコンポーネントを作成しましょう。まず、4ビットの数値に対してこれを実装します。</p>",
      "specification": "<p>入力されたすべてのビットが0の場合に限り、1を出力するようにします。</p>",
      "debriefing": "このアプローチは簡単に16ビットに拡張できるので、16ビットの数値がゼロであるかどうかを確認するコンポーネントを作成しておきます。"
    },
    "SIGN": {
      "title": "ゼロより小さいかどうかの判定",
      "splash": "<p>次に、16ビットの数値が負であるかどうかを示すコンポーネントを設計しましょう。</p>",
      "specification": "<p>16ビットの数値の入力が負の場合は1を出力します。</p>\n\n<p>仕様:</p>\n<table class='data'>\n<colgroup class=input><col></colgroup>\n<colgroup class=output><col></colgroup>\n<tr><th>入力</th><th>出力</th></tr>\n<tr><td>入力 ≧ 0</td><td>0</td></tr>\n<tr><td>入力 < 0</td><td>1</td></tr>\n</table>\n\n第15ビットが1であれば、その数値はゼロ未満とみなされます。\n\n<h3>ビットの番号付け</h3>\nビットは右から左に向かって番号が付けられ、右端のビットを0として数えます。したがって、16ビットのワードでは第15ビットが左端のビットです。\n",
      "elaboration": "このコンポーネントにおいては、16ビットの値を符号付き整数として解釈し、左端のビットを符号とみなします。\n\n<p>ツールボックスに<b>スプリッタ</b>を追加しました。スプリッタは16ビットのバスを16個の個別の端子に分割します。\nスプリッタを使用すると、16ビットの入力の個々のビットを確認できます。スプリッタには内部ロジックは一切ありません。\n\n<div class=subject>\n<h3>符号付きと符号なしの数値</h3>\n\n<p>16ビットの値は、符号付き整数としても符号なし整数としても解釈できます。0付近のいくつかの数値の例を示します：</p>\n\n<table class='data numbers'>\n<tr><th>16ビット2進数</th><th>16進数</th><th>符号なし10進数</th><th>符号付き10進数</th></tr>\n<tr><td>0000000000000001</td><td>0001</td><td>1</td><td>1</td></tr>\n<tr><td>0000000000000000</td><td>0000</td><td>0</td><td>0</td></tr>\n<tr><td>1111111111111111</td><td>FFFF</td><td>65535</td><td>-1</td></tr>\n<tr><td>1111111111111110</td><td>FFFE</td><td>65534</td><td>-2</td></tr>\n<tr><td>1111111111111101</td><td>FFFD</td><td>65533</td><td>-3</td></tr>\n</table>\n\n<p>便利なことに、数値を符号付きとして解釈しても符号なしとして解釈しても、加算と減算はまったく同じように動作します。\nこれはつまり、プロセッサは実際には符号付きかどうかを知らなくてよいということです。</p>\n\n<a href=\"https://gihyo.jp/assets/files/book/2017/978-4-7741-8523-1/download/P027.pdf\">2 の補数のチュートリアル（日本語）</a>\n</div>\n",
      "spoilers": {
        "0": "このコンポーネントにおいては、論理コンポーネントは必要なく、スプリッタだけで十分です。"
      }
    },
    "MULTIPLEXER": {
      "title": "セレクタ",
      "specification": "<p><b>セレクト</b>コンポーネントは、2つの入力ビットのうち1つを選んで出力します。</p>\n\n<p>どちらの入力が選ばれるかを示すのが、<b>s</b>（セレクト）ビットです。\n0の場合は<b>d0</b>が選ばれ、1の場合は<b>d1</b>が選ばれます。</p>",
      "elaboration": "<p>このコンポーネントは、<b>マルチプレクサ</b>（multiplexer）としても知られています。</p>"
    },
    "DEMUX": {
      "title": "スイッチ",
      "splash": "次に、データビットを2つの出力チャネルのどちらかに通す<b>スイッチ</b>を作成しましょう。",
      "specification": "<p><b>スイッチ</b>コンポーネントは、データビットを2つの出力チャネルのどちらかに通します。</p>\n\n<p><b>s</b>（セレクタ）にどちらのビットが入ってくるかによって、<b>d</b>（データ）ビットが<b>c1</b>か<b>c0</b>のどちらを通るかが決まります。</p>"
    },
    "SR_LATCH": {
      "title": "SRラッチ",
      "splash": "<p>これまでに作成した回路にはメモリがありませんが、面白いことができるコンピュータを作るためにはメモリが必要です。</p>\n\n<p>今回のミッションは、1ビットを保持できる<b>ラッチ</b>というコンポーネントを作成することです。<p>これは最も簡単な形式のメモリですが、これを基にしてより大きなコンピュータメモリを作成していくことができます。</p>",
      "specification": "<p><b>SRラッチ</b>（セット/リセットラッチ）コンポーネントは、1ビットの出力を保持することができます。</p>\n<p><b>s</b>=1（セット）で出力を1に設定します。</p>\n<p><b>r</b>=1（リセット）で出力を0に設定します。</p>\n<p><b>s</b>と<b>r</b>が両方とも1の場合、出力は変更されず、事前にセット・リセットされた値がそのまま出力されます。</p>\n<p>最初のセットまたはリセット信号が来るまで、出力は未定義です（つまり、任意の出力が許容されます）。</p>\n<p>また、両方の入力が0のときの出力も未定義です。</p>\n\n<table class='data'>\n<colgroup class=input><col><col></colgroup>\n<colgroup class=input><col></colgroup>\n<colgroup class=output><col></colgroup>\n<tr><th colspan=2>入力</th><th>出力</th></tr>\n<tr><th>s</th><th>r</th><th></th></tr>\n<tr><td>1</td><td>0</td><td>1</td></tr>\n<tr><td>0</td><td>1</td><td>0</td></tr>\n<tr><td>1</td><td>1</td><td>以前の出力</td></tr>\n<tr><td>0</td><td>0</td><td><u>使用されません</u></td></tr>\n</table>\n",
      "spoilers": {
        "0": "回路が入力を保持するためには、配線接続を循環させる必要があります。"
      }
    },
    "LATCH": {
      "title": "Dラッチ",
      "splash": "<p>SRラッチは、1を保持するためのピンと0を保持するためのピンが別々であることや、(0, 0)の入力状態が「禁止されている」ことといった面倒があるため、メモリを構築するための部品としてはあまり実用的ではありません。<b>データラッチ</b>では、SRラッチを拡張し、「データ用の入力が 1 つ、そのデータを保持するかどうかを示す入力が 1 つ」というふうに、入力がもっと実用的になるようになっています。</p>\n",
      "specification": "<p><b>Dラッチ</b>（データラッチ）コンポーネントは、1ビットを保持します。</p>\n<p><b>st</b>（ストア）が1のとき、<b>d</b>の値が保持され、出力されます。</p>\n<p><b>st</b>が0のとき、<b>d</b>の値は無視され、以前に保持された値が引き続き出力されます。</p>\n\n<table class='data'>\n<colgroup class=input><col><col></colgroup>\n<colgroup class=input><col></colgroup>\n<colgroup class=output><col></colgroup>\n<tr><th colspan=2>入力</th><th>出力</th></tr>\n<tr><th>st</th><th>d</th><th></th><th></th></tr>\n<tr><td>1</td><td>0</td><td>0</td></tr>\n<tr><td>1</td><td>1</td><td>1</td></tr>\n<tr><td>0</td><td>1</td><td>前回と同じ</td></tr>\n<tr><td>0</td><td>0</td><td>前回と同じ</td></tr>\n</table>\n\n<p>初めて<b>st</b>がセットされるまでの出力（初期出力）は未定義であり、任意の値が許容されます。</p>"
    },
    "DFF": {
      "title": "データフリップフロップ",
      "splash": "<p>ラッチを使うことで、時間の経過に伴って状態が変わる回路を作成できます。</p>\n\n<p>しかし、困ったことに、状態変化のタイミングが回路全体で同期されていないため、状態変化が回路内を伝播する順序が予測できず、競合や、一般的に予測不可能な結果を引き起こします。</p>\n\n<p>その解決策が<b>クロック信号</b>です。これは、周期的に変化し、状態を持つすべてのコンポーネントに接続される1ビットの信号です。</p>\n\n<p>コンポーネントがクロック信号の変化時にのみ出力を変更するようにすれば、回路全体で変化が同時に発生し、同期の問題を回避できます。</p>\n\n<p>このタスクでは、<b>フリップフロップ</b>コンポーネントを作成します。フリップフロップは、クロック信号が1のときにビットを保持する一方で、その後クロック信号が0に変わって初めて、保持されたビットを出力し始める部品です。</p>\n",
      "specification": "\n<p>DFF（データフリップフロップ）コンポーネントは、1ビットを保持し出力します。入力が変わっても出力はすぐには更新されません。変更は段階的に、<b>cl</b>（クロック）信号が0と1の間で切り替わるタイミングで行われます。</p>\n\n<p><b>cl</b>=0<br>この段階では入力フラグ<b>st</b>と<b>d</b>を変更できます。</p>\n<p><b>cl</b>=1<br><b>cl</b>が1に変わるときに<b>st</b>=1であれば、現在の<b>d</b>の値が保持されます。ただし、保持された値はまだ出力されません。</p>\n<p><b>cl</b>=0<br><b>cl</b>が再び0に変わると、以前に保持された値が出力されます。</p>\n\n<p>cl=1のときの入力の影響:</p>\n\n<table class=truth>\n<colgroup class=input><col><col></colgroup>\n<colgroup class=input><col></colgroup>\n<tr><th colspan=2>入力</th><th>影響</th></tr>\n<tr><th>st</th><th>d</th><th></th></tr>\n<tr><td>1</td><td>0</td><td>次の出力 = 0</td></tr>\n<tr><td>1</td><td>1</td><td>次の出力 = 1</td></tr>\n<tr><td>0</td><td>0</td><td>変更なし</td></tr>\n<tr><td>0</td><td>1</td><td>変更なし</td></tr>\n</table>\n\n<p><b>st</b>がまだセットされていなかったり、クロックが 1 サイクル回っていなかったりする段階での出力は未規定です。cl=1 となっている最中に入力に変更がないことを前提とします。</p>",
      "elaboration": "<p>クロック信号はメトロノームのようなもので、すべてのコンポーネントが同時に変化するようにします。</p>\n\n<p><b>クロックサイクル</b>とは、クロック信号が0から1に変わり、次に1から0に戻るまでの時間のことです。</p>\n\n<p>実際のプロセッサでは、振動する水晶を用いてクロック信号を発生させます。このゲームでは、クロック信号は手動入力となっており、手動で回路をテストできるようになっています。</p>\n\n<p><b>クロックレート</b>とは、クロックがどれだけ速く変化するかを示します。クロックレートが高いほど、コンピュータの動作が速くなります。</p>\n\n<p>注意: 「クロック」という名前は「時計」という意味ですが、クロック自体は時間を計るわけではありません。あくまで、規則的なリズムにのった信号を送るだけです。しかし、カウンターと組み合わせることで、時間を計測するコンポーネントを作成することもできます。</p>\n",
      "spoilers": {
        "0": "<p>ラッチを2つ使用する必要があります。</p>",
        "1": "<p>1つ目のラッチはcl=1のときに書き込まれるようにしましょう。2つ目のラッチは、cl=0のときに1つ目のラッチから書き込まれるようにしましょう。</p>"
      }
    },
    "DFF2": {
      "title": "レジスタ",
      "splash": "<p>ここまでで、1ビットのデータを保存できるようになりました。</p>\n<p>このミッションでは、2つのデータフリップフロップ（DFF）を組み合わせて、<b>2</b>ビットのデータを一度に保持したり取得したり操作を行います。</p>\n<p>（最終的には16ビットのワードを一度に保持したり取得したりしたいと考えていますが、2ビットを保持する方法さえわかってしまえば、それより大きなものも保持する方法は考えるまでもなく明らかです。）</p>\n",
      "specification": "<p><b>2ビットDFF</b>コンポーネントは、通常のデータフリップフロップと同様に動作しますが、1ビットではなく2ビット（<b>d1</b>と<b>d0</b>）が保持され、出力されます。</p>",
      "elaboration": "今回の、2ビットを保持する部品の設計は、そのまま繰り返すことができます。\n これを繰り返して16ビットを保持する部品を作成します。このコンポーネントは<b>レジスタ</b>と呼ばれます。\n",
      "debriefing": "2ビットを保持する部品の設計を繰り返していくことで、8ビット、16ビット、32ビットを保持する部品を簡単に作成していけます。\n<p>ここでは16ビットコンピュータを作り上げようとしていっているので、16ビットの保存ユニット（<b>レジスタ</b>と呼ばれる）を作ってツールボックスに追加しておきました。</p>\n"
    },
    "COUNTER": {
      "title": "カウンター",
      "splash": "<p>次のタスクは、クロックサイクルごとに数値をインクリメントする「カウンター」を作成することです。</p>\n<p>カウンターはプロセッサの中核をなすコンポーネントであり、命令の実行を進める役割を担います。</p>\n",
      "specification": "<p><b>カウンター</b>コンポーネントは、クロックサイクルごとに16ビットの数値をインクリメントします。</p>\n\n<p><b>st</b>（ストア）が1の場合、入力値<b>X</b>が新しいカウンターの値として使用されます。</p>\n\n<p><b>st</b>が0の場合、前回のカウンター値に1を加算します。</p>\n<p>カウンターの出力は、<b>cl</b>（クロック信号）が0に変わるときに更新されます。</p>\n\n<table class=\"data\">\n <colgroup class=input><col><col></colgroup>\n <colgroup class=input><col></colgroup>\n\n<tr><th colspan=2>入力</th><th>効果</th></tr>\n<tr><th>st</th><th>cl</th><th></th></tr>\n<tr><td>0</td><td>0</td><td class=text><b>next</b>を<b>output</b> + 1に設定</td></tr>\n<tr><td>1</td><td>0</td><td class=text><b>next</b>を<b>X</b>に設定</td></tr>\n</table>\n\n<p><b>output</b>はコンポーネントの現在の出力です。<b>next</b>は、<b>cl</b>が0に変わったタイミングで、「現在の出力」となります。</p>",
      "spoilers": {
        "0": "レジスタのコンポーネントが 1 つ必要です。"
      }
    },
    "RAM": {
      "title": "RAM",
      "splash": "<p>これで、レジスタに16ビットのワードを保存できるようになりました。</p>\n<p>これらのレジスタを積み増していくだけで、もっとたくさんの情報を記憶していくことができます。</p>\n<p>しかし、プロセッサは1度に1つのワードのみを操作するのですから、積み増したものの中から適切なワードだけを選択してそれを変更する方法が必要です。</p>\n<p>このために使うのが、メモリアドレスです。</p>\n<p>メモリ内の各ワードに番号を割り当てることで、この番号を使用して特定のワードを取得したり、特定のワードを上書きしたりすることができます。</p>\n\n<p>このミッションでは、2つのレジスタを使用し、1ビットのアドレスを使ってそれらをアドレス指定します。</p>\n",
      "specification": "<p>1ビットのアドレスで指定でき、書き込み可能な2つの16ビットレジスタを持つメモリを作成しましょう。</p>\n\n<h3>入力</h3>\n<p><b>ad</b>（アドレス）は、どちらの記憶領域にアクセスしにいくのかを示します。</p>\n<p><b>st</b>（ストア）は、書き込みを行うかどうかを示します。</p>\n<ul>\n<li>1の場合、<b>X</b>の値が指定された記憶領域に書き込まれます。</li>\n<li>0の場合、<b>X</b>は無視されます。</li>\n</ul>\n<p><b>X</b>（データ）は16ビットの値です。</p>\n<p><b>cl</b>（クロック信号）は状態の変化を同期させます。<b>cl</b>=0のときに<b>X</b>が保存されますが、<b>cl</b>が1に変わるまで出力は行われません。</p>\n\n<h3>出力</h3>\n<p><b>ad</b>で指定された記憶領域に現在保存されている値。</p>",
      "elaboration": "<p>2ワード分のメモリではあまり多くはありません。しかし、これがうまく機能すれば、この設計を再帰的に繰り返して、4ワード、8ワード、16ワードと増やしていくことができます。</p>\n\n<h3>アドレス指定</h3>\n<p>メモリ内のデータワードには、0から順に番号が付けられます。このメモリワードの番号が<b>アドレス</b>と呼ばれるものです。\nメモリ上の各ワードを読み書きするときには、このアドレスを使ってアクセスします。</p>\n\n<p>メモリにワードが2つしかない場合、アドレスは2通りのみであり、1ビットで選択できます。しかし、我々が作ろうとしているのは16ビットのアーキテクチャですから、16ビットのアドレスまで対応でき、つまり65,536個のワードの中から選んでアクセスすることができるようになります。</p>\n\n<p>このようなメモリはRAM（ランダムアクセスメモリ）と呼ばれ、アドレスさえ知っていれば、どのワードにもアクセスして値を更新することができます。</p>\n\n<div class=subject>\n<h3>バイトとKB</h3>\n<p>メモリ容量（RAMおよびその他のストレージ）は<b>バイト</b>で測定されます。1バイトは8ビットです。\n16ビットのアーキテクチャでは、16ビットワードを一度に保存および取得するため、各ワードは2バイトです。\n16ビットで表現できる範囲は0から65535までなので、65,536個のワードを持つことができ、バイト単位で測定するとその2倍、つまり131,072バイトになります。これは通常、128KB（KB = キロバイト）と表記されます。</p>\n\n<p>バイトを測定する場合、Kは1000を意味するのではなく、1024を意味するということになっており、128 × 1024 = 131,072なので、131,072は128Kになります。</p>\n\n</div>\n",
      "debriefing": "<p>1ビットのアドレスを指定できるこのRAMの設計を再帰的に繰り返すことで、より大きなRAMユニットを構築できます。</p>"
    },
    "DISPLAY16": {
      "title": "ディスプレイ",
      "specification": "<p>LEDランプを5×3のグリッドに配置します。ランプはメモリとつながっており、16ビットの値を書き込むと、1クロックサイクル後にランプがそれに応じて点灯します。</p>\n<p>ランプは、ビットパターン<code>1111001101001000</code>が<p><code>● ● ●<br>●</br>● ●<br>●<br>●</code></p>と表示されるように配置されるべきです。</p>\n<p>（最後のビットは使用されません）</p>"
    },
    "ALU_PRESET": {
      "title": "一項演算ALU",
      "splash": "<p>これまでに作成したコンポーネントは、すべて特定の単一の操作を実行してきました。</p>\n<p>ALU（算術論理演算装置）は、加算、減算、ビット反転など、さまざまな論理および算術演算を実行できる中核的なコンポーネントです。</p>\n<p>複数の制御ビットを受け取り、それによってどの操作を実行するのかが決定されます。</p>\n<p>ここでは、ALUを2段階に分けて実装していきましょう。最初のステップは「一項演算ALU」で、入力をビット反転させるか、ゼロに置き換えます。</p>",
      "specification": "<p><b>一項演算ALU</b>は、単一の入力<b>X</b>を変更します。どの操作を適用するかを選択するための、2つのフラグがあります。</p>\n\n<p><b>z</b>（ゼロ）が1の場合、入力の代わりに0が出力されます。</p>\n<p><b>n</b>（否定）が1の場合、入力がビット反転されます。</p>\n<p>両方が1の場合、出力は0のビット反転になります。つまり、操作を適用する順序に気をつける必要があるということです。</p>\n\n<p>仕様:</p>\n<table class='data'>\n<colgroup class=input><col><col></colgroup>\n<colgroup class=output><col></colgroup>\n<tr><th colspan=2>入力</th><th>出力</th></tr>\n<tr><th>z</th><th>n</th><th></th><th></th></tr>\n<tr><td>0</td><td>0</td><td>Xのまま</td></tr>\n<tr><td>1</td><td>0</td><td>0</td></tr>\n<tr><td>0</td><td>1</td><td>Xをビット反転</td></tr>\n<tr><td>1</td><td>1</td><td>0をビット反転</td></tr>\n</table>\n",
      "elaboration": "<h3>算術論理演算装置 (ALU) の設計</h3>\n\n<p>ALUは、さまざまな算術および論理演算を実行できるコンポーネントです。\n今回のALUでは、入力はXとYの2つがあり、それに加えていくつかのオプション（フラグ）も入力として受け取り、オプションに応じてどの操作を実行するかが選択されます。</p>\n\n<p>ALUが実行できる操作には、加算（X+Y）、減算（X-Y または Y-X）、ビットAND（X and Y）、ビットOR（X or Y）などがあります。また、一方の入力に対してのみ操作を実行することもできます。例えば、インクリメント（X+1）、デクリメント（X-1）、Xのビット反転、マイナスX（0-X）といったものを計算できます。</p>\n\n<p>これらすべての操作をサポートするには非常に複雑なコンポーネントが必要に見えるかもしれませんが、実際には、各入力と出力に対して2つの変更をしたりしなかったりするようにする機能を組み合わせるだけで達成できます。</p>\n\n<p>例えば、「減算」ステージで確認したように、1つの入力と出力をビット反転することさえできれば、減算を加算の形で実装できます。\nまた、「インクリメント」ステージで見たように、インクリメント（Xに1を加える）はYを0に置き換えてからビット反転して減算することで実装できます。</p>\n<p>入力 2 つおよび出力の中から上手く選んでビット反転またはゼロにするだけで、かなり多くの算術演算を実装できます。</p>\n\n<p>ということで、ALUを2段階で実装していきます。まず、入力をビット反転またはゼロにできる一項演算コンポーネントを構築します。（「一項演算」とは、単一の数に対して操作を行うことを意味します）\nそして次の段階で、この入力/出力修飾子を二項演算と組み合わせて、ALUを完成させます。</p>"
    },
    "ALU": {
      "title": "ALU",
      "splash": "<p>これで、ALU自体を構築できるようになりました。</p>\n<p>2つの16ビット入力値と、入力に対してどの操作を実行するかを指示する6つのオプションがあります。</p>",
      "specification": "<p>ALU（算術論理演算装置）は、2つの入力値<b>X</b>と<b>Y</b>に対して1つまたは複数の操作を実行します。</p>\n\n<p>6つのフラグにより、どのような操作が実行されるのか決まります。各フラグは、1になっているときに以下の操作を引き起こします。</p>\n\n<table>\n<tr><th>zx</th><td>Xを0にする</td></tr>\n<tr><th>nx</th><td>Xをビット反転する</td></tr>\n<tr><th>zy</th><td>Yを0にする</td></tr>\n<tr><th>ny</th><td>Yをビット反転する</td></tr>\n<tr><th>f</th><td>操作を選択する。\n <br />0の場合：出力はX AND Y\n <br />1の場合：出力はX + Y</td></tr>\n<tr><th>no</th><td>出力をビット反転する</td></tr>\n</table>\n\n<p>フラグは組み合わせることができ、その際には順序が重要です。（訳注：上の表での掲載順に基づいて操作を適用するということ）</p>\n<p>例えば、<b>zx</b>と<b>nx</b>が両方とも1の場合、Xは0のビット反転となります。</p>",
      "elaboration": "<p>6つのフラグを組み合わせることで、幅広い算術操作を実行できます。</p>\n<p>いくつかの例を挙げると、こうなります。</p>\n<table class='data numbers'>\n<tr><th>zx</th><th>nx</th><th>zy</th><th>ny</th><th>f</th><th>no</th><th>結果</th></tr>\n<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>X + Y</td></tr>\n<tr><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>X - 1</td></tr>\n<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>X AND Y</td></tr>\n<tr><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>X - Y</td></tr>\n<tr><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>\n<tr><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr>\n</table>\n\n<p>特定のフラグの組み合わせが特定の結果を引き起こす理由がすぐにはわからないかもしれませんが、自分で試してみてその仕組みを確認してみてください。</p>\n\n<p>（このALUの設計は、<a href=\"https://www.nand2tetris.org/\">Nand to Tetrisコース</a>に基づいており、許可を得てここで使用しています。）</p>\n"
    },
    "ALU_LOGIC": {
      "title": "ビット演算装置",
      "splash": "<p>これで、さまざまな操作を利用できるようになりました。さて、プロセッサの本質的に重要な役割として、「入力に基づいて異なる操作を選択できる」というものがあります。まずは、4種類のビット演算の中から1つを選択できるコンポーネントを作ることから始めましょう。</p>",
      "specification": "<p>2つの16ビット入力<b>X</b>と<b>Y</b>に対して、指定されたビット演算を行います。以下の4種類のうちどのビット演算を行うかは、2つのビットフラグ<b>op0</b>と<b>op1</b>で指定します。</p> \n\n<table class=truth>\n<tr><th>op1</th><th>op0</th><th>出力</th></tr> \n<tr><td>0</td><td>0</td><td>X AND Y</td></tr> \n<tr><td>0</td><td>1</td><td>X OR Y</td></tr> \n<tr><td>1</td><td>0</td><td>X XOR Y</td></tr> \n<tr><td>1</td><td>1</td><td>Xをビット反転</td></tr>\n</table>\n"
    },
    "ALU_ARITHMETIC": {
      "title": "算術演算装置",
      "specification": "<p>2つの16ビット入力<b>X</b>と<b>Y</b>に対して、指定された算術演算を行います。以下の4種類のうちどの算術演算を行うかは、2つのビットフラグ<b>op0</b>と<b>op1</b>で指定します。</p> \n\n<table class=truth>\n<tr><th>op1</th><th>op0</th><th>出力</th></tr>\n<tr><td>0</td><td>0</td><td>X + Y</td></tr>\n<tr><td>1</td><td>0</td><td>X - Y</td></tr>\n<tr><td>0</td><td>1</td><td>X + 1</td></tr>\n<tr><td>1</td><td>1</td><td>X - 1</td></tr>\n</table>"
    },
    "ALU2": {
      "title": "ALU",
      "specification": "<p>ALU（算術論理演算装置）は、論理演算（ビット演算）をする装置と算術演算をする装置を組み合わせたものです。</p>\n<table class=truth>\n<colgroup class=input><col><col><col></colgroup>\n<colgroup class=output><col></colgroup>\n<tr><th colspan=3>入力</th><th>出力</th></tr>\n<tr><th>u</th><th>op1</th><th>op0</th><th></th></tr>\n<tr><td>0</td><td>0</td><td>0</td><td>X AND Y</td></tr>\n<tr><td>0</td><td>0</td><td>1</td><td>X OR Y</td></tr>\n<tr><td>0</td><td>1</td><td>0</td><td>X XOR Y</td></tr>\n<tr><td>0</td><td>1</td><td>1</td><td>Xをビット反転</td></tr>\n<tr><td>1</td><td>0</td><td>0</td><td>X + Y</td></tr>\n<tr><td>1</td><td>1</td><td>0</td><td>X - Y</td></tr>\n<tr><td>1</td><td>0</td><td>1</td><td>X + 1</td></tr>\n<tr><td>1</td><td>1</td><td>1</td><td>X - 1</td></tr>\n</table>\n<p></p>\n\n<p>オペランドに変更を加えるためのフラグがさらに2つあります。</p>\n<ul>\n<li><b>sw</b>フラグが1の場合、<b>X</b>入力と<b>Y</b>入力が交換されます。</li>\n<li><b>zx</b>フラグが1の場合、左のオペランドが<code>0</code>に置き換えられます。</li>\n</ul>\n\n<p>例えば<code>X - Y</code>の操作に対してはこれらのフラグは以下のような影響をもたらします。</p>\n<table class=truth>\n<colgroup class=input span=2><colgroup class=output span=1>\n<tbody>\n<tr><th>zx</th><th>sw</th><th>実際に起こる操作</th></tr>\n<tr><td>0</td><td>0</td><td>X - Y</td></tr>\n<tr><td>0</td><td>1</td><td>Y - X</td></tr>\n<tr><td>1</td><td>0</td><td>0 - Y</td></tr>\n<tr><td>1</td><td>1</td><td>0 - X</td></tr>\n</tbody>\n</table>"
    },
    "OPCODES1": {
      "title": "オペコード",
      "specification": "<p>オペコードの式に対応する、ALUのビットフラグの組み合わせを選択してください。</p>\n<p>ほとんどの式については説明不要かと思います。</p>\n<p><b>~</b>はビット反転を表します。入力のすべてのビットを反転させます。</p>\n<p><b>&</b>はビット<b>AND</b>、<b>|</b>はビット<b>OR</b>です。</p>\n<p>注意: いくつかの行には、複数の正解がある場合があります。</p>",
      "spoilers": {
        "0": "減算ステージで見たように、Xのビット反転はマイナスXから1を引いたものに等しいです。つまり、~X = -X-1 です。\n",
        "1": "<p>したがって、<b>nx</b>フラグにより -X-1 が、<b>ny</b>フラグにより -Y-1 が出てきます。</p>"
      },
      "elaboration": "<p>このステージによって、ビットフラグの組み合わせを変えるだけで様々なビット演算および算術演算が実行できることが明らかになったかと思います。さらに、<b>オペコード</b>がどんな役割を果たしているのかも見て取れたかと思います。オペコードは、対応するビットの集まりをテキストや記号として表現したものであり、そのままのビットの集まりだったり2進数だったりといった表現方法と比べて、人間にとってはるかに読みやすく理解しやすいものです。</p>\n"
    },
    "CONDITION": {
      "title": "条件",
      "specification": "<p>以下の3つのフラグで、数値<b>X</b>に対する3つの可能な条件を表します。</p>\n\n<table class='data text'>\n<tr><th>フラグ</th><th>条件</th></tr>\n<tr><td><b>lt</b></td><td>0未満</td></tr>\n<tr><td><b>eq</b></td><td>0と等しい</td></tr>\n<tr><td><b>gt</b></td><td>0より大きい</td></tr>\n</table>\n\n<p>今回作るコンポーネントでは、入力フラグで指定された条件のどれかを入力Xが満たしているときに1を出力するようにしてください。</p>\n<p>なお、フラグを組み合わせることで、以下のような条件を指定することができます。</p>\n\n<table class='data'>\n<tr><th colspan=3>フラグ</th><th>1を出力する条件</th></tr>\n<tr><th>lt</th><th>eq</th><th>gt</th><th></th></tr>\n<tr><td>0</td><td>0</td><td>0</td><td>決して出力されない</td></tr>\n<tr><td>0</td><td>0</td><td>1</td><td>X &gt; 0</td></tr>\n<tr><td>0</td><td>1</td><td>0</td><td>X = 0</td></tr>\n<tr><td>0</td><td>1</td><td>1</td><td>X ≧ 0</td></tr>\n<tr><td>1</td><td>0</td><td>0</td><td>X &lt; 0</td></tr>\n<tr><td>1</td><td>0</td><td>1</td><td>X ≠ 0</td></tr>\n<tr><td>1</td><td>1</td><td>0</td><td>X ≦ 0</td></tr>\n<tr><td>1</td><td>1</td><td>1</td><td>常に出力される</td></tr>\n</table>\n",
      "spoilers": {
        "0": "3つの条件のうち、同時に真となるのは1つだけです。",
        "1": "最初の2つの条件を判定するためのコンポーネントは既に作りましたね。",
        "2": "「X ≦ 0」とは、Xが0より小さい<u>または</u>0に等しいことを意味します。",
        "3": "<b>lt</b>=1かつX < 0の場合、または<b>eq</b>=1かつX = 0の場合、または<b>gt</b>=1かつX > 0の場合に、出力が1になります。"
      }
    },
    "CPU_STATE": {
      "specification": "<p>プロセッサの用いる記憶装置には、AとDという2つの16ビットレジスタと、RAMユニットがあります。</p>\n\n<p><b>a</b>、<b>d</b>、<b>*a</b>のフラグと<b>X</b>入力を使って、1つ以上のレジスタを更新します。</p>\n\n<table class='data text'>\n<tr><th>フラグ</th><th>操作</th></tr>\n<tr><td>a</td><td>AレジスタにXを書き込む</td></tr>\n<tr><td>d</td><td>DレジスタにXを書き込む</td></tr>\n<tr><td>*a</td><td>Aレジスタで指定されたアドレスのRAMにXを書き込む</td></tr>\n</table>\n\n<p>フラグは組み合わせることができ、<b>X</b>を複数のレジスタに同時に書き込むことができます。3つフラグがすべて0の場合、X入力は無視されます。</p>\n\n<p><b>cl</b>はクロック信号です。</p>\n\n<table class='data text'>\n<tr><th>出力</th><th>内容</th></tr>\n<tr><td>A</td><td>Aレジスタの現在の値</td></tr>\n<tr><td>D</td><td>Dレジスタの現在の値</td></tr>\n<tr><td>*A</td><td>Aレジスタで指定されたアドレスのRAMに現在保存されている値</td></tr>\n</table>",
      "title": "記憶装置を統合する",
      "splash": "プロセッサは、レジスタとRAMという2種類の記憶装置を使用します。\n<p>レジスタはプロセッサによって直接アクセスでき、一時的なデータの保存や計算処理に使われます。\nRAMは大量のデータを保存できますが、同時に読み書きできるのは一つのアドレスに対してのみです。</p>\n<p>このプロセッサには、<b>A</b>と<b>D</b>という2つのレジスタと1つのRAMバンクがあります。</p>\n<p>このミッションでは、2つのレジスタとRAMバンクを組み合わせます。</p>",
      "elaboration": "<p>このプロセッサには、レジスタとRAMという2段階の記憶装置があります。</p>\n<p>RAMは圧倒的に大きな容量を持っていますが、RAMからデータを読み取るためにはアドレスが必要なので、アドレスそのものを記憶する装置がほしくなります。また、処理の途中で使う一時的な値を記憶することも必要になります。これらの需要に応えるべく、このプロセッサにはA（アドレス用）とD（データ用）の2つのレジスタがあります。</p>\n\n\n<p>実際のプロセッサには、十数個やそれ以上の個数のレジスタがあることが多いですが、今回のプロセッサでは必要最小限として2つだけ用意することにします。</p>\n\n<h3>フラグ</h3>\n<p><u>フラグ</u>とは、特定のオプションを選択するための入力ビットを指す用語です。複数のフラグがある場合、それぞれを独立にオンオフできます。\n例えば、このコンポーネントでは、<b>a</b>、<b>d</b>、<b>*a</b>のフラグがあり、これらは任意の組み合わせで設定することができます。すべてオンにすることも、すべてオフにすることも可能です。</p>\n"
    },
    "ALU_INSTRUCTION": {
      "title": "命令（インストラクション）",
      "specification": "<p>入力<b>I</b>は、ALUコンポーネントと条件コンポーネントに対する命令を指定します。Iのそれぞれのビットが以下のような役割を持つようにしてください。</p>\n\n<table class='data'>\n<tr><th>入力</th><th colspan=2>出力</th><th></th></tr>\n<tr><th>ビット</th><th>グループ</th><th>フラグ</th></tr>\n\n<tr><td>10</td><td>ALU</td><td>u</td></tr>\n<tr><td>9</td><td>ALU</td><td>op1</td></tr>\n<tr><td>8</td><td>ALU</td><td>op0</td></tr>\n<tr><td>7</td><td>ALU</td><td>zx</td></tr>\n<tr><td>6</td><td>ALU</td><td>sw</td></tr>\n\n<tr><td>5</td><td>書き込み先</td><td>a</td></tr>\n<tr><td>4</td><td>書き込み先</td><td>d</td></tr>\n<tr><td>3</td><td>書き込み先</td><td>*a</td></tr>\n\n<tr><td>2</td><td>条件</td><td>lt</td></tr>\n<tr><td>1</td><td>条件</td><td>eq</td></tr>\n<tr><td>0</td><td>条件</td><td>gt</td></tr>\n</table>\n\n<p>入力A、入力D、および 入力*Aは、それぞれのレジスタの値です。</p>\n<p>ALUのX入力にはDを、Y入力には命令の第12ビットに応じてAまたは*Aを指定してください。第12ビットが0の場合はA、1の場合は*Aです。</p>\n<p><b>R</b>出力には、ALU操作の結果を出力してください。</p>\n<p><b>j</b>フラグでは、ALUの出力がビット0-2で指定された条件に一致するかどうかを示してください。</p>\n"
    },
    "CONTROL_UNIT": {
      "title": "制御装置",
      "splash": "プログラムとは、命令が列をなしたもののことです。それぞれ命令は、以下の情報を指定するためのビットフラグを集めることで構成されています。\n<ul>\n<li>実行するALU操作</li>\n<li>入力として使用するレジスタ</li>\n<li>結果を格納するレジスタ</li>\n</ul>",
      "specification": "<p>ALU命令に加えて、<b>データ命令</b>もサポートするようにしましょう。データ命令では、命令の値が直接Aレジスタに書き込まれます。</p>\n<p>命令<b>I</b>の最上位ビットに応じて、データ命令またはALU命令を実行する制御装置を作成してください。</p>\n\n<table class=data>\n<tr><th>第15ビット</th><th>命令の種類</th></tr>\n<tr><td>0</td><td>データ命令</td></tr>\n<tr><td>1</td><td>ALU命令</td></tr>\n</table>\n\n<h3>ALU命令</h3>\n<p>ALU命令の場合、出力は前のステージで指示された通りにしてください。RはALU操作の結果となるようにしましょう。</p>\n\n<h3>データ命令</h3>\n<p>データ命令の場合、出力<b>R</b>は入力<b>I</b>そのものであり、結果を格納するのはAレジスタになります。つまり、<b>a</b>は1にし、<b>d</b>、<b>*a</b>、および<b>j</b>フラグはすべて0に設定してください。</p>"
    },
    "CPU3": {
      "specification": "<p>以下の要素を組み合わせてコンピュータを構築してください。</p>\n<ul>\n<li>制御装置</li>\n<li>記憶装置（RAMとレジスタ）</li>\n<li>プログラムメモリユニット（ROM）</li>\n<li>現在の命令アドレスを追跡するカウンター（「プログラムカウンター」または<b>PC</b>と呼ばれます）</li>\n<li>クロックユニット</li>\n</ul>\n\n<p>プログラムメモリ内のPCアドレスにあるワードが、制御装置への<b>I</b>入力となります。</p>\n\n<p>各クロックサイクルで、<b>j</b>の値に応じてプログラムカウンターが変化します。</p>\n<p><b>j</b>=0 の場合、プログラムカウンターを1進めてください。</p>\n<p><b>j</b>=1 の場合、PCを<b>A</b>の値に設定してください。</p>\n",
      "splash": "最終チャレンジに到達しました。これを完成させれば、プログラム可能であり使い物になるマイクロプロセッサを構築したことになります。",
      "title": "コンピュータ"
    },
    "IO": {
      "title": "入出力",
      "splash": "<p>コンピュータが実際に何らかの役に立つためには、外界と情報をやりとりできる必要があります。</p>\n<p>画面、キーボード、タッチセンサー、ネットワークインターフェースなどのハードウェアデバイスを通じて、情報のやりとりが行われます。</p>\n\n<p>このステージでは、今まで作ってきたコンピューターを、モーターやセンサーといった簡単なロボットのハードウェアと合体させます。</p>\n\n",
      "specification": "<p>コンピューターをロボットのハードウェアと合体させ、メモリアドレスのようにしてハードウェアを読み書きできるようにしてください。</p>\n\n<p>入力信号は、<b>st</b>（ストア）が1であり、かつ<b>cl</b>（クロック信号）が1の場合に、ハードウェアに送信されるようにします。</p>\n\n<p>出力信号は、即座に読み取れるようにしてください。</p>\n\n<p><b>X</b>の入力ビットとデバイス制御信号の対応関係は以下の通りです。</p>\n<table class=data>\n<tr><th>ビット</th><th>制御信号</th></tr>\n<tr><td>15</td><td>lo</td></tr>\n<tr><td>14</td><td>lf</td></tr>\n<tr><td>13</td><td>mv</td></tr>\n<tr><td>12</td><td>stp</td></tr>\n<tr><td>11</td><td>tl</td></tr>\n<tr><td>10</td><td>tr</td></tr>\n<tr><td>09</td><td>zp</td></tr>\n</table>\n\n<p>デバイスセンサーと出力ビットの対応関係は以下の通りです。</p>\n<table class=data>\n<tr><th>ビット</th><th>センサー出力</th></tr>\n<tr><td>3</td><td>mv</td></tr>\n<tr><td>2</td><td>tn</td></tr>\n<tr><td>1</td><td>ob</td></tr>\n<tr><td>0</td><td>lf</td></tr>\n</table>\n",
      "elaboration": "<p><b>メモリマップト</b>入出力とは、外部デバイスへの接続が通常のRAMユニットと一緒にメモリアドレス空間に組み込まれていることを意味します。</p>\n\n（訳注：日本語では「メモリマップ<b>ド</b>」と書かれることも多い）\n\n<p>これにより、プロセッサは、メモリに対して読み書きを行うのとまったく同じ方法で、出力デバイスに情報を書き込んだり入力デバイスから情報を読み取ったりすることができます。</p>\n\n<p></p>"
    },
    "IO2": {
      "elaboration": "<p><b>メモリマップト</b>入出力とは、外部デバイスへの接続が通常のRAMユニットと一緒にメモリアドレス空間に組み込まれていることを意味します。</p>\n\n（訳注：日本語では「メモリマップ<b>ド</b>」と書かれることも多い）\n\n<p>これにより、プロセッサは、メモリに対して読み書きを行うのとまったく同じ方法で、出力デバイスに情報を書き込んだり入力デバイスから情報を読み取ったりすることができます。</p>\n\n<p></p>",
      "title": "入出力",
      "splash": "<p>コンピュータが実際に何らかの役に立つためには、外界と情報をやりとりできる必要があります。</p>\n<p>画面、キーボード、タッチセンサー、ネットワークインターフェースなどのハードウェアデバイスを通じて、情報のやりとりが行われます。</p>\n<p>このステージでは、コンピューターをランプとボタンといった簡単なハードウェアデバイスと合体させます。</p>\n",
      "specification": "<p>ランプとボタンを接続し、メモリアドレスのようにしてランプやボタンにアクセスできるようにしてください。</p>\n\n<p><b>デバイスへの出力</b></p>\n<p>ランプは<b>X</b>の第0ビットと第1ビットによって制御されます。</p>\n<p>第1ビットが1のとき、ランプの<b>on</b>入力に信号が入るようにしてください。第0ビットが1のとき、ランプの<b>off</b>入力に信号が入るようにしてください。</p>\n<p><b>st</b>（ストア）が1であり、かつ<b>cl</b>（クロック信号）が1の場合に、信号がハードウェアに送信されるようにしてください。</p>\n\n<p><b>デバイスからの入力</b></p>\n<p>ボタンの状態はコンポーネント出力の第15ビットに表示されるようにしてください。</p>\n<p>ボタンが押されているときは第15ビットが1になり、押されていないときは0になるようにしてください。</p>\n<p>入力信号は即座に読み取れるようにしてください。</p>"
    },
    "PROGRAM1": {
      "title": "機械語",
      "specification": "<p>次の4つの命令からなるプログラムを書いてください。</p>\n<p>0) Dレジスタを0に設定する <br>1) Aレジスタを2に設定する <br>2) Dレジスタに1を加算する <br>3) 無条件でジャンプする</p>\n\n<p>プログラムを実行した結果は、「1回反復するたびに<b>D</b>が1ずつ増加する」というものになるはずです。</p>\n<p>それぞれの命令に対して適切なビットフラグを設定することでプログラムを書いていってください。</p>\n<p><b>Clock Tick</b>ボタンをクリックすると、コンピュータが命令を1つ実行します。</p>\n"
    },
    "OPCODES2": {
      "title": "アセンブリ言語",
      "specification": "<p>記号で書かれた命令をバイナリ(2進数)の機械語に変換するアセンブラを組み上げてください。</p>\n<p>アセンブラ命令は、<u>書き込み先</u>、<u>計算</u>、および（あってもなくてもいい）<u>ジャンプ条件</u>の3つの部分から構成されます。</p>\n<p>「書き込み先」は、操作の出力が書き込まれるレジスタを指定します。</p>\n<p>「計算」はALU操作です。ビットパターンについては、ALUのステージを参照してください。</p>\n<p>「ジャンプ条件」は、ジャンプを引き起こす条件です。どういう構造だったかについては、「条件」のステージを参照してください。</p>\n<p>算術記号<code>+</code>および<code>-</code>はそのままの意味です。ビット演算の記号は以下の通りです。</p>\n<table class=data>\n<tr><th>記号</th><th>意味</th></tr>\n<tr><td><code>X&Y</code></td><td>16ビットのビットAND</td></tr>\n<tr><td><code>X|Y</code></td><td>16ビットのビットOR</td></tr>\n<tr><td><code>~X</code></td><td>16ビットのビット反転</td></tr>\n</table>\n",
      "splash": "<p>直接命令ビットを設定してコンピュータをプログラミングするのは非常に時間がかかり、ミスが発生しやすいものです。</p>\n<p>そして、何より退屈です。</p>\n<p>そこで、命令ビットの代わりに文字や記号を使ってテキスト形式で機械語を表現する、いわゆる<b>アセンブラ</b>言語を作成していきましょう。</p>\n<p>記号で書かれた命令をバイナリ(2進数)の機械語に変換するもののことを、<b>アセンブラ</b>と呼びます。</p>\n<p>このステージでは、我々がこれまで組んできた機械のためのアセンブラを組み上げていきます。</p>\n"
    },
    "ASSEMBLER1": {
      "title": "アセンブリプログラム",
      "splash": "<p>そろそろお気づきかもしれませんが、バイナリ(2進数)の機械語でプログラムを書くのは、非常にめんどくさく退屈な作業です。</p>\n<p>それを簡単にするために、命令をテキスト形式で記述する<b>アセンブリ言語</b>を使用します。アセンブリ言語で書かれたテキストの各行が機械語の命令に対応しています。そうしたら、<b>アセンブラ</b>というプログラムを使って、このテキストを機械語に変換するのです。</p>\n<p>このミッションでは、アセンブリ言語でプログラムを書いていきます。</p>",
      "specification": "<p>アセンブリ言語で、ランプを少なくとも3回点滅させるプログラムを書いてください。</p>\n<p>ランプはアドレス7FFFにメモリマップされており、第1ビットと第0ビットで制御します。</p>\n<table class='data text'>\n<tr><th>ビット</th><th>1に設定すると</th></tr>\n<tr><td>0</td><td>ランプを点灯させる</td></tr>\n<tr><td>1</td><td>ランプを消灯させる</td></tr>\n</table>\n<p>外部デバイスは、ビットが0から1に変わったときにのみ影響を受けます。</p>\n"
    },
    "READ_KEYBOARD": {
      "title": "キーボード入力",
      "specification": "<p>キーボード入力をメモリに書き込むためのプログラムをアセンブリ言語で書いてください。</p>\n<p>キーボード入力はメモリアドレス<code>6000</code>にマッピングされています。</p>\n<p>最初に入力された文字をメモリアドレス<code>1000</code>（16進数）に、2番目に入力された文字を<code>1001</code>（16進数）に、その次に入力された文字を<code>1002</code>（16進数）に、というふうに書き込んでいってください。</p>\n<p>注意: 通常、キーは1クロックサイクルよりも長く押され続けますが、キーが放されるまでの間に一度だけ入力として認識されるようにしてください。</p>"
    },
    "ESCAPE": {
      "specification": "<p>コンピュータは火星の迷宮に閉じ込められています。迷宮から脱出させるプログラムを書いてください。</p>\n<p>コンピュータには車輪と前方障害物センサーが接続されています。車輪とセンサーへの入出力は、アドレス7FFFにメモリマップされています。</p>\n\n<p><b>周辺機器への出力信号:</b></p>\n<table class='data text'>\n<tr><th>ビット</th><th>1に設定すると</th></tr>\n<tr><td>2</td><td>前進（1ステップ）</td></tr>\n<tr><td>3</td><td>左に90度回転</td></tr>\n<tr><td>4</td><td>右に90度回転</td></tr>\n</table>\n\n<p>ビットが0から1に変わると、動作や回転が開始されますが、完了するまでに少し時間がかかります。</p>\n\n<p><b>周辺機器からの入力:</b></p>\n<table class='data text'>\n<tr><th>ビット</th><th>1のときの意味</th></tr>\n<tr><td>8</td><td>前方に障害物を検出</td></tr>\n<tr><td>9</td><td>デバイスが回転中</td></tr>\n<tr><td>10</td><td>デバイスが前進中</td></tr>\n</table>\n",
      "title": "迷宮からの脱出"
    },
    "ASSEMBLER_DISPLAY": {
      "specification": "<p>画面に好きなロゴを表示してください。</p>\n<p>ロゴのデザインは自由ですが、幅と高さがそれぞれ最低16ピクセル以上である必要があります。</p>\n<p>画面は512×256ピクセルのモノクロで、アドレス0x4000から0x6000までの範囲にメモリマップされています。各アドレスは画面上の16ピクセルに対応しています。画面の各行はメモリ内で連続しており、1行目は0x4000から始まり、2行目は0x4020から始まる、といったふうになっています。</p>\n",
      "title": "ディスプレイ"
    },
    "ASSEMBLER_NETWORK_RECEIVE": {
      "title": "ネットワーク",
      "specification": "<p>ネットワークを介して別のコンピュータからデータを受信し、画面に表示してください。</p>\n<p>ペイロードは幅16ピクセルの画像です。</p>\n<p>使用されるネットワークプロトコルの詳細については、ステージのヘルプを参照してください。</p>\n<p>ネットワークのワイヤは、アドレス<code>6001</code>（16進数）にメモリマップされており、重要なビットが2つあります。<b>data</b>（第0ビット）はワイヤを介して送られてきたデータの現在のビットで、<b>sync</b>（第1ビット）は新しいビットが到着したときにそのことを示すために変化するビットです。</p>\n<p>注意: この課題はアセンブリ言語だけで解くのが難しいかもしれません。スタック操作のマクロを実装してからこのチャレンジに戻り、それを使ってコードを簡素化するのも一つの方法です。</p>\n",
      "elaboration": "ネットワークは情報をビットの列として送信します。銅線上では、一定レベル以上の電流があることによって1を表したり、電流がない（または一定の閾値以下である）ことによって0を表したりするかもしれません。（訳注：実際は電流よりも電圧が使われることが多い気がします。）光ファイバーでは、光信号が1を表し、光がないことが0を意味します。\n\n<h4>同期</h4>\n<p>ここで問題となるのは、1つのビットが終了し、新しいビットが開始されるタイミングをどう判断するかです。連続した2つの1は、単一の1が長く続いている場合と区別がつきません。したがって、ネットワークプロトコルには、ビットの終了を判断するためのタイミングメカニズムが必要です。</p>\n<p>よくある解決策は、全参加者が共有する合意されたネットワーククロックを使用することです。これには高い精度が必要で、一方がわずかに同期からずれるだけで、すべてのデータがごちゃごちゃになってしまいます。他の方法として、同期信号をネットワーク自体が運ぶ同期型ネットワークがあります。これにはより多くの帯域幅が必要ですが、ネットワーククロックを使うよりは簡単に実現できます。</p>\n<p>このミッションでは、2本のワイヤを使用した同期接続を使用します。1本のワイヤがデータを運び、もう1本が同期信号を運びます。同期信号が変化するたびに（0から1、または1から0）、新しいビットがデータワイヤから読み取れます。</p>\n<p>これには（データのワイヤだけを用意する方法に比べて）2倍の帯域幅が必要ですが、実装は簡単です。</p>\n\n<h4>メッセージ形式</h4>\n<p>次に、データ送信の開始と終了をどう判断するかという問題があります。仮に「0の信号」と「送信されていない」が同じであった場合、相手が0を送信しているのか、送信が終了したのかを知る方法がありませんね。そのため、このミッションで使用するプロトコルでは、送信は常に「1」のビットから始まり、その後に16ビットのデータが続き、その後に制御ビットが続きます。制御ビットが0の場合は送信が終了したことを意味し、制御ビットが1の場合はさらに16ビットのデータが続き、再び制御ビットが続くという仕組みです。</p>\n\n<h4>帯域幅</h4>\n<p>ネットワークのビットレートは、プロセッサが各ビットを受信して一つずつ処理しても間に合うぐらいの遅さにしておく必要があります。現実には、ネットワークのビットレートはプロセッサより<u>はるかに</u>遅くなっているのが普通です。</p>\n<p>このシミュレーションでは、ネットワークのビットレートはプロセッサのクロックレートの100倍遅いという設定になっています。つまり、ネットワークから1ビットが送られてくる間に、プログラムは100命令を実行できるものとしています。</p>\n"
    },
    "CMOS_NAND": {
      "title": "Nand（CMOS）",
      "splash": "最初のステージでは、電磁リレーを使用して<b>nand</b>ゲートを構築しました。現代のコンピュータはトランジスタで構築されているので、このステージではリレーの代わりにCMOSトランジスタを使ってnandゲートを作成します。",
      "specification": "<p>CMOSトランジスタを使用してNANDゲートを構築してください。</p>\n<p>CMOS回路では、トランジスタをスイッチとして用います。トランジスタには2種類あり、nmos（1が来ると接続するようになる）とpmos（1が来ると切断するようになる）があります。</p>\n<p><b>1</b>は電圧を、<b>0</b>はグランド（接地）を表します。</p>\n\n<p>切断状態のトランジスタの出力は、0でも1でもありません（<b>?</b>として表示されます）。したがって、どんな入力に対しても、回路の出力が何らかの経路で常に0または1の入力のいずれかと接続されているようにする必要があります。</p>\n<p>電圧（1）をグランド（0）に直接接続して回路をショートさせないように注意してください。</p>\n"
    },
    "CMOS_INV": {
      "title": "反転（CMOS）",
      "specification": "<p>CMOSトランジスタを使用してINVゲートを構築してください。</p>",
      "splash": "<p>私たちは、単一のNANDゲートを使用してインバータ（否定回路）を構築できることを既に知っています。</p>\n<p>ただし、これには4つのCMOSトランジスタが必要です。</p>\n<p>では、使うCMOSトランジスタの数をさらに減らしてインバータ（INV）を実装することは可能でしょうか？</p>"
    },
    "NOR": {
      "title": "NOR"
    },
    "XNOR": {
      "title": "XNOR"
    },
    "CMOS_NOR": {
      "specification": "NANDと同様に、NORも万能論理ゲートです。NORゲートだけを使用して、他のどんな論理ゲートでも構築することができます。",
      "title": "Nor（CMOS）"
    },
    "SHL": {
      "title": "左シフト",
      "specification": "<p>すべてのビットを左に1つずつシフトします。出力の最下位ビットは0に設定されます。入力の最上位ビットは破棄されます。</p>\n<p>これは2倍するのと同じです。</p>"
    },
    "SHR": {
      "title": "論理右シフト",
      "specification": "<p>すべてのビットを右に1つずつシフトします。出力の最上位ビットは0に設定されます。入力の最下位ビットは破棄されます。</p>\n<p>これは符号なしの数値に対して2で割るのと同じです。</p>\n"
    },
    "SAR": {
      "title": "算術右シフト",
      "specification": "<p>すべてのビットを右に1つずつシフトしますが、最上位ビットはそのままの値を保持します。入力の最下位ビットは破棄されます。</p>\n<p>これは符号付きの数値に対して2で割るのと同じです。</p>\n"
    },
    "MUL16": {
      "title": "掛け算",
      "specification": "2つの正の数を掛け算してください。オーバーフローしたビットは破棄されるものとします。",
      "elaboration": "これは難しい課題です。解決するためには、きっと複数のカスタムコンポーネントを作成する必要が出てくるでしょう。",
      "spoilers": {
        "0": "掛け算は、複数回の加算として実装できます。",
        "1": "ビットを左にシフトすることは、2倍するのと同じです。"
      }
    },
    "MIN16": {
      "title": "最小値",
      "specification": "2つの16ビット数値のうち、より小さい方を出力してください。"
    },
    "MAX16": {
      "title": "最大値",
      "specification": "2つの16ビット数値のうち、より大きい方を出力してください。"
    },
    "SHL16": {
      "title": "左バレルシフト",
      "specification": "<p>16ビットの入力を0～15ビット分左にシフトしてください。</p>\n<p>シフトするビット数は、4ビットの入力<b>n</b>で指定されます。</p>"
    },
    "FLOAT_MUL_UNPACKED": {
      "splash": "<p>浮動小数点演算では、乗算は加算や減算よりも簡単です。</p>\n<p>そこで、まずは乗算から始めましょう。</p>\n<p>浮動小数点数の乗算は、仮数部を掛け合わせ、指数部を加算することで行います。</p>\n<p>2つの11ビットの仮数部を整数として掛け合わせると、21ビットまたは22ビットの仮数部が得られます。しかし、暗黙の小数点に対処するために、右端の10桁を捨てる必要があります。</p>\n<p>これは、浮動小数点演算において、結果の桁数（どの程度の大きさであるのか）は正しいけれども精度が失われることがある、という一例になっています。</p>\n",
      "title": "浮動小数点乗算",
      "specification": "<p>アンパックされた浮動小数点数を2つ掛け算してください。</p>\n<p>2つの入力について:</p>\n<p><b>sg</b> は符号（0=正、1=負）<br><b>exp</b> はバイアス付きの指数（バイアス値 = 15）<br><b>sf</b> は仮数で、11ビットの2進数</p>\n\n<p>出力は次のようにしてください。</p>\n<p><b>sg</b> は結果の符号です。普通の掛け算の規則に従ってください。<br><b>exp</b> は、指数の和からバイアス値を引いたものにしてください。<br><b>sf</b> は仮数の積で、11ビットまたは12ビットの数値としてください。（積の下位10ビットは切り捨てます）</p>\n\n<p><u>注: 11ビットの値を2つ掛け算した積は22ビットになるため、このレベルでは22ビットの乗算器（<b>mul</b>）および22ビットのスプリッタのコンポーネントが提供されます。</u></p>\n\n<p><u>注: 指数にバイアスをつけることで、ここでは単に複雑さが増しているだけのように見えますが、負の指数値を避けることができるおかげで、普段はロジックを簡素化してくれます。したがって、一般的には、これは設計上のトレードオフとして許容できると考えます。</u></p>\n"
    },
    "FLOAT_PACK": {
      "specification": "<p>符号、指数、および仮数を正規化し、16ビットの浮動小数点形式にパックしてください。</p>\n\n<p>パックされた形式では、<br>第15ビットが符号<br>第14ビット～第10ビットがバイアス付きの指数<br>第9ビット～第0ビットが、正規化された仮数から先頭の1を除いたもの<br>になります。</p>\n\n<h3>0</h3>\n<p>入力として与えられた正規化されていない仮数が0である場合、指数も0に設定してください。</p>\n\n<h3>オーバーフロー/アンダーフロー</h3>\n<p>正規化後の指数が0から31の範囲（つまり、5ビットで表現できる範囲）におさまっていない場合、その数値は無効となります。その場合には、指数部を31に設定してください。</p>",
      "title": "浮動小数点数をパックする"
    },
    "FLOAT_NORMALIZE_OVERFLOW": {
      "title": "オーバーフローを正規化する",
      "splash": "<p>2つの仮数を掛け合わせた結果は、11ビットまたは12ビットの2進数になりえます。12ビットの場合は、最下位ビットを切り捨てて11ビットに正規化し、指数を1増やします。</p>",
      "specification": "<p>入力される仮数（<b>sf</b>）は11ビットまたは12ビットのいずれかです。<p>12ビットの場合は、11ビットにシフトし、最下位ビットを切り捨て、指数を1増加させてください。</p>"
    },
    "FLOAT_NORMALIZE_UNDERFLOW": {
      "title": "アンダーフローを正規化する\n",
      "specification": "<p>入力された仮数（<b>sf</b>）の桁数が11ビット未満の場合、それを11ビットに変更し、指数をそれに応じて調整してください。</p>\n<p>入力がゼロでなく、最大で11ビットであることを前提とします。</p>"
    },
    "FLOAT_VERIFY_EXPONENT": {
      "title": "指数を検証する",
      "specification": "<p>指数（<b>exp</b>）が0～30の範囲（16進数で00～1e）からはみ出ている場合、指数を31（16進数で1f、2進数で11111）に設定してください。</p>"
    },
    "FLOAT_UNPACK": {
      "title": "浮動小数点数のアンパック",
      "specification": "<p>正規化された16ビットの浮動小数点数を符号、指数、仮数の3つの部分に分解してください。</p>\n<p><b>sgn</b>: 符号（0 = 正、1 = 負）<br><b>exp</b>: 指数<br><b>sf</b>: 仮数</p>\n\n<p>パックされた形式では、次のようになります。</p>\n<br>第15ビットが符号（0 = 正、1 = 負）\n<br>第14ビット～第10ビットが指数\n<br>第9ビット～第0ビットが正規化された仮数\n\n<p>「正規化された仮数」というのは、「指数が0でない限り、第9ビット～第0ビットの10ビット仮数の前には、暗黙の1が付くと仮定される」という意味です。アンパックされた形式では、この1を挿入して11ビットの仮数としてください。</p>",
      "splash": "<p>この後に続く追加ステージでは、浮動小数点演算を構築していきます。なお、これは高度な内容ですよ。</p>\n\n<p>浮動小数点数は、分数を表したり、整数より広い範囲の数値を表したりすることができます。これは、元となる数を拡大・縮小するための<b>指数部</b>を含めることにより実現されます。指数部は、ビットを左または右に移動することに対応します。（訳注：ビットが左右に動いていると考えてもよいですし、小数点が左右に動いていると考えてもよいです。）</p>\n<p>ここでは、10ビット分を仮数に、5ビット分を指数に、1ビット分を符号に割り当てて使う16ビットの浮動小数点形式を使用します。</p>\n<p>最初のミッションは、この16ビット形式を3つの要素にアンパックし、その後の操作を行えるようにすることです。</p>\n",
      "elaboration": "<h3>2進小数</h3> \n<p>以下の文章では、2進数の小数が使用されています。これは一般的にはあまり使われていない形式ですが、浮動小数点数がどのように機能するかを説明するためには便利です。</p> \n<p>小数点以下の桁の値は、1/2、1/4、1/8と続きます。<br><code>0.1</code><small>（2進数）</small>は10進数では1/2、つまり0.5に相当し、<br><code>0.01</code><small>（2進数）</small>は10進数では1/4、つまり0.25に相当し、<br>というふうに続きます。</p> \n\n<h3>指数</h3>\n<p>浮動小数点形式では、数を<b>仮数部</b>（桁が並んだもの）と<b>指数部</b>（小数点から見た桁の位置を示す）を組み合わせて表現します。</p>\n<p>例えば、<code>1</code>という桁に対して指数が0であるとき、それは単なる<code>1</code>です。<br><code>1</code>という桁に対して指数が1である場合、その数字は2進数で<code>10</code>（10進数で2）になります。<br>指数が-1である場合、その数字は2進数で<code>0.1</code>（10進数で0.5）になります。</p>\n<p>したがって、指数が1増えるごとに数字が2倍になり、1減るごとに数字が半分になります。つまり、指数が1増えると末尾に0が追加され（2倍に相当）、指数が1減ると小数点が左に移動します（半分に相当）。</p>\n<p>「浮動小数点」という用語は、小数点が仮数部の桁に対して相対的に移動できることを意味しています。</p>\n\n<h3>正規化</h3>\n<p>同じ数値が複数の方法で表現できることがあります。例えば、<code>10</code><small>（2進数）</small>に指数1がついたものは、<code>1</code><small>（2進数）</small>に指数2がついたものと、そして<code>0.1</code><small>（2進数）</small>に指数3がついたものと同じ数値を表します。</p>\n<p>これでは比較や計算をする上で不便なので、数値を<u>正規化</u>し、標準形式に統一します。正規化された形式では、先頭の1の後に小数点を置き、その後に残り全ての有効桁が続くようにします。</p>\n<p>さらに、この先頭の1は常に同じですから、明示的に保存する必要がなくなり、これにより1ビット分のストレージを節約できます。</p>\n\n<h3>指数のバイアス</h3>\n<p>負の指数を扱うのは不便なので、指数に15を加えて保存します。これを「指数に<u>バイアス</u>をつける」「<u>バイアス</u>を足す」と言います。</p>\n\n<h3>16ビット浮動小数点形式</h3>\n<p>簡単にするため、16ビットの浮動小数点形式を使用します。現代のプロセッサでは、より大きな形式、32ビット、64ビット、またはそれ以上が一般的で、これにより、圧倒的に広い範囲と良い精度を提供します。ただし、16ビットも32ビットも64ビットも基本的な概念は同じです。</p>\n\n<h3>精度とその限界</h3>\n<p>一部の数値は正確に表現できません。例えば、<br><code>1.1111111110</code><small>（2進数）</small>に指数12をつけたものは8188であり、<br><code>1.1111111111</code><small>（2進数）</small>に指数12をつけたものは8184です。</p>\n<p>その間の数値は、この浮動小数点形式では表現できません。したがって、8184に1を加えても、丸め（10進法でいう四捨五入）により8184のままになってしまいます。</p>\n<p>仮数部のビット数を増やせば精度は向上しますが、整数や小数が無限に存在するのに対して有限のビット数しかないため、精度が一部失われてしまうことは避けられないものなのです。</p>\n<p>意外に思われるかもしれませんが、一般的な10進数の分数の中には、浮動小数点で正確に表現できないものがあります。例えば、10進数で0.1（1/10）は浮動小数点で正確に表現できません。これは、0.1が無限に続く2進数展開を持つためです。（ちょうど1/3が10進数表記では正確に表現できないのと同じです。）</p>\n<p>このため、浮動小数点形式は通常、金銭データの計算には使用されません。10セント（訳注：つまり、0.1ドル）単位の金額というのは日常的に用いられるものですから、（訳注：アメリカ合衆国で、ドル単位で金銭を扱う上では）0.1を正確に表せないという精度限界は容認できないのです。とはいえ、2進数の浮動小数点は、ハードウェアで分数や実数を扱う上では圧倒的に最も一般的な方法となっています。</p>\n"
    },
    "FLOAT_MUL": {
      "title": "浮動小数点の掛け算",
      "specification": "パックされた16ビット浮動小数点数2つを掛け算してください。"
    },
    "FLOAT_ALIGN": {
      "title": "仮数を揃える",
      "specification": "<p>2つの数値の指数と仮数を調整して、同じ指数を持つようにしてください。</p>\n<p>共通の指数は、入力された指数のうち大きいほうにしてください。指数が小さい方の数値の指数を調整し、もう一つのほうの指数に合わせてもらいますが、その際、仮数の桁をいくつか切り捨てる必要があるかもしれません。</p>\n\n<p>出力:</p>\n<p><b>ex</b> 大きい方の指数</p>\n<p><b>asf</b> A入力の仮数で、共通の指数に調整されたもの</p>\n<p><b>bsf</b> B入力の仮数で、共通の指数に調整されたもの</p>"
    },
    "ADD_SIGNED_MAGNITUDE": {
      "title": "「符号と絶対値」表現の加減算",
      "specification": "<p>「符号と絶対値」表現で表された符号付き整数を加算または減算してください。</p>\n<p><b>sg</b> は符号を表します<br>（0 = 正、1 = 負）。<br><b>M</b> は符号を取り外したときの数値です。</p>\n<p>例えば、-2 は sg=1, M=2 で表されます。</p>\n<p><b>op</b> フラグにより、行うべき操作が指定されます。</p>\n<table class=truth>\n<tr><th>op</th><th>操作</th></tr>\n<tr><td>0</td><td>A + B</td></tr>\n<tr><td>1</td><td>A - B</td></tr>\n</table>"
    },
    "FLOAT_ADD": {
      "title": "浮動小数点数の加算",
      "specification": "<p>浮動小数点数を加算または減算してください。</p>\n<p><b>op</b> フラグにより、行うべき操作が指定されます。</p>\n<table class=truth>\n<tr><th>op</th><th>操作</th></tr>\n<tr><td>0</td><td>A + B</td></tr>\n<tr><td>1</td><td>A - B</td></tr>\n</table>"
    }
  },
  "ui": {
    "donate": "寄付する",
    "about": "このサイトについて",
    "custom_components": "カスタムコンポーネント",
    "btn_reset_state": "状態をリセット",
    "btn_clear_levels": "全てのステージの進捗を削除",
    "btn_skip_level": "このステージを飛ばす",
    "btn_next_level": "次のステージ",
    "btn_ok": "OK",
    "btn_close": "閉じる",
    "stay": "このステージに留まる",
    "click_to_reveal": "(クリックして表示)",
    "about_translation": "翻訳文に修正すべき箇所を見つけた方は、お手数ですが <a href=\"https://github.com/hsjoihs/nandgame-translate-ja/issues/new\">https://github.com/hsjoihs/nandgame-translate-ja</a> までご報告ください。",
    "btn_level_complete": "正誤判定をする",
    "level_help": "ステージのヘルプ",
    "solve_level": "ステージを解く",
    "level_complete": "ステージクリア！",
    "confirm_clear_levels": "全進捗が消えることになります。全てのステージの解答を削除して本当に最初からやり直しますか？",
    "btn_clear_canvas": "盤面をリセット",
    "level_error_header": "正しくありません。",
    "level_error": "現状の解答は仕様を満たしていません。",
    "custom_components_start": "カスタムコンポーネントは、自由に設計できます。特定のステージを解くための部品として使用することもできますし、単に楽しんで試行錯誤するために使っても構いません。"
  },
  "texts": {
    "translation_credits": ""
  }
}