{
  "missions": {
    "RELAY_NAND": {
      "title": "Nand",
      "splash": "<p><b>Nand Game</b>へようこそ！</p>\n<p>このゲームでは、基本的な部品（コンポーネント）からスタートして、コンピュータを組み上げていきます。\n  <div><p>このゲームは、順番にステージをこなす構成となっています。\n 各ステージでは、仕様に従って動作するコンポーネントを作成することが求められます。\n 作成したコンポーネントは、以降のステージで、新たに物を組み立てるための部品として使用できます。\n\n<p>このゲームでは、コンピュータアーキテクチャやソフトウェアについての事前知識は<b>一切</b>必要ありませんし、足し算や引き算以外の数学的なスキルも必要ありません。\n （ただし、解くのに結構時間がかかりそうなタスクもそこそこあるので、忍耐力は必要ですよ～）\n\n </div> <p>最初のタスクは、<b>nand</b>という部品を作成することです。\n <p>図の左側に、このタスクで作り上げるべき部品の厳密な仕様が載っています。\n 「ステージのヒント」をクリックすると、追加のお役立ち情報を見ることができます。",
      "specification": "<p>今回のタスクは、入力 <b>a</b> と <b>b</b> が両方とも 1 のときに出力が 0 になるように、入力を出力へとワイヤーやリレーで接続することです。</p>\n\n<p><b>1</b> は電流が流れていることを表し、<b>0</b> は電流が流れていないことを表します。</p>\n<p><b>V</b> 入力は常に電流が流れている状態です。つまり、常に 1 を保っています。</p>\n<p>厳密な仕様は以下の通りです。",
      "elaboration": "<p><b>nand</b>コンポーネント（nand ゲートともいう）は、論理回路を構成する上で根幹をなす部品です。nand ゲートだけを使って、あらゆる計算をこなす論理回路を構築することができます。だからこそ、まず nand ゲートを作成することから始めるのです。</p>\n\n<p><b>リレー</b>は、電気で制御されるスイッチで、制御信号によってスイッチのオンとオフが切り替わります。制御電流が電磁石に流れたり流れなかったりすることで、その電磁石の力で接点がオンやオフの位置へと動きます。</p>\n\n<p>初期の電子計算機は電磁リレーで作られていましたが、今日のコンピュータはトランジスタで作られています。トランジスタは、リレーと同様、スイッチとして振る舞う装置です。ただし、トランジスタにはリレーと違い物理的・機械的に動くパーツが一切ないため、リレーよりも（はるかに）小型で、安価で、しかも高速に動作することができます。\n\nリレーの方が仕組みを説明しやすいので、Nandgameではリレーを使用していますが、機能としてはリレーとトランジスタは同様のものです。一度 nand コンポーネントを作成してしまえば、それがリレーで作られているかトランジスタで作られているかは気にしなくて良くなるのです。\n",
      "spoilers": [
        "リレーを使って 2 段階の処理を行います。最初のリレーでは、入力 a と b が両方とも 1 のときに 1 を出力します。次に、2 つ目のリレーで最初のリレーの出力を反転させ、1 を 0 に、0 を 1 に変えます。"
      ],
      "hints": {
        "drag": "<b>ステップ1:</b> ツールボックスからコンポーネントをドラッグして、青いエリアに配置します。\n",
        "tap": "<b>ステップ2:</b> 配線を繋げるには、三角形をタップまたはドラッグしましょう。",
        "tap-end": "コンポーネントの（丸い）端子をタップすると、配線が繋がります。",
        "truth": "作成すべきコンポーネントの仕様: <p>どの入力に対しても、正しい出力をすること。",
        "toggle": "チェックボックスをクリックして入力信号を切り替え、回路にどのように影響するかを確認しましょう。",
        "verify": "コンポーネントが正しく設計できたと思ったら、ここをクリックしてください。"
      },
      "debriefing": "<b>nand</b>コンポーネントがツールボックスに追加され、次のステージで組み立ての部品として使用できるようになりました。"
    },
    "INV": {
      "title": "反転",
      "splash": "<p>次のタスクは、<b>nand</b>コンポーネントを使って<b>インバータ</b>（否定回路）コンポーネントを作成することです。</p>\n<p></p> \n<p>このステージからは、根底にあるスイッチの仕組みを考慮する必要はありません。物理的な nand ゲートでは電源への接続が必要ですが、図にこれを示す必要はありません。すべてのコンポーネントは暗黙のうちに電源に接続されているものとします。これからは、論理的な入力と出力に集中しましょう。</p>\n",
      "specification": "<p>次のタスクは、否定回路（インバータ、<b>inv</b>) コンポーネントを作成することです。</p>\n\n<p><b>inv</b>コンポーネントは、単一の入力と単一の出力を持ちます。\n<p>出力は入力の反対になるようにしてください。つまり、1 の場合は 0 を、0 の場合は 1 を出力しましょう。\n",
      "hints": {
        "0": "<b>nand</b>コンポーネントがツールボックスに追加されました。"
      }
    },
    "AND": {
      "title": "AND",
      "splash": "<p>次のタスクは、<b>nand</b>コンポーネントと<b>inv</b>コンポーネントだけを使って<b>AND</b>ゲートを作成することです。\n （このタスクは、どちらか一方のコンポーネントだけで解けるかもしれません。）",
      "specification": "<p><b>AND</b>ゲートの出力は、両方の入力が 1 のときに 1 になります。",
      "spoilers": [
        "実は、\"NAND\" は \"NOT AND\" の略です。\n\n（訳注：原文は「\"NAND\" は \"Negative AND\" の略である」と主張していますが、Oxford English Dictionary によると not + and が語源とのことです。）"
      ]
    },
    "OR": {
      "title": "OR",
      "specification": "<p><b>OR</b>ゲートの出力は、少なくとも1つの入力が1のときに1になります。</p>"
    },
    "XOR": {
      "title": "XOR",
      "specification": "<p><b>XOR</b>ゲートの出力は、2つの入力が異なるときに1になります。</p>",
      "elaboration": "XOR は <u>Exclusive OR</u> の略です。Exclusive とは「排他的」という意味です。<u>a または b のどちらか一方が 1 であり（これが「OR」）、両方が 1 というわけでない（これが「排他的」）</u>ことを意味します。"
    },
    "HALFADD": {
      "title": "半加算器",
      "splash": "<p>おめでとうございます。基本となる論理ゲートを作成できました。</p>\n<p>次のステップは、算術演算です。プロセッサは、数値を加算および減算できる必要があります。</p>\n\n<p>最初のタスクは、1ビットの数値を2つ足し合わせることです。結果は2ビットの数値になります。</p>\n<p>これを解くには、2進法の仕組みを理解している必要があります。</p>",
      "specification": "<p>2つのビットを足し合わせて2ビットの値を出力する<b>加算（add）</b>コンポーネントです。</p>\n<p><b>h</b>出力は上位 (high) ビット、<b>l</b>は下位 (low) ビットです。</p>",
      "elaboration": "<div class=subject>\n\n <h3>2進法</h3>\n\n <p>コンピュータは<b>2進法</b>を使用して算術演算を行います。</p>\n\n <p>我々が普段慣れ親しんでいる、0 から 9 の数字を使って数を書く通常の書き方と異なり、2進法では、すべての数値が 0 と 1 という数字だけを使って表されます。</p>\n\n <p>例:</p>\n\n <table class=data>\n <tr><th>2進法</th><th>10進法</th></tr>\n <tr><td>00</td><td>0</td></tr>\n <tr><td>01</td><td>1</td></tr>\n <tr><td>10</td><td>2</td></tr>\n <tr><td>11</td><td>3</td></tr>\n </table>\n\n2進法を理解するには、まず10進法の仕組みを考えてみましょう。10種類の異なる数字がありますが、桁の位置を調整することで任意の大きな数字を表現できます。3桁の数では、一番右の桁が1の位、右から2番目が10の位、右から3番目が100の位、というように続きます。\nということで、たとえば 273 は 2 × 100 + 7 × 10 + 3 × 1 です。各桁は 10 の累乗に対応しているので、これは「<u>10進法</u>」で数を表現している、と言います。\n\n<p>2進法では、0 と 1 の2つの数字だけが使用されます。2進法では各桁が 2 の累乗に対応しており、1の位、2の位、4の位、8の位、と続きます。\nということで、たとえば 2進法で 101 と書いたら 10進法でいう 5 に相当します（1 × 4 + 0 × 2 + 1 × 1）。離散的システムにおける2種類の状態を数字の 0 と 1 に対応するようにさせることができるので、2進法はデジタル回路に最適なのです。</p>\n\n<p><a href=\"https://www.mathsisfun.com/binary-number-system.html\">詳しくはこちら（英語）</a></p>\n<p><a href=\"https://www.cc.kyoto-su.ac.jp/~kbys/kiso/number/number1.html\">詳しくはこちら（日本語）</a></p>\n\n</div>\n",
      "spoilers": [
        "2つの出力に対応する列をそれぞれ個別に見て、何かパターンが見えてくるか確認してみましょう。"
      ]
    },
    "FULLADD": {
      "title": "全加算器",
      "splash": "<p>これで、2つのビットを足し合わせる加算器を作成できました。</p>\n<p>しかし、より大きな数値を加算するには、下の桁の加算からの「繰り上がり」を考慮する必要があります。</p>\n<p>このミッションでは、3つのビット a、b、c を加算する加算器コンポーネントを作成します。ここで、c は繰り上がり (carry) ビットです。</p>\n",
      "specification": "<p>3つのビット、<b>a</b>、<b>b</b>、<b>c</b> を加算する<b>加算器（add）</b>コンポーネントです。</p>\n<p>出力は2ビットの値になります。<b>h</b>出力は上位 (high) ビット、<b>l</b>は下位 (low) ビットです。</p>\n",
      "elaboration": "目的は、どれだけ大きい数値でも加算できるようにすることです。まず a と b という 2 つのビットで足し算を行い、もし繰り上がりビットがあればそれも考慮してもう一度足し算を行います。\n"
    },
    "ADD2": {
      "title": "多ビット加算器",
      "splash": "<p>次に、2ビットの数 2 つ（と、1ビットの繰り上がり）を加算する加算器を作成しましょう。</p>\n<p>2ビット加算器は、繰り返し使用することで、より大きな数に対応する加算器を作ることができます。</p>",
      "specification": "<p>2ビットの数 2 つと、1 ビットの繰り上がりを加算する加算器を作成しましょう。</p>\n<h3>入力</h3>\n<p><b>a1 a0</b> は2ビットの数値です。</p>\n<p><b>b1 b0</b> は2ビットの数値です。</p>\n<p><b>c</b>（繰り上がり入力）は1ビットの数値です。</p>\n\n<h3>出力</h3>\n<p>入力された数値を加算し、3ビットの数値 <b>c s1 s0</b> を出力します。ここで、<b>c</b> は上位ビットです。</p>\n\n<h3>例</h3>\n\n<table class='data'>\n<colgroup class=input><col><col></colgroup>\n<colgroup class=input><col><col></colgroup>\n<colgroup class=input><col></colgroup>\n<colgroup class=output><col><col><col></colgroup>\n<colgroup class=output><col></colgroup>\n<tr><th colspan=5>入力</th><th colspan=3>出力</th></tr>\n<tr><th>a1</th><th>a0</th><th>b1</th><th>b0</th><th>c</th><th>c</th><th>s1</th><th>s0</th></tr>\n<tr><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td><td>2+2+1=5</td></tr>\n</table>\n",
      "debriefing": "<p>2桁の2進数を加算するコンポーネントの設計を繰り返し適用することで、任意の大きさの数を加算することができます。</p>\n\n<p>我々は 16 ビットプロセッサを構築しようとしているので、今回のコンポーネントを繰り返し使用して 16 ビット加算器コンポーネントを作成し、<b>add 16</b>という名前でツールボックスに追加しておきますね。</p>\n"
    },
    "INC": {
      "title": "インクリメント\n",
      "splash": "<p>これで、16ビットの数値を扱う準備が整いました。</p>\n\n<p>今回のミッションは、16ビットの数値に 1 を加算する<b>インクリメント</b>コンポーネントを作成することです。</p>\n\n<p>16ビットの数値を扱うことになるため、図上での表現を簡略化しました。16本のバラバラの配線と16個の端子を描くのではなく、それらをまとめて1つの端子として表示し、小さな「<b>16</b>」ラベルで示しています。</p>\n",
      "specification": "<p>16ビットの数値に<b>1</b>を加算しましょう。</p>\n<p>結果が16ビットを超える場合は、繰り上がりを無視してください。</p>\n",
      "hints": {
        "0": "16ビットの出力を1つのかたまりとして扱い、出力は16進数と符号付き10進数で表示されます。\n",
        "1": "16ビットの入力を1つのかたまりとして扱い、値は16進数または10進数で入力できます。"
      },
      "elaboration": "<p><b>インクリメント</b>とは、数値を1増やすことを意味します。<a href=\"https://ja.wikipedia.org/wiki/%E6%95%B0%E5%8F%96%E5%99%A8\">ボタンを押すたびに数が 1 増えるカウンター</a>をイメージすると分かりやすいでしょう。</p>\n\n<h3>16ビット</h3>\n\n<p>プロセッサは常に複数のビットを同時に処理します。いま構築していっているプロセッサは<b>16ビットプロセッサ</b>であり、16ビットのまとまりを一度に処理します。</p>\n\n<p>現代のプロセッサ（コンピュータやスマートフォンに搭載されているもの）は通常32ビットまたは64ビットです。電子レンジのような組み込みプロセッサは、8ビットや4ビットだったりするかもしれません。16ビットは実用的なことをするのに十分なサイズであるため、ここでは16ビットを選択しています。</p>\n\n<h3>ワードとバイト</h3>\n<p>16ビットのまとまりは<b>ワード</b>と呼ばれます。ワードのサイズはプロセッサによって異なります。<b>バイト</b>は常に8ビットで、どの機械を使っているのかに依存しない単位です。</p>\n\n<div>\n<h3>バス</h3>\n<p>接続のまとまりを1つの単位として扱うものは<b>バス</b>と呼ばれます。入力と出力はそれぞれ16ビットのバスです。16ビット加算器の<b>A</b>入力と<b>B</b>入力もそれぞれ16ビットのバスです。</p>\n</div>\n\n<div>\n<h3>16進数</h3>\n<p>大きな2進数は、人間にとって読み書きが不便です。そのため、より短くて扱いやすい<b>16進数</b>が使われます。16進数では、A, B, C, D, E, F の文字が10から15を表します。</p>\n<p>16進数（hexadecimal、略して<u>hex</u>と呼ばれる）は、2進データを表現するのに便利です。なぜなら、16進数の1桁は常に4ビットに対応するからです。16ビットのワードは16進数では4桁になります。一方、10進数は2進数の桁と直接対応しないため、2進データを扱うのにはあまり便利ではありません。</p>\n\n<p>例:</p>\n<table class='data numbers'>\n<tr><th>hex</th><th>符号なし10進数</th><th>2進数</th></tr>\n<tr><td>1</td><td>1</td><td>0000000000000001</td></tr>\n<tr><td>F</td><td>15</td><td>0000000000001111</td></tr>\n<tr><td>10</td><td>16</td><td>0000000000010000</td></tr>\n<tr><td>2A</td><td>42</td><td>0000000000101010</td></tr>\n<tr><td>0100</td><td>256</td><td>0000000100000000</td></tr>\n<tr><td>FFFF</td><td>65535</td><td>1111111111111111</td></tr>\n</table>\n\n<p>便利機能として、16ビットの入力端子と出力端子では、数値が2進数と並んで16進数でも表示されるようにしておきました。16進数の値を入力すると、自動的に2進数に変換されます。</p>\n\n<p><a href=\"https://www.mathsisfun.com/hexadecimals.html\">16進数のチュートリアル（英語）</a>（おすすめのチュートリアルがある場合は原作者にお伝えください。）</p>\n<p><a href=\"https://zenn.dev/masahiro_toba/books/b42ef6fe522b38/viewer/72dbdd\">16進数のチュートリアル（日本語）</a>（おすすめのチュートリアルがある場合は、このチュートリアルを翻訳した <a href=\"https://github.com/hsjoihs\">hsjoihs</a> までお知らせください。）</p>\n\n\n</div>\n",
      "spoilers": [
        "入力端子は何にも接続されていなくても構いません。接続されていない入力は常に0です。",
        "入力に何も接続されていない<b>inv</b>ゲートは、常に1を出力します。",
        "<b>add</b>コンポーネントの繰り上がり入力<b>c</b>は、1ビットの入力であり、0または1の2進数を受け付けます。"
      ]
    },
    "SUB": {
      "title": "減算",
      "splash": "<p>次に、16ビットの数から16ビットの数を<b>減算</b>するコンポーネントを作成しましょう。",
      "specification": "<p>A から B を引いた結果を16ビットの数値として出力します。</p>\n<p>結果が0未満（つまり、マイナスの数）の場合、65536を足した値で表現されます。</p>\n<p>例:</p>\n\n<table class='data numbers'>\n<tr><th>結果</th><th>16ビット2進数</th><th>符号なし10進数</th></tr>\n<tr><td>1</td><td>0000000000000001</td><td>1</td></tr>\n<tr><td>0</td><td>0000000000000000</td><td>0</td></tr>\n<tr><td>-1</td><td>1111111111111111</td><td>65535</td></tr>\n<tr><td>-2</td><td>1111111111111110</td><td>65534</td></tr>\n<tr><td>-3</td><td>1111111111111101</td><td>65533</td></tr>\n</table>\n\n<p>（これは2の補数表現に相当します）</p>",
      "elaboration": "<div class=subject>\n\n <h3>2の補数</h3>\n <p>2の補数は、符号付き（正および負）の数を2進数で表現する標準的な方法です。</p>\n <p>右から15番目のビット（一番左のビット）は符号を示します。\n右から15番目のビットが0ならその数は正の数、1なら負の数です。負の数は、65536からその数を引いた値として表されます。\n 例えば、-127 なら 65536 - 127 = 65409 と計算することで符号なしの数値 65409に対応することが分かります。</p>\n\n <p>いくつかの例を示します。</p>\n <table class='data numbers'>\n <tr><th>符号付き10進数</th><th>符号なし10進数</th><th>16ビット2進数</th><th>16進数</th></tr>\n <tr><td>32767</td><td>32767</td><td>0111111111111111</td><td>7FFF</td></tr>\n <tr><td>1</td><td>1</td><td>0000000000000001</td><td>0001</td></tr>\n <tr><td>0</td><td>0</td><td>0000000000000000</td><td>0000</td></tr>\n <tr><td>-1</td><td>65535</td><td>1111111111111111</td><td>FFFF</td></tr>\n <tr><td>-2</td><td>65534</td><td>1111111111111110</td><td>FFFE</td></tr>\n <tr><td>-3</td><td>65533</td><td>1111111111111101</td><td>FFFD</td></tr>\n <tr><td>-32768</td><td>32768</td><td>1000000000000000</td><td>8000</td></tr>\n </table>\n\n <p>\n </div>\n",
      "spoilers": [
        "ビットごとの反転（<b>inv16</b>）が数値にどのような影響を与えるか調べてみましょう。\n\n\n\n",
        "数値をビット反転したものは、65535からその数を引いた値と同じです。負の数は、65536からその数を引いた値として表されます。",
        "A - B = A + INV(B) + 1"
      ],
      "debriefing": "おめでとうございます。基本となる算術演算を行うためのコンポーネントを作成できました。\n<p>現代のプロセッサは、乗算や除算、浮動小数点数など、はるかに複雑な算術演算をサポートしていますが、このゲームでは、動作するプロセッサを作成するために必要最低限のものだけを作成します。</p>"
    },
    "ISZERO": {
      "title": "ゼロであるかどうかの判定",
      "splash": "<p>次に、数値がゼロであるかどうかを示すコンポーネントを作成しましょう。まず、4ビットの数値に対してこれを実装します。</p>",
      "specification": "<p>入力されたすべてのビットが0の場合に限り、1を出力するようにします。</p>",
      "debriefing": "このアプローチは簡単に16ビットに拡張できるので、16ビットの数値がゼロであるかどうかを確認するコンポーネントを作成しておきます。"
    },
    "SIGN": {
      "title": "ゼロより小さいかどうかの判定",
      "splash": "<p>次に、16ビットの数値が負であるかどうかを示すコンポーネントを設計しましょう。</p>",
      "specification": "<p>16ビットの数値の入力が負の場合は1を出力します。</p>\n\n<p>仕様:</p>\n<table class='data'>\n<colgroup class=input><col></colgroup>\n<colgroup class=output><col></colgroup>\n<tr><th>入力</th><th>出力</th></tr>\n<tr><td>入力 ≧ 0</td><td>0</td></tr>\n<tr><td>入力 < 0</td><td>1</td></tr>\n</table>\n\n第15ビットが1であれば、その数値はゼロ未満とみなされます。\n\n<h3>ビットの番号付け</h3>\nビットは右から左に向かって番号が付けられ、右端のビットを0として数えます。したがって、16ビットのワードでは第15ビットが左端のビットです。\n",
      "elaboration": "このコンポーネントにおいては、16ビットの値を符号付き整数として解釈し、左端のビットを符号とみなします。\n\n<p>ツールボックスに<b>スプリッタ</b>を追加しました。スプリッタは16ビットのバスを16個の個別の端子に分割します。\nスプリッタを使用すると、16ビットの入力の個々のビットを確認できます。スプリッタには内部ロジックは一切ありません。\n\n<div class=subject>\n<h3>符号付きと符号なしの数値</h3>\n\n<p>16ビットの値は、符号付き整数としても符号なし整数としても解釈できます。0付近のいくつかの数値の例を示します：</p>\n\n<table class='data numbers'>\n<tr><th>16ビット2進数</th><th>16進数</th><th>符号なし10進数</th><th>符号付き10進数</th></tr>\n<tr><td>0000000000000001</td><td>0001</td><td>1</td><td>1</td></tr>\n<tr><td>0000000000000000</td><td>0000</td><td>0</td><td>0</td></tr>\n<tr><td>1111111111111111</td><td>FFFF</td><td>65535</td><td>-1</td></tr>\n<tr><td>1111111111111110</td><td>FFFE</td><td>65534</td><td>-2</td></tr>\n<tr><td>1111111111111101</td><td>FFFD</td><td>65533</td><td>-3</td></tr>\n</table>\n\n<p>便利なことに、数値を符号付きとして解釈しても符号なしとして解釈しても、加算と減算はまったく同じように動作します。\nこれはつまり、プロセッサは実際には符号付きかどうかを知らなくてよいということです。</p>\n\n<a href=\"https://gihyo.jp/assets/files/book/2017/978-4-7741-8523-1/download/P027.pdf\">2 の補数のチュートリアル（日本語）</a>\n</div>\n",
      "spoilers": [
        "このコンポーネントにおいては、論理コンポーネントは必要なく、スプリッタだけで十分です。"
      ]
    },
    "MULTIPLEXER": {
      "title": "セレクタ",
      "specification": "<p><b>セレクト</b>コンポーネントは、2つの入力ビットのうち1つを選んで出力します。</p>\n\n<p>どちらの入力が選ばれるかを示すのが、<b>s</b>（セレクト）ビットです。\n0の場合は<b>d0</b>が選ばれ、1の場合は<b>d1</b>が選ばれます。</p>",
      "elaboration": "<p>このコンポーネントは、<b>マルチプレクサ</b>（multiplexer）としても知られています。</p>"
    },
    "DEMUX": {
      "title": "スイッチ",
      "splash": "次に、データビットを2つの出力チャネルのどちらかに通す<b>スイッチ</b>を作成しましょう。",
      "specification": "<p><b>スイッチ</b>コンポーネントは、データビットを2つの出力チャネルのどちらかに通します。</p>\n\n<p><b>s</b>（セレクタ）にどちらのビットが入ってくるかによって、<b>d</b>（データ）ビットが<b>c1</b>か<b>c0</b>のどちらを通るかが決まります。</p>"
    },
    "SR_LATCH": {
      "title": "SRラッチ",
      "splash": "<p>これまでに作成した回路にはメモリがありませんが、面白いことができるコンピュータを作るためにはメモリが必要です。</p>\n\n<p>今回のミッションは、1ビットを保持できる<b>ラッチ</b>というコンポーネントを作成することです。<p>これは最も簡単な形式のメモリですが、これを基にしてより大きなコンピュータメモリを作成していくことができます。</p>",
      "specification": "<p><b>SRラッチ</b>（セット/リセットラッチ）コンポーネントは、1ビットの出力を保持することができます。</p>\n<p><b>s</b>=1（セット）で出力を1に設定します。</p>\n<p><b>r</b>=1（リセット）で出力を0に設定します。</p>\n<p><b>s</b>と<b>r</b>が両方とも1の場合、出力は変更されず、事前にセット・リセットされた値がそのまま出力されます。</p>\n<p>最初のセットまたはリセット信号が来るまで、出力は未定義です（つまり、任意の出力が許容されます）。</p>\n<p>また、両方の入力が0のときの出力も未定義です。</p>\n\n<table class='data'>\n<colgroup class=input><col><col></colgroup>\n<colgroup class=input><col></colgroup>\n<colgroup class=output><col></colgroup>\n<tr><th colspan=2>入力</th><th>出力</th></tr>\n<tr><th>s</th><th>r</th><th></th></tr>\n<tr><td>1</td><td>0</td><td>1</td></tr>\n<tr><td>0</td><td>1</td><td>0</td></tr>\n<tr><td>1</td><td>1</td><td>以前の出力</td></tr>\n<tr><td>0</td><td>0</td><td><u>使用されません</u></td></tr>\n</table>\n",
      "spoilers": [
        "回路が入力を保持するためには、配線接続を循環させる必要があります。"
      ]
    },
    "LATCH": {
      "title": "Dラッチ",
      "splash": "<p>SRラッチは、1を保持するためのピンと0を保持するためのピンが別々であることや、(0, 0)の入力状態が「禁止されている」ことといった面倒があるため、メモリを構築するための部品としてはあまり実用的ではありません。<b>データラッチ</b>では、SRラッチを拡張し、「データ用の入力が 1 つ、そのデータを保持するかどうかを示す入力が 1 つ」というふうに、入力がもっと実用的になるようになっています。</p>\n",
      "specification": "<p><b>Dラッチ</b>（データラッチ）コンポーネントは、1ビットを保持します。</p>\n<p><b>st</b>（ストア）が1のとき、<b>d</b>の値が保持され、出力されます。</p>\n<p><b>st</b>が0のとき、<b>d</b>の値は無視され、以前に保持された値が引き続き出力されます。</p>\n\n<table class='data'>\n<colgroup class=input><col><col></colgroup>\n<colgroup class=input><col></colgroup>\n<colgroup class=output><col></colgroup>\n<tr><th colspan=2>入力</th><th>出力</th></tr>\n<tr><th>st</th><th>d</th><th></th><th></th></tr>\n<tr><td>1</td><td>0</td><td>0</td></tr>\n<tr><td>1</td><td>1</td><td>1</td></tr>\n<tr><td>0</td><td>1</td><td>前回と同じ</td></tr>\n<tr><td>0</td><td>0</td><td>前回と同じ</td></tr>\n</table>\n\n<p>初めて<b>st</b>がセットされるまでの出力（初期出力）は未規定であり、任意の値が許容されます。</p>"
    },
    "DFF": {
      "title": "データフリップフロップ",
      "splash": "<p>ラッチを使うことで、時間の経過に伴って状態が変わる回路を作成できます。</p>\n\n<p>しかし、困ったことに、状態変化のタイミングが回路全体で同期されていないため、状態変化が回路内を伝播する順序が予測できず、競合や、一般的に予測不可能な結果を引き起こします。</p>\n\n<p>その解決策が<b>クロック信号</b>です。これは、周期的に変化し、状態を持つすべてのコンポーネントに接続される1ビットの信号です。</p>\n\n<p>コンポーネントがクロック信号の変化時にのみ出力を変更するようにすれば、回路全体で変化が同時に発生し、同期の問題を回避できます。</p>\n\n<p>このタスクでは、<b>フリップフロップ</b>コンポーネントを作成します。フリップフロップは、クロック信号が1のときにビットを保持する一方で、その後クロック信号が0に変わって初めて、保持されたビットを出力し始める部品です。</p>\n",
      "specification": "\n<p>DFF（データフリップフロップ）コンポーネントは、1ビットを保持し出力します。入力が変わっても出力はすぐには更新されません。変更は段階的に、<b>cl</b>（クロック）信号が0と1の間で切り替わるタイミングで行われます。</p>\n\n<p><b>cl</b>=0<br>この段階では入力フラグ<b>st</b>と<b>d</b>を変更できます。</p>\n<p><b>cl</b>=1<br><b>cl</b>が1に変わるときに<b>st</b>=1であれば、現在の<b>d</b>の値が保持されます。ただし、保持された値はまだ出力されません。</p>\n<p><b>cl</b>=0<br><b>cl</b>が再び0に変わると、以前に保持された値が出力されます。</p>\n\n<p>cl=1のときの入力の影響:</p>\n\n<table class=truth>\n<colgroup class=input><col><col></colgroup>\n<colgroup class=input><col></colgroup>\n<tr><th colspan=2>入力</th><th>影響</th></tr>\n<tr><th>st</th><th>d</th><th></th></tr>\n<tr><td>1</td><td>0</td><td>次の出力 = 0</td></tr>\n<tr><td>1</td><td>1</td><td>次の出力 = 1</td></tr>\n<tr><td>0</td><td>0</td><td>変更なし</td></tr>\n<tr><td>0</td><td>1</td><td>変更なし</td></tr>\n</table>\n\n<p><b>st</b>がまだセットされていなかったり、クロックが 1 サイクル回っていなかったりする段階での出力は未規定です。cl=1 となっている最中に入力に変更がないことを前提とします。</p>",
      "elaboration": "<p>クロック信号はメトロノームのようなもので、すべてのコンポーネントが同時に変化するようにします。</p>\n\n<p><b>クロックサイクル</b>とは、クロック信号が0から1に変わり、次に1から0に戻るまでの時間のことです。</p>\n\n<p>実際のプロセッサでは、振動する水晶を用いてクロック信号を発生させます。このゲームでは、クロック信号は手動入力となっており、手動で回路をテストできるようになっています。</p>\n\n<p><b>クロックレート</b>とは、クロックがどれだけ速く変化するかを示します。クロックレートが高いほど、コンピュータの動作が速くなります。</p>\n\n<p>注意: 「クロック」という名前は「時計」という意味ですが、クロック自体は時間を計るわけではありません。あくまで、規則的なリズムにのった信号を送るだけです。しかし、カウンターと組み合わせることで、時間を計測するコンポーネントを作成することもできます。</p>\n",
      "spoilers": [
        "<p>ラッチを2つ使用する必要があります。</p>",
        "<p>1つ目のラッチはcl=1のときに書き込まれるようにしましょう。2つ目のラッチは、cl=0のときに1つ目のラッチから書き込まれるようにしましょう。</p>"
      ]
    },
    "DFF2": {
      "title": "レジスタ",
      "splash": "<p>ここまでで、1ビットのデータを保存できるようになりました。</p>\n<p>このミッションでは、2つのデータフリップフロップ（DFF）を組み合わせて、<b>2</b>ビットのデータを一度に保持したり取得したり操作を行います。</p>\n<p>（最終的には16ビットのワードを一度に保持したり取得したりしたいと考えていますが、2ビットを保持する方法さえわかってしまえば、それより大きなものも保持する方法は考えるまでもなく明らかです。）</p>\n",
      "specification": "<p><b>2ビットDFF</b>コンポーネントは、通常のデータフリップフロップと同様に動作しますが、1ビットではなく2ビット（<b>d1</b>と<b>d0</b>）が保持され、出力されます。</p>",
      "elaboration": "今回の、2ビットを保持する部品の設計は、そのまま繰り返すことができます。\n これを繰り返して16ビットを保持する部品を作成します。このコンポーネントは<b>レジスタ</b>と呼ばれます。\n",
      "debriefing": "2ビットを保持する部品の設計を繰り返していくことで、8ビット、16ビット、32ビットを保持する部品を簡単に作成していけます。\n<p>ここでは16ビットコンピュータを作り上げようとしていっているので、16ビットの保存ユニット（<b>レジスタ</b>と呼ばれる）を作ってツールボックスに追加しておきました。</p>\n"
    },
    "COUNTER": {
      "title": "カウンター",
      "splash": "<p>次のタスクは、クロックサイクルごとに数値をインクリメントする「カウンター」を作成することです。</p>\n<p>カウンターはプロセッサの中核をなすコンポーネントであり、命令の実行を進める役割を担います。</p>\n",
      "specification": "<p><b>カウンター</b>コンポーネントは、クロックサイクルごとに16ビットの数値をインクリメントします。</p>\n\n<p><b>st</b>（ストア）が1の場合、入力値<b>X</b>が新しいカウンターの値として使用されます。</p>\n\n<p><b>st</b>が0の場合、前回のカウンター値に1を加算します。</p>\n<p>カウンターの出力は、<b>cl</b>（クロック信号）が0に変わるときに更新されます。</p>\n\n<table class=\"data\">\n <colgroup class=input><col><col></colgroup>\n <colgroup class=input><col></colgroup>\n\n<tr><th colspan=2>入力</th><th>効果</th></tr>\n<tr><th>st</th><th>cl</th><th></th></tr>\n<tr><td>0</td><td>0</td><td class=text><b>next</b>を<b>output</b> + 1に設定</td></tr>\n<tr><td>1</td><td>0</td><td class=text><b>next</b>を<b>X</b>に設定</td></tr>\n</table>\n\n<p><b>output</b>はコンポーネントの現在の出力です。<b>next</b>は、<b>cl</b>が0に変わったタイミングで、「現在の出力」となります。</p>",
      "spoilers": [
        "レジスタのコンポーネントが 1 つ必要です。"
      ]
    },
    "RAM": {
      "title": "RAM",
      "splash": "<p>これで、レジスタに16ビットのワードを保存できるようになりました。</p>\n<p>これらのレジスタを積み増していくだけで、もっとたくさんの情報を記憶していくことができます。</p>\n<p>しかし、プロセッサは1度に1つのワードのみを操作するのですから、積み増したものの中から適切なワードだけを選択してそれを変更する方法が必要です。</p>\n<p>このために使うのが、メモリアドレスです。</p>\n<p>メモリ内の各ワードに番号を割り当てることで、この番号を使用して特定のワードを取得したり、特定のワードを上書きしたりすることができます。</p>\n\n<p>このミッションでは、2つのレジスタを使用し、1ビットのアドレスを使ってそれらをアドレス指定します。</p>\n",
      "specification": "<p>1ビットのアドレスで指定でき、書き込み可能な2つの16ビットレジスタを持つメモリを作成しましょう。</p>\n\n<h3>入力</h3>\n<p><b>ad</b>（アドレス）は、どちらの記憶領域にアクセスしにいくのかを示します。</p>\n<p><b>st</b>（ストア）は、書き込みを行うかどうかを示します。</p>\n<ul>\n<li>1の場合、<b>X</b>の値が指定された記憶領域に書き込まれます。</li>\n<li>0の場合、<b>X</b>は無視されます。</li>\n</ul>\n<p><b>X</b>（データ）は16ビットの値です。</p>\n<p><b>cl</b>（クロック信号）は状態の変化を同期させます。<b>cl</b>=0のときに<b>X</b>が保存されますが、<b>cl</b>が1に変わるまで出力は行われません。</p>\n\n<h3>出力</h3>\n<p><b>ad</b>で指定された記憶領域に現在保存されている値。</p>",
      "elaboration": "<p>2ワード分のメモリではあまり多くはありません。しかし、これがうまく機能すれば、この設計を再帰的に繰り返して、4ワード、8ワード、16ワードと増やしていくことができます。</p>\n\n<h3>アドレス指定</h3>\n<p>メモリ内のデータワードには、0から順に番号が付けられます。このメモリワードの番号が<b>アドレス</b>と呼ばれるものです。\nメモリ上の各ワードを読み書きするときには、このアドレスを使ってアクセスします。</p>\n\n<p>メモリにワードが2つしかない場合、アドレスは2通りのみであり、1ビットで選択できます。しかし、我々が作ろうとしているのは16ビットのアーキテクチャですから、16ビットのアドレスまで対応でき、つまり65,536個のワードの中から選んでアクセスすることができるようになります。</p>\n\n<p>このようなメモリはRAM（ランダムアクセスメモリ）と呼ばれ、アドレスさえ知っていれば、どのワードにもアクセスして値を更新することができます。</p>\n\n<div class=subject>\n<h3>バイトとKB</h3>\n<p>メモリ容量（RAMおよびその他のストレージ）は<b>バイト</b>で測定されます。1バイトは8ビットです。\n16ビットのアーキテクチャでは、16ビットワードを一度に保存および取得するため、各ワードは2バイトです。\n16ビットで表現できる範囲は0から65535までなので、65,536個のワードを持つことができ、バイト単位で測定するとその2倍、つまり131,072バイトになります。これは通常、128KB（KB = キロバイト）と表記されます。</p>\n\n<p>バイトを測定する場合、Kは1000を意味するのではなく、1024を意味するということになっており、128 × 1024 = 131,072なので、131,072は128Kになります。</p>\n\n</div>\n",
      "debriefing": "<p>1ビットのアドレスを指定できるこのRAMの設計を再帰的に繰り返すことで、より大きなRAMユニットを構築できます。</p>"
    },
    "DISPLAY16": {
      "title": "ディスプレイ",
      "specification": "<p>LEDランプを5×3のグリッドに配置します。ランプはメモリとつながっており、16ビットの値を書き込むと、1クロックサイクル後にランプがそれに応じて点灯します。</p>\n<p>ランプは、ビットパターン<code>1111001101001000</code>が<p><code>● ● ●<br>●</br>● ●<br>●<br>●</code></p>と表示されるように配置されるべきです。</p>\n<p>（最後のビットは使用されません）</p>"
    },
    "ALU_PRESET": {
      "title": "一項演算ALU",
      "splash": "<p>これまでに作成したコンポーネントは、すべて特定の単一の操作を実行してきました。</p>\n<p>ALU（算術論理演算装置）は、加算、減算、ビット反転など、さまざまな論理および算術演算を実行できる中核的なコンポーネントです。</p>\n<p>複数の制御ビットを受け取り、それによってどの操作を実行するのかが決定されます。</p>\n<p>ここでは、ALUを2段階に分けて実装していきましょう。最初のステップは「一項演算ALU」で、入力をビット反転させるか、ゼロに置き換えます。</p>",
      "specification": "<p><b>一項演算ALU</b>は、単一の入力<b>X</b>を変更します。どの操作を適用するかを選択するための、2つのフラグがあります。</p>\n\n<p><b>z</b>（ゼロ）が1の場合、入力の代わりに0が出力されます。</p>\n<p><b>n</b>（否定）が1の場合、入力がビット反転されます。</p>\n<p>両方が1の場合、出力は0のビット反転になります。つまり、操作を適用する順序に気をつける必要があるということです。</p>\n\n<p>仕様:</p>\n<table class='data'>\n<colgroup class=input><col><col></colgroup>\n<colgroup class=output><col></colgroup>\n<tr><th colspan=2>入力</th><th>出力</th></tr>\n<tr><th>z</th><th>n</th><th></th><th></th></tr>\n<tr><td>0</td><td>0</td><td>Xのまま</td></tr>\n<tr><td>1</td><td>0</td><td>0</td></tr>\n<tr><td>0</td><td>1</td><td>Xをビット反転</td></tr>\n<tr><td>1</td><td>1</td><td>0をビット反転</td></tr>\n</table>\n",
      "elaboration": "<h3>算術論理演算装置 (ALU) の設計</h3>\n\n<p>ALUは、さまざまな算術および論理演算を実行できるコンポーネントです。\n今回のALUでは、入力はXとYの2つがあり、それに加えていくつかのオプション（フラグ）も入力として受け取り、オプションに応じてどの操作を実行するかが選択されます。</p>\n\n<p>ALUが実行できる操作には、加算（X+Y）、減算（X-Y または Y-X）、ビットAND（X and Y）、ビットOR（X or Y）などがあります。また、一方の入力に対してのみ操作を実行することもできます。例えば、インクリメント（X+1）、デクリメント（X-1）、Xのビット反転、マイナスX（0-X）といったものを計算できます。</p>\n\n<p>これらすべての操作をサポートするには非常に複雑なコンポーネントが必要に見えるかもしれませんが、実際には、各入力と出力に対して2つの変更をしたりしなかったりするようにする機能を組み合わせるだけで達成できます。</p>\n\n<p>例えば、「減算」ステージで確認したように、1つの入力と出力をビット反転することさえできれば、減算を加算の形で実装できます。\nまた、「インクリメント」ステージで見たように、インクリメント（Xに1を加える）はYを0に置き換えてからビット反転して減算することで実装できます。</p>\n<p>入力 2 つおよび出力の中から上手く選んでビット反転またはゼロにするだけで、かなり多くの算術演算を実装できます。</p>\n\n<p>ということで、ALUを2段階で実装していきます。まず、入力をビット反転またはゼロにできる一項演算コンポーネントを構築します。（「一項演算」とは、単一の数に対して操作を行うことを意味します）\nそして次の段階で、この入力/出力修飾子を二項演算と組み合わせて、ALUを完成させます。</p>"
    },
    "ALU": {
      "title": "ALU",
      "splash": "<p>これで、ALU自体を構築できるようになりました。</p>\n<p>2つの16ビット入力値と、入力に対してどの操作を実行するかを指示する6つのオプションがあります。</p>",
      "specification": "<p>ALU（算術論理演算装置）は、2つの入力値<b>X</b>と<b>Y</b>に対して1つまたは複数の操作を実行します。</p>\n\n<p>6つのフラグにより、どのような操作が実行されるのか決まります。各フラグは、1になっているときに以下の操作を引き起こします。</p>\n\n<table>\n<tr><th>zx</th><td>Xを0にする</td></tr>\n<tr><th>nx</th><td>Xをビット反転する</td></tr>\n<tr><th>zy</th><td>Yを0にする</td></tr>\n<tr><th>ny</th><td>Yをビット反転する</td></tr>\n<tr><th>f</th><td>操作を選択する。\n <br />0の場合：出力はX AND Y\n <br />1の場合：出力はX + Y</td></tr>\n<tr><th>no</th><td>出力をビット反転する</td></tr>\n</table>\n\n<p>フラグは組み合わせることができ、その際には順序が重要です。（訳注：上の表での掲載順に基づいて操作を適用するということ）</p>\n<p>例えば、<b>zx</b>と<b>nx</b>が両方とも1の場合、Xは0のビット反転となります。</p>",
      "elaboration": "<p>6つのフラグを組み合わせることで、幅広い算術操作を実行できます。</p>\n<p>いくつかの例を挙げると、こうなります。</p>\n<table class='data numbers'>\n<tr><th>zx</th><th>nx</th><th>zy</th><th>ny</th><th>f</th><th>no</th><th>結果</th></tr>\n<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>X + Y</td></tr>\n<tr><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>X - 1</td></tr>\n<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>X AND Y</td></tr>\n<tr><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>X - Y</td></tr>\n<tr><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>\n<tr><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr>\n</table>\n\n<p>特定のフラグの組み合わせが特定の結果を引き起こす理由がすぐにはわからないかもしれませんが、自分で試してみてその仕組みを確認してみてください。</p>\n\n<p>（このALUの設計は、<a href=\"https://www.nand2tetris.org/\">Nand to Tetrisコース</a>に基づいており、許可を得てここで使用しています。）</p>\n"
    },
    "ALU_LOGIC": {
      "title": "ビット演算装置",
      "splash": "<p>これで、さまざまな操作を利用できるようになりました。さて、プロセッサの本質的に重要な役割として、「入力に基づいて異なる操作を選択できる」というものがあります。まずは、4種類のビット演算の中から1つを選択できるコンポーネントを作ることから始めましょう。</p>",
      "specification": "<p>2つの16ビット入力<b>X</b>と<b>Y</b>に対して、指定されたビット演算を行います。以下の4種類のうちどのビット演算を行うかは、2つのビットフラグ<b>op0</b>と<b>op1</b>で指定します。</p> \n\n<table class=truth>\n<tr><th>op1</th><th>op0</th><th>出力</th></tr> \n<tr><td>0</td><td>0</td><td>X AND Y</td></tr> \n<tr><td>0</td><td>1</td><td>X OR Y</td></tr> \n<tr><td>1</td><td>0</td><td>X XOR Y</td></tr> \n<tr><td>1</td><td>1</td><td>Xをビット反転</td></tr>\n</table>\n"
    },
    "ALU_ARITHMETIC": {
      "title": "算術演算装置",
      "specification": "<p>2つの16ビット入力<b>X</b>と<b>Y</b>に対して、指定された算術演算を行います。以下の4種類のうちどの算術演算を行うかは、2つのビットフラグ<b>op0</b>と<b>op1</b>で指定します。</p> \n\n<table class=truth>\n<tr><th>op1</th><th>op0</th><th>出力</th></tr>\n<tr><td>0</td><td>0</td><td>X + Y</td></tr>\n<tr><td>1</td><td>0</td><td>X - Y</td></tr>\n<tr><td>0</td><td>1</td><td>X + 1</td></tr>\n<tr><td>1</td><td>1</td><td>X - 1</td></tr>\n</table>"
    },
    "ALU2": {
      "title": "ALU",
      "specification": "<p>ALU（算術論理演算装置）は、論理演算（ビット演算）をする装置と算術演算をする装置を組み合わせたものです。</p>\n<table class=truth>\n<colgroup class=input><col><col><col></colgroup>\n<colgroup class=output><col></colgroup>\n<tr><th colspan=3>入力</th><th>出力</th></tr>\n<tr><th>u</th><th>op1</th><th>op0</th><th></th></tr>\n<tr><td>0</td><td>0</td><td>0</td><td>X AND Y</td></tr>\n<tr><td>0</td><td>0</td><td>1</td><td>X OR Y</td></tr>\n<tr><td>0</td><td>1</td><td>0</td><td>X XOR Y</td></tr>\n<tr><td>0</td><td>1</td><td>1</td><td>Xをビット反転</td></tr>\n<tr><td>1</td><td>0</td><td>0</td><td>X + Y</td></tr>\n<tr><td>1</td><td>1</td><td>0</td><td>X - Y</td></tr>\n<tr><td>1</td><td>0</td><td>1</td><td>X + 1</td></tr>\n<tr><td>1</td><td>1</td><td>1</td><td>X - 1</td></tr>\n</table>\n<p></p>\n\n<p>オペランドに変更を加えるためのフラグがさらに2つあります。</p>\n<ul>\n<li><b>sw</b>フラグが1の場合、<b>X</b>入力と<b>Y</b>入力が交換されます。</li>\n<li><b>zx</b>フラグが1の場合、左のオペランドが<code>0</code>に置き換えられます。</li>\n</ul>\n\n<p>例えば<code>X - Y</code>の操作に対してはこれらのフラグは以下のような影響をもたらします。</p>\n<table class=truth>\n<colgroup class=input span=2><colgroup class=output span=1>\n<tbody>\n<tr><th>zx</th><th>sw</th><th>実際に起こる操作</th></tr>\n<tr><td>0</td><td>0</td><td>X - Y</td></tr>\n<tr><td>0</td><td>1</td><td>Y - X</td></tr>\n<tr><td>1</td><td>0</td><td>0 - Y</td></tr>\n<tr><td>1</td><td>1</td><td>0 - X</td></tr>\n</tbody>\n</table>"
    },
    "OPCODES1": {
      "title": "オペコード",
      "specification": "<p>オペコードの式に対応する、ALUのビットフラグの組み合わせを選択してください。</p>\n<p>ほとんどの式については説明不要かと思います。</p>\n<p><b>~</b>はビット反転を表します。入力のすべてのビットを反転させます。</p>\n<p><b>&</b>はビット<b>AND</b>、<b>|</b>はビット<b>OR</b>です。</p>\n<p>注意: いくつかの行には、複数の正解がある場合があります。</p>",
      "spoilers": [
        "減算ステージで見たように、Xのビット反転はマイナスXから1を引いたものに等しいです。つまり、~X = -X-1 です。\n",
        "<p>したがって、<b>nx</b>フラグにより -X-1 が、<b>ny</b>フラグにより -Y-1 が出てきます。</p>"
      ],
      "elaboration": "<p>このステージによって、ビットフラグの組み合わせを変えるだけで様々なビット演算および算術演算が実行できることが明らかになったかと思います。さらに、<b>オペコード</b>がどんな役割を果たしているのかも見て取れたかと思います。オペコードは、対応するビットの集まりをテキストや記号として表現したものであり、そのままのビットの集まりだったり2進数だったりといった表現方法と比べて、人間にとってはるかに読みやすく理解しやすいものです。</p>\n"
    },
    "CONDITION": {
      "title": "条件",
      "specification": "<p>以下の3つのフラグで、数値<b>X</b>に対して考えられる3つの条件を表します。</p>\n\n<table class='data text'>\n<tr><th>フラグ</th><th>条件</th></tr>\n<tr><td><b>lt</b></td><td>0未満</td></tr>\n<tr><td><b>eq</b></td><td>0と等しい</td></tr>\n<tr><td><b>gt</b></td><td>0より大きい</td></tr>\n</table>\n\n<p>今回作るコンポーネントでは、入力フラグで指定された条件のどれかを入力Xが満たしているときに1を出力するようにしてください。</p>\n<p>なお、フラグを組み合わせることで、以下のような条件を指定することができます。</p>\n\n<table class='data'>\n<tr><th colspan=3>フラグ</th><th>1を出力する条件</th></tr>\n<tr><th>lt</th><th>eq</th><th>gt</th><th></th></tr>\n<tr><td>0</td><td>0</td><td>0</td><td>決して出力されない</td></tr>\n<tr><td>0</td><td>0</td><td>1</td><td>X &gt; 0</td></tr>\n<tr><td>0</td><td>1</td><td>0</td><td>X = 0</td></tr>\n<tr><td>0</td><td>1</td><td>1</td><td>X ≧ 0</td></tr>\n<tr><td>1</td><td>0</td><td>0</td><td>X &lt; 0</td></tr>\n<tr><td>1</td><td>0</td><td>1</td><td>X ≠ 0</td></tr>\n<tr><td>1</td><td>1</td><td>0</td><td>X ≦ 0</td></tr>\n<tr><td>1</td><td>1</td><td>1</td><td>常に出力される</td></tr>\n</table>\n",
      "spoilers": [
        "3つの条件のうち、同時に真となるのは1つだけです。",
        "最初の2つの条件を判定するためのコンポーネントは既に作りましたね。",
        "「X ≦ 0」とは、Xが0より小さい<u>または</u>0に等しいことを意味します。",
        "<b>lt</b>=1かつX < 0の場合、または<b>eq</b>=1かつX = 0の場合、または<b>gt</b>=1かつX > 0の場合に、出力が1になります。"
      ]
    },
    "CPU_STATE": {
      "specification": "<p>プロセッサの用いる記憶装置には、AとDという2つの16ビットレジスタと、RAMユニットがあります。</p>\n\n<p><b>a</b>、<b>d</b>、<b>*a</b>のフラグと<b>X</b>入力を使って、1つ以上のレジスタを更新します。</p>\n\n<table class='data text'>\n<tr><th>フラグ</th><th>操作</th></tr>\n<tr><td>a</td><td>AレジスタにXを書き込む</td></tr>\n<tr><td>d</td><td>DレジスタにXを書き込む</td></tr>\n<tr><td>*a</td><td>Aレジスタで指定されたアドレスのRAMにXを書き込む</td></tr>\n</table>\n\n<p>フラグは組み合わせることができ、<b>X</b>を複数のレジスタに同時に書き込むことができます。3つフラグがすべて0の場合、X入力は無視されます。</p>\n\n<p><b>cl</b>はクロック信号です。</p>\n\n<table class='data text'>\n<tr><th>出力</th><th>内容</th></tr>\n<tr><td>A</td><td>Aレジスタの現在の値</td></tr>\n<tr><td>D</td><td>Dレジスタの現在の値</td></tr>\n<tr><td>*A</td><td>Aレジスタで指定されたアドレスのRAMに現在保存されている値</td></tr>\n</table>",
      "title": "記憶装置を統合する",
      "splash": "プロセッサは、レジスタとRAMという2種類の記憶装置を使用します。\n<p>レジスタはプロセッサによって直接アクセスでき、一時的なデータの保存や計算処理に使われます。\nRAMは大量のデータを保存できますが、同時に読み書きできるのは一つのアドレスに対してのみです。</p>\n<p>このプロセッサには、<b>A</b>と<b>D</b>という2つのレジスタと1つのRAMバンクがあります。</p>\n<p>このミッションでは、2つのレジスタとRAMバンクを組み合わせます。</p>",
      "elaboration": "<p>このプロセッサには、レジスタとRAMという2段階の記憶装置があります。</p>\n<p>RAMは圧倒的に大きな容量を持っていますが、RAMからデータを読み取るためにはアドレスが必要なので、アドレスそのものを記憶する装置がほしくなります。また、処理の途中で使う一時的な値を記憶することも必要になります。これらの需要に応えるべく、このプロセッサにはA（アドレス用）とD（データ用）の2つのレジスタがあります。</p>\n\n\n<p>実際のプロセッサには、十数個やそれ以上の個数のレジスタがあることが多いですが、今回のプロセッサでは必要最小限として2つだけ用意することにします。</p>\n\n<h3>フラグ</h3>\n<p><u>フラグ</u>とは、特定のオプションを選択するための入力ビットを指す用語です。複数のフラグがある場合、それぞれを独立にオンオフできます。\n例えば、このコンポーネントでは、<b>a</b>、<b>d</b>、<b>*a</b>のフラグがあり、これらは任意の組み合わせで設定することができます。すべてオンにすることも、すべてオフにすることも可能です。</p>\n"
    },
    "ALU_INSTRUCTION": {
      "title": "命令（インストラクション）",
      "specification": "<p>入力<b>I</b>は、ALUコンポーネントと条件コンポーネントに対する命令を指定します。Iのそれぞれのビットが以下のような役割を持つようにしてください。</p>\n\n<table class='data'>\n<tr><th>入力</th><th colspan=2>出力</th><th></th></tr>\n<tr><th>ビット</th><th>グループ</th><th>フラグ</th></tr>\n\n<tr><td>10</td><td>ALU</td><td>u</td></tr>\n<tr><td>9</td><td>ALU</td><td>op1</td></tr>\n<tr><td>8</td><td>ALU</td><td>op0</td></tr>\n<tr><td>7</td><td>ALU</td><td>zx</td></tr>\n<tr><td>6</td><td>ALU</td><td>sw</td></tr>\n\n<tr><td>5</td><td>書き込み先</td><td>a</td></tr>\n<tr><td>4</td><td>書き込み先</td><td>d</td></tr>\n<tr><td>3</td><td>書き込み先</td><td>*a</td></tr>\n\n<tr><td>2</td><td>条件</td><td>lt</td></tr>\n<tr><td>1</td><td>条件</td><td>eq</td></tr>\n<tr><td>0</td><td>条件</td><td>gt</td></tr>\n</table>\n\n<p>入力A、入力D、および 入力*Aは、それぞれのレジスタの値です。</p>\n<p>ALUのX入力にはDを、Y入力には命令の第12ビットに応じてAまたは*Aを指定してください。第12ビットが0の場合はA、1の場合は*Aです。</p>\n<p><b>R</b>出力には、ALU操作の結果を出力してください。</p>\n<p><b>j</b>フラグでは、ALUの出力がビット0-2で指定された条件に一致するかどうかを示してください。</p>\n"
    },
    "CONTROL_UNIT": {
      "title": "制御装置",
      "splash": "プログラムとは、命令が列をなしたもののことです。それぞれ命令は、以下の情報を指定するためのビットフラグを集めることで構成されています。\n<ul>\n<li>実行するALU操作</li>\n<li>入力として使用するレジスタ</li>\n<li>結果を格納するレジスタ</li>\n</ul>",
      "specification": "<p>ALU命令に加えて、<b>データ命令</b>もサポートするようにしましょう。データ命令では、命令の値が直接Aレジスタに書き込まれます。</p>\n<p>命令<b>I</b>の最上位ビットに応じて、データ命令またはALU命令を実行する制御装置を作成してください。</p>\n\n<table class=data>\n<tr><th>第15ビット</th><th>命令の種類</th></tr>\n<tr><td>0</td><td>データ命令</td></tr>\n<tr><td>1</td><td>ALU命令</td></tr>\n</table>\n\n<h3>ALU命令</h3>\n<p>ALU命令の場合、出力は前のステージで指示された通りにしてください。RはALU操作の結果となるようにしましょう。</p>\n\n<h3>データ命令</h3>\n<p>データ命令の場合、出力<b>R</b>は入力<b>I</b>そのものであり、結果を格納するのはAレジスタになります。つまり、<b>a</b>は1にし、<b>d</b>、<b>*a</b>、および<b>j</b>フラグはすべて0に設定してください。</p>"
    },
    "CPU3": {
      "specification": "<p>以下の要素を組み合わせてコンピュータを構築してください。</p>\n<ul>\n<li>制御装置</li>\n<li>記憶装置（RAMとレジスタ）</li>\n<li>プログラムメモリユニット（ROM）</li>\n<li>現在の命令アドレスを追跡するカウンター（「プログラムカウンター」または<b>PC</b>と呼ばれます）</li>\n<li>クロックユニット</li>\n</ul>\n\n<p>プログラムメモリ内のPCアドレスにあるワードが、制御装置への<b>I</b>入力となります。</p>\n\n<p>各クロックサイクルで、<b>j</b>の値に応じてプログラムカウンターが変化します。</p>\n<p><b>j</b>=0 の場合、プログラムカウンターを1進めてください。</p>\n<p><b>j</b>=1 の場合、PCを<b>A</b>の値に設定してください。</p>\n",
      "splash": "最終チャレンジに到達しました。これを完成させれば、プログラム可能であり使い物になるマイクロプロセッサを構築したことになります。",
      "title": "コンピュータ"
    },
    "IO": {
      "title": "入出力",
      "splash": "<p>コンピュータが実際に何らかの役に立つためには、外界と情報をやりとりできる必要があります。</p>\n<p>画面、キーボード、タッチセンサー、ネットワークインターフェースなどのハードウェアデバイスを通じて、情報のやりとりが行われます。</p>\n\n<p>このステージでは、今まで作ってきたコンピューターを、モーターやセンサーといった簡単なロボットのハードウェアと合体させます。</p>\n\n",
      "specification": "<p>コンピューターをロボットのハードウェアと合体させ、メモリアドレスのようにしてハードウェアを読み書きできるようにしてください。</p>\n\n<p>入力信号は、<b>st</b>（ストア）が1であり、かつ<b>cl</b>（クロック信号）が1の場合に、ハードウェアに送信されるようにします。</p>\n\n<p>出力信号は、即座に読み取れるようにしてください。</p>\n\n<p><b>X</b>の入力ビットとデバイス制御信号の対応関係は以下の通りです。</p>\n<table class=data>\n<tr><th>ビット</th><th>制御信号</th></tr>\n<tr><td>15</td><td>lo</td></tr>\n<tr><td>14</td><td>lf</td></tr>\n<tr><td>13</td><td>mv</td></tr>\n<tr><td>12</td><td>stp</td></tr>\n<tr><td>11</td><td>tl</td></tr>\n<tr><td>10</td><td>tr</td></tr>\n<tr><td>09</td><td>zp</td></tr>\n</table>\n\n<p>デバイスセンサーと出力ビットの対応関係は以下の通りです。</p>\n<table class=data>\n<tr><th>ビット</th><th>センサー出力</th></tr>\n<tr><td>3</td><td>mv</td></tr>\n<tr><td>2</td><td>tn</td></tr>\n<tr><td>1</td><td>ob</td></tr>\n<tr><td>0</td><td>lf</td></tr>\n</table>\n",
      "elaboration": "<p><b>メモリマップト</b>入出力とは、外部デバイスへの接続が通常のRAMユニットと一緒にメモリアドレス空間に組み込まれていることを意味します。</p>\n\n（訳注：日本語では「メモリマップ<b>ド</b>」と書かれることも多い）\n\n<p>これにより、プロセッサは、メモリに対して読み書きを行うのとまったく同じ方法で、出力デバイスに情報を書き込んだり入力デバイスから情報を読み取ったりすることができます。</p>\n\n<p></p>"
    },
    "IO2": {
      "elaboration": "<p><b>メモリマップト</b>入出力とは、外部デバイスへの接続が通常のRAMユニットと一緒にメモリアドレス空間に組み込まれていることを意味します。</p>\n\n（訳注：日本語では「メモリマップ<b>ド</b>」と書かれることも多い）\n\n<p>これにより、プロセッサは、メモリに対して読み書きを行うのとまったく同じ方法で、出力デバイスに情報を書き込んだり入力デバイスから情報を読み取ったりすることができます。</p>\n\n<p></p>",
      "title": "入出力",
      "splash": "<p>コンピュータが実際に何らかの役に立つためには、外界と情報をやりとりできる必要があります。</p>\n<p>画面、キーボード、タッチセンサー、ネットワークインターフェースなどのハードウェアデバイスを通じて、情報のやりとりが行われます。</p>\n<p>このステージでは、コンピューターをランプとボタンといった簡単なハードウェアデバイスと合体させます。</p>\n",
      "specification": "<p>ランプとボタンを接続し、メモリアドレスのようにしてランプやボタンにアクセスできるようにしてください。</p>\n\n<p><b>デバイスへの出力</b></p>\n<p>ランプは<b>X</b>の第0ビットと第1ビットによって制御されます。</p>\n<p>第1ビットが1のとき、ランプの<b>on</b>入力に信号が入るようにしてください。第0ビットが1のとき、ランプの<b>off</b>入力に信号が入るようにしてください。</p>\n<p><b>st</b>（ストア）が1であり、かつ<b>cl</b>（クロック信号）が1の場合に、信号がハードウェアに送信されるようにしてください。</p>\n\n<p><b>デバイスからの入力</b></p>\n<p>ボタンの状態はコンポーネント出力の第15ビットに表示されるようにしてください。</p>\n<p>ボタンが押されているときは第15ビットが1になり、押されていないときは0になるようにしてください。</p>\n<p>入力信号は即座に読み取れるようにしてください。</p>"
    },
    "PROGRAM1": {
      "title": "機械語",
      "specification": "<p>次の4つの命令からなるプログラムを書いてください。</p>\n<p>0) Dレジスタを0に設定する <br>1) Aレジスタを2に設定する <br>2) Dレジスタに1を加算する <br>3) 無条件でジャンプする</p>\n\n<p>プログラムを実行した結果は、「1回反復するたびに<b>D</b>が1ずつ増加する」というものになるはずです。</p>\n<p>それぞれの命令に対して適切なビットフラグを設定することでプログラムを書いていってください。</p>\n<p><b>Clock Tick</b>ボタンをクリックすると、コンピュータが命令を1つ実行します。</p>\n"
    },
    "OPCODES2": {
      "title": "アセンブリ言語",
      "specification": "<p>記号で書かれた命令をバイナリ(2進数)の機械語に変換するアセンブラを組み上げてください。</p>\n<p>アセンブラ命令は、<u>書き込み先</u>、<u>計算</u>、および（あってもなくてもいい）<u>ジャンプ条件</u>の3つの部分から構成されます。</p>\n<p>「書き込み先」は、操作の出力が書き込まれるレジスタを指定します。</p>\n<p>「計算」はALU操作です。ビットパターンについては、ALUのステージを参照してください。</p>\n<p>「ジャンプ条件」は、ジャンプを引き起こす条件です。どういう構造だったかについては、「条件」のステージを参照してください。</p>\n<p>算術記号<code>+</code>および<code>-</code>はそのままの意味です。ビット演算の記号は以下の通りです。</p>\n<table class=data>\n<tr><th>記号</th><th>意味</th></tr>\n<tr><td><code>X&Y</code></td><td>16ビットのビットAND</td></tr>\n<tr><td><code>X|Y</code></td><td>16ビットのビットOR</td></tr>\n<tr><td><code>~X</code></td><td>16ビットのビット反転</td></tr>\n</table>\n",
      "splash": "<p>直接命令ビットを設定してコンピュータをプログラミングするのは非常に時間がかかり、ミスが発生しやすいものです。</p>\n<p>そして、何より退屈です。</p>\n<p>そこで、命令ビットの代わりに文字や記号を使ってテキスト形式で機械語を表現する、いわゆる<b>アセンブラ</b>言語を作成していきましょう。</p>\n<p>記号で書かれた命令をバイナリ(2進数)の機械語に変換するもののことを、<b>アセンブラ</b>と呼びます。</p>\n<p>このステージでは、我々がこれまで組んできた機械のためのアセンブラを組み上げていきます。</p>\n"
    },
    "ASSEMBLER1": {
      "title": "アセンブリプログラム",
      "splash": "<p>そろそろお気づきかもしれませんが、バイナリ(2進数)の機械語でプログラムを書くのは、非常にめんどくさく退屈な作業です。</p>\n<p>それを簡単にするために、命令をテキスト形式で記述する<b>アセンブリ言語</b>を使用します。アセンブリ言語で書かれたテキストの各行が機械語の命令に対応しています。そうしたら、<b>アセンブラ</b>というプログラムを使って、このテキストを機械語に変換するのです。</p>\n<p>このミッションでは、アセンブリ言語でプログラムを書いていきます。</p>",
      "specification": "<p>アセンブリ言語で、ランプを少なくとも3回点滅させるプログラムを書いてください。</p>\n<p>ランプはアドレス7FFFにメモリマップされており、第1ビットと第0ビットで制御します。</p>\n<table class='data text'>\n<tr><th>ビット</th><th>1に設定すると</th></tr>\n<tr><td>0</td><td>ランプを点灯させる</td></tr>\n<tr><td>1</td><td>ランプを消灯させる</td></tr>\n</table>\n<p>外部デバイスは、ビットが0から1に変わったときにのみ影響を受けます。</p>\n"
    },
    "READ_KEYBOARD": {
      "title": "キーボード入力",
      "specification": "<p>キーボード入力をメモリに書き込むためのプログラムをアセンブリ言語で書いてください。</p>\n<p>キーボード入力はメモリアドレス<code>6000</code>にマッピングされています。</p>\n<p>最初に入力された文字をメモリアドレス<code>1000</code>（16進数）に、2番目に入力された文字を<code>1001</code>（16進数）に、その次に入力された文字を<code>1002</code>（16進数）に、というふうに書き込んでいってください。</p>\n<p>注意: 通常、キーは1クロックサイクルよりも長く押され続けますが、キーが放されるまでの間に一度だけ入力として認識されるようにしてください。</p>"
    },
    "ESCAPE": {
      "specification": "<p>コンピュータは火星の迷宮に閉じ込められています。迷宮から脱出させるプログラムを書いてください。</p>\n<p>コンピュータには車輪と前方障害物センサーが接続されています。車輪とセンサーへの入出力は、アドレス7FFFにメモリマップされています。</p>\n\n<p><b>周辺機器への出力信号:</b></p>\n<table class='data text'>\n<tr><th>ビット</th><th>1に設定すると</th></tr>\n<tr><td>2</td><td>前進（1ステップ）</td></tr>\n<tr><td>3</td><td>左に90度回転</td></tr>\n<tr><td>4</td><td>右に90度回転</td></tr>\n</table>\n\n<p>ビットが0から1に変わると、動作や回転が開始されますが、完了するまでに少し時間がかかります。</p>\n\n<p><b>周辺機器からの入力:</b></p>\n<table class='data text'>\n<tr><th>ビット</th><th>1のときの意味</th></tr>\n<tr><td>8</td><td>前方に障害物を検出</td></tr>\n<tr><td>9</td><td>デバイスが回転中</td></tr>\n<tr><td>10</td><td>デバイスが前進中</td></tr>\n</table>\n",
      "title": "迷宮からの脱出"
    },
    "ASSEMBLER_DISPLAY": {
      "specification": "<p>画面に好きなロゴを表示してください。</p>\n<p>ロゴのデザインは自由ですが、幅と高さがそれぞれ最低16ピクセル以上である必要があります。</p>\n<p>画面は512×256ピクセルのモノクロで、アドレス0x4000から0x6000までの範囲にメモリマップされています。各アドレスは画面上の16ピクセルに対応しています。画面の各行はメモリ内で連続しており、1行目は0x4000から始まり、2行目は0x4020から始まる、といったふうになっています。</p>\n",
      "title": "ディスプレイ"
    },
    "ASSEMBLER_NETWORK_RECEIVE": {
      "title": "ネットワーク",
      "specification": "<p>ネットワークを介して別のコンピュータからデータを受信し、画面に表示してください。</p>\n<p>ペイロードは幅16ピクセルの画像です。</p>\n<p>使用されるネットワークプロトコルの詳細については、ステージのヒントを参照してください。</p>\n<p>ネットワークのワイヤは、アドレス<code>6001</code>（16進数）にメモリマップされており、重要なビットが2つあります。<b>data</b>（第0ビット）はワイヤを介して送られてきたデータの現在のビットで、<b>sync</b>（第1ビット）は新しいビットが到着したときにそのことを示すために変化するビットです。</p>\n<p>注意: この課題はアセンブリ言語だけで解くのが難しいかもしれません。スタック操作のマクロを実装してからこのチャレンジに戻り、それを使ってコードを簡素化するのも一つの方法です。</p>\n",
      "elaboration": "ネットワークは情報をビットの列として送信します。銅線上では、一定レベル以上の電流があることによって1を表したり、電流がない（または一定の閾値以下である）ことによって0を表したりするかもしれません。（訳注：実際は電流よりも電圧が使われることが多い気がします。）光ファイバーでは、光信号が1を表し、光がないことが0を意味します。\n\n<h4>同期</h4>\n<p>ここで問題となるのは、1つのビットが終了し、新しいビットが開始されるタイミングをどう判断するかです。連続した2つの1は、単一の1が長く続いている場合と区別がつきません。したがって、ネットワークプロトコルには、ビットの終了を判断するためのタイミングメカニズムが必要です。</p>\n<p>よくある解決策は、全参加者が共有する合意されたネットワーククロックを使用することです。これには高い精度が必要で、一方がわずかに同期からずれるだけで、すべてのデータがごちゃごちゃになってしまいます。他の方法として、同期信号をネットワーク自体が運ぶ同期型ネットワークがあります。これにはより多くの帯域幅が必要ですが、ネットワーククロックを使うよりは簡単に実現できます。</p>\n<p>このミッションでは、2本のワイヤを使用した同期接続を使用します。1本のワイヤがデータを運び、もう1本が同期信号を運びます。同期信号が変化するたびに（0から1、または1から0）、新しいビットがデータワイヤから読み取れます。</p>\n<p>これには（データのワイヤだけを用意する方法に比べて）2倍の帯域幅が必要ですが、実装は簡単です。</p>\n\n<h4>メッセージ形式</h4>\n<p>次に、データ送信の開始と終了をどう判断するかという問題があります。仮に「0の信号」と「送信されていない」が同じであった場合、相手が0を送信しているのか、送信が終了したのかを知る方法がありませんね。そのため、このミッションで使用するプロトコルでは、送信は常に「1」のビットから始まり、その後に16ビットのデータが続き、その後に制御ビットが続きます。制御ビットが0の場合は送信が終了したことを意味し、制御ビットが1の場合はさらに16ビットのデータが続き、再び制御ビットが続くという仕組みです。</p>\n\n<h4>帯域幅</h4>\n<p>ネットワークのビットレートは、プロセッサが各ビットを受信して一つずつ処理しても間に合うぐらいの遅さにしておく必要があります。現実には、ネットワークのビットレートはプロセッサより<u>はるかに</u>遅くなっているのが普通です。</p>\n<p>このシミュレーションでは、ネットワークのビットレートはプロセッサのクロックレートの100倍遅いという設定になっています。つまり、ネットワークから1ビットが送られてくる間に、プログラムは100命令を実行できるものとしています。</p>\n"
    },
    "CMOS_NAND": {
      "title": "Nand（CMOS）",
      "splash": "最初のステージでは、電磁リレーを使用して<b>nand</b>ゲートを構築しました。現代のコンピュータはトランジスタで構築されているので、このステージではリレーの代わりにCMOSトランジスタを使ってnandゲートを作成します。",
      "specification": "<p>CMOSトランジスタを使用してNANDゲートを構築してください。</p>\n<p>CMOS回路では、トランジスタをスイッチとして用います。トランジスタには2種類あり、nmos（1が来ると接続するようになる）とpmos（1が来ると切断するようになる）があります。</p>\n<p><b>1</b>は電圧を、<b>0</b>はグランド（接地）を表します。</p>\n\n<p>切断状態のトランジスタの出力は、0でも1でもありません（<b>?</b>として表示されます）。したがって、どんな入力に対しても、回路の出力が何らかの経路で常に0または1の入力のいずれかと接続されているようにする必要があります。</p>\n<p>電圧（1）をグランド（0）に直接接続して回路をショートさせないように注意してください。</p>\n"
    },
    "CMOS_INV": {
      "title": "反転（CMOS）",
      "specification": "<p>CMOSトランジスタを使用してINVゲートを構築してください。</p>",
      "splash": "<p>私たちは、単一のNANDゲートを使用してインバータ（否定回路）を構築できることを既に知っています。</p>\n<p>ただし、これには4つのCMOSトランジスタが必要です。</p>\n<p>では、使うCMOSトランジスタの数をさらに減らしてインバータ（INV）を実装することは可能でしょうか？</p>"
    },
    "NOR": {
      "title": "NOR"
    },
    "XNOR": {
      "title": "XNOR"
    },
    "CMOS_NOR": {
      "specification": "NANDと同様に、NORも万能論理ゲートです。NORゲートだけを使用して、他のどんな論理ゲートでも構築することができます。",
      "title": "Nor（CMOS）"
    },
    "SHL": {
      "title": "左シフト",
      "specification": "<p>すべてのビットを左に1つずつシフトします。出力の最下位ビットは0に設定されます。入力の最上位ビットは破棄されます。</p>\n<p>これは2倍するのと同じです。</p>"
    },
    "SHR": {
      "title": "論理右シフト",
      "specification": "<p>すべてのビットを右に1つずつシフトします。出力の最上位ビットは0に設定されます。入力の最下位ビットは破棄されます。</p>\n<p>これは符号なしの数値に対して2で割るのと同じです。</p>\n"
    },
    "SAR": {
      "title": "算術右シフト",
      "specification": "<p>すべてのビットを右に1つずつシフトしますが、最上位ビットはそのままの値を保持します。入力の最下位ビットは破棄されます。</p>\n<p>これは符号付きの数値に対して2で割るのと同じです。</p>\n"
    },
    "MUL16": {
      "title": "掛け算",
      "specification": "2つの正の数を掛け算してください。オーバーフローしたビットは破棄されるものとします。",
      "elaboration": "これは難しい課題です。解決するためには、きっと複数のカスタムコンポーネントを作成する必要が出てくるでしょう。",
      "spoilers": [
        "掛け算は、複数回の加算として実装できます。",
        "ビットを左にシフトすることは、2倍するのと同じです。"
      ]
    },
    "MIN16": {
      "title": "最小値",
      "specification": "2つの16ビット数値のうち、より小さい方を出力してください。"
    },
    "MAX16": {
      "title": "最大値",
      "specification": "2つの16ビット数値のうち、より大きい方を出力してください。"
    },
    "SHL16": {
      "title": "左バレルシフト",
      "specification": "<p>16ビットの入力を0～15ビット分左にシフトしてください。</p>\n<p>シフトするビット数は、4ビットの入力<b>n</b>で指定されます。</p>"
    },
    "FLOAT_MUL_UNPACKED": {
      "splash": "<p>浮動小数点演算では、乗算は加算や減算よりも簡単です。</p>\n<p>そこで、まずは乗算から始めましょう。</p>\n<p>浮動小数点数の乗算は、仮数部を掛け合わせ、指数部を加算することで行います。</p>\n<p>2つの11ビットの仮数部を整数として掛け合わせると、21ビットまたは22ビットの仮数部が得られます。しかし、暗黙の小数点に対処するために、右端の10桁を捨てる必要があります。</p>\n<p>これは、浮動小数点演算において、結果の桁数（どの程度の大きさであるのか）は正しいけれども精度が失われることがある、という一例になっています。</p>\n",
      "title": "浮動小数点乗算",
      "specification": "<p>アンパックされた浮動小数点数を2つ掛け算してください。</p>\n<p>2つの入力について:</p>\n<p><b>sg</b> は符号（0=正、1=負）<br><b>exp</b> はバイアス付きの指数（バイアス値 = 15）<br><b>sf</b> は仮数で、11ビットの2進数</p>\n\n<p>出力は次のようにしてください。</p>\n<p><b>sg</b> は結果の符号です。普通の掛け算の規則に従ってください。<br><b>exp</b> は、指数の和からバイアス値を引いたものにしてください。<br><b>sf</b> は仮数の積で、11ビットまたは12ビットの数値としてください。（積の下位10ビットは切り捨てます）</p>\n\n<p><u>注: 11ビットの値を2つ掛け算した積は22ビットになるため、このレベルでは22ビットの乗算器（<b>mul</b>）および22ビットのスプリッタのコンポーネントが提供されます。</u></p>\n\n<p><u>注: 指数にバイアスをつけることで、ここでは単に複雑さが増しているだけのように見えますが、負の指数値を避けることができるおかげで、普段はロジックを簡素化してくれます。したがって、一般的には、これは設計上のトレードオフとして許容できると考えます。</u></p>\n"
    },
    "FLOAT_PACK": {
      "specification": "<p>符号、指数、および仮数を正規化し、16ビットの浮動小数点形式にパックしてください。</p>\n\n<p>パックされた形式では、<br>第15ビットが符号<br>第14ビット～第10ビットがバイアス付きの指数<br>第9ビット～第0ビットが、正規化された仮数から先頭の1を除いたもの<br>になります。</p>\n\n<h3>0</h3>\n<p>入力として与えられた正規化されていない仮数が0である場合、指数も0に設定してください。</p>\n\n<h3>オーバーフロー/アンダーフロー</h3>\n<p>正規化後の指数が0から31の範囲（つまり、5ビットで表現できる範囲）におさまっていない場合、その数値は無効となります。その場合には、指数部を31に設定してください。</p>",
      "title": "浮動小数点数をパックする"
    },
    "FLOAT_NORMALIZE_OVERFLOW": {
      "title": "オーバーフローを正規化する",
      "splash": "<p>2つの仮数を掛け合わせた結果は、11ビットまたは12ビットの2進数になりえます。12ビットの場合は、最下位ビットを切り捨てて11ビットに正規化し、指数を1増やします。</p>",
      "specification": "<p>入力される仮数（<b>sf</b>）は11ビットまたは12ビットのいずれかです。<p>12ビットの場合は、11ビットにシフトし、最下位ビットを切り捨て、指数を1増加させてください。</p>"
    },
    "FLOAT_NORMALIZE_UNDERFLOW": {
      "title": "アンダーフローを正規化する\n",
      "specification": "<p>入力された仮数（<b>sf</b>）の桁数が11ビット未満の場合、それを11ビットに変更し、指数をそれに応じて調整してください。</p>\n<p>入力がゼロでなく、最大で11ビットであることを前提とします。</p>"
    },
    "FLOAT_VERIFY_EXPONENT": {
      "title": "指数を検証する",
      "specification": "<p>指数（<b>exp</b>）が0～30の範囲（16進数で00～1e）からはみ出ている場合、指数を31（16進数で1f、2進数で11111）に設定してください。</p>"
    },
    "FLOAT_UNPACK": {
      "title": "浮動小数点数のアンパック",
      "specification": "<p>正規化された16ビットの浮動小数点数を符号、指数、仮数の3つの部分に分解してください。</p>\n<p><b>sgn</b>: 符号（0 = 正、1 = 負）<br><b>exp</b>: 指数<br><b>sf</b>: 仮数</p>\n\n<p>パックされた形式では、次のようになります。</p>\n<br>第15ビットが符号（0 = 正、1 = 負）\n<br>第14ビット～第10ビットが指数\n<br>第9ビット～第0ビットが正規化された仮数\n\n<p>「正規化された仮数」というのは、「指数が0でない限り、第9ビット～第0ビットの10ビット仮数の前には、暗黙の1が付くと仮定される」という意味です。アンパックされた形式では、この1を挿入して11ビットの仮数としてください。</p>",
      "splash": "<p>この後に続く追加ステージでは、浮動小数点演算を構築していきます。なお、これは高度な内容ですよ。</p>\n\n<p>浮動小数点数は、分数を表したり、整数より広い範囲の数値を表したりすることができます。これは、元となる数を拡大・縮小するための<b>指数部</b>を含めることにより実現されます。指数部は、ビットを左または右に移動することに対応します。（訳注：ビットが左右に動いていると考えてもよいですし、小数点が左右に動いていると考えてもよいです。）</p>\n<p>ここでは、10ビット分を仮数に、5ビット分を指数に、1ビット分を符号に割り当てて使う16ビットの浮動小数点形式を使用します。</p>\n<p>最初のミッションは、この16ビット形式を3つの要素にアンパックし、その後の操作を行えるようにすることです。</p>\n",
      "elaboration": "<h3>2進小数</h3> \n<p>以下の文章では、2進数の小数が使用されています。これは一般的にはあまり使われていない形式ですが、浮動小数点数がどのように機能するかを説明するためには便利です。</p> \n<p>小数点以下の桁の値は、1/2、1/4、1/8と続きます。<br><code>0.1</code><small>（2進数）</small>は10進数では1/2、つまり0.5に相当し、<br><code>0.01</code><small>（2進数）</small>は10進数では1/4、つまり0.25に相当し、<br>というふうに続きます。</p> \n\n<h3>指数</h3>\n<p>浮動小数点形式では、数を<b>仮数部</b>（桁が並んだもの）と<b>指数部</b>（小数点から見た桁の位置を示す）を組み合わせて表現します。</p>\n<p>例えば、<code>1</code>という桁に対して指数が0であるとき、それは単なる<code>1</code>です。<br><code>1</code>という桁に対して指数が1である場合、その数字は2進数で<code>10</code>（10進数で2）になります。<br>指数が-1である場合、その数字は2進数で<code>0.1</code>（10進数で0.5）になります。</p>\n<p>したがって、指数が1増えるごとに数字が2倍になり、1減るごとに数字が半分になります。つまり、指数が1増えると末尾に0が追加され（2倍に相当）、指数が1減ると小数点が左に移動します（半分に相当）。</p>\n<p>「浮動小数点」という用語は、小数点が仮数部の桁に対して相対的に移動できることを意味しています。</p>\n\n<h3>正規化</h3>\n<p>同じ数値が複数の方法で表現できることがあります。例えば、<code>10</code><small>（2進数）</small>に指数1がついたものは、<code>1</code><small>（2進数）</small>に指数2がついたものと、そして<code>0.1</code><small>（2進数）</small>に指数3がついたものと同じ数値を表します。</p>\n<p>これでは比較や計算をする上で不便なので、数値を<u>正規化</u>し、標準形式に統一します。正規化された形式では、先頭の1の後に小数点を置き、その後に残り全ての有効桁が続くようにします。</p>\n<p>さらに、この先頭の1は常に同じですから、明示的に保存する必要がなくなり、これにより1ビット分のストレージを節約できます。</p>\n\n<h3>指数のバイアス</h3>\n<p>負の指数を扱うのは不便なので、指数に15を加えて保存します。これを「指数に<u>バイアス</u>をつける」「<u>バイアス</u>を足す」と言います。</p>\n\n<h3>16ビット浮動小数点形式</h3>\n<p>簡単にするため、16ビットの浮動小数点形式を使用します。現代のプロセッサでは、より大きな形式、32ビット、64ビット、またはそれ以上が一般的で、これにより、圧倒的に広い範囲と良い精度を提供します。ただし、16ビットも32ビットも64ビットも基本的な概念は同じです。</p>\n\n<h3>精度とその限界</h3>\n<p>一部の数値は正確に表現できません。例えば、<br><code>1.1111111110</code><small>（2進数）</small>に指数12をつけたものは8188であり、<br><code>1.1111111111</code><small>（2進数）</small>に指数12をつけたものは8184です。</p>\n<p>その間の数値は、この浮動小数点形式では表現できません。したがって、8184に1を加えても、丸め（10進法でいう四捨五入）により8184のままになってしまいます。</p>\n<p>仮数部のビット数を増やせば精度は向上しますが、整数や小数が無限に存在するのに対して有限のビット数しかないため、精度が一部失われてしまうことは避けられないものなのです。</p>\n<p>意外に思われるかもしれませんが、一般的な10進数の分数の中には、浮動小数点で正確に表現できないものがあります。例えば、10進数で0.1（1/10）は浮動小数点で正確に表現できません。これは、0.1が無限に続く2進数展開を持つためです。（ちょうど1/3が10進数表記では正確に表現できないのと同じです。）</p>\n<p>このため、浮動小数点形式は通常、金銭データの計算には使用されません。10セント（訳注：つまり、0.1ドル）単位の金額というのは日常的に用いられるものですから、（訳注：アメリカ合衆国で、ドル単位で金銭を扱う上では）0.1を正確に表せないという精度限界は容認できないのです。とはいえ、2進数の浮動小数点は、ハードウェアで分数や実数を扱う上では圧倒的に最も一般的な方法となっています。</p>\n"
    },
    "FLOAT_MUL": {
      "title": "浮動小数点の掛け算",
      "specification": "パックされた16ビット浮動小数点数2つを掛け算してください。"
    },
    "FLOAT_ALIGN": {
      "title": "仮数を揃える",
      "specification": "<p>2つの数値の指数と仮数を調整して、同じ指数を持つようにしてください。</p>\n<p>共通の指数は、入力された指数のうち大きいほうにしてください。指数が小さい方の数値の指数を調整し、もう一つのほうの指数に合わせてもらいますが、その際、仮数の桁をいくつか切り捨てる必要があるかもしれません。</p>\n\n<p>出力:</p>\n<p><b>ex</b> 大きい方の指数</p>\n<p><b>asf</b> A入力の仮数で、共通の指数に調整されたもの</p>\n<p><b>bsf</b> B入力の仮数で、共通の指数に調整されたもの</p>"
    },
    "ADD_SIGNED_MAGNITUDE": {
      "title": "「符号と絶対値」表現の加減算",
      "specification": "<p>「符号と絶対値」表現で表された符号付き整数を加算または減算してください。</p>\n<p><b>sg</b> は符号を表します<br>（0 = 正、1 = 負）。<br><b>M</b> は符号を取り外したときの数値です。</p>\n<p>例えば、-2 は sg=1, M=2 で表されます。</p>\n<p><b>op</b> フラグにより、行うべき操作が指定されます。</p>\n<table class=truth>\n<tr><th>op</th><th>操作</th></tr>\n<tr><td>0</td><td>A + B</td></tr>\n<tr><td>1</td><td>A - B</td></tr>\n</table>"
    },
    "FLOAT_ADD": {
      "title": "浮動小数点数の加算",
      "specification": "<p>浮動小数点数を加算または減算してください。</p>\n<p><b>op</b> フラグにより、行うべき操作が指定されます。</p>\n<table class=truth>\n<tr><th>op</th><th>操作</th></tr>\n<tr><td>0</td><td>A + B</td></tr>\n<tr><td>1</td><td>A - B</td></tr>\n</table>"
    },
    "STACK_INIT": {
      "splash": "<p>そろそろお気づきかもしれませんが、レジスタが2つしかない状況でコードを書くのは非常に制約が多いものです。</p>\n<p>2つのレジスタがあれば 2 + 2 を計算することはできますが、2 - (3 - 2) のような計算を行うというだけでも既に大変です。途中の結果を保存する必要があるからです。</p>\n<p>そこで、<b>スタック</b>という、シンプルですが非常に強力なツールを導入します。</p>\n<p>ここでいうスタックとは、メモリの中の一領域で、最後に入れたものが最初に取り出される（LIFO: Last-In-First-Out）という形で中間の値を保存したり取り出したりできるものです。</p>\n<p>メモリの最初のアドレス、つまりアドレス0を使用して<b>スタックポインタ</b>（SP）を保存します。</p>\n<p>最初の演習では、スタックポインタを特定のメモリアドレスに初期化するコードを書いていきます。</p>\n<p>そして、これを<code>init.stack</code>という<b>マクロ</b>で書けるようにしておきます。マクロとは、簡単に再利用できるコードの断片のことです。以降、アセンブリ言語で<code>init.stack</code>というキーワードを使用すると、ここで書いたコードに置き換えられることにします。</p>",
      "specification": "<p>スタックポインタ（RAMアドレス0）を256（16進数で0100）に設定してください。</p>\n<p>SPという名前で値0を持つ定数を定義すると便利かもしれません。</p>",
      "title": "スタックの初期化"
    },
    "STACK_PUSH_D": {
      "specification": "<p>スタックに新しい値を保存する操作を<b>プッシュ</b>と呼びます。</p>\n<p><b>D</b>レジスタの現在の値をスタックの一番上にプッシュするコードを書いてください。</p>\n<p>その際、スタックポインタ（SP）は1増加させてください。</p>\n<p>なお、SPはスタックトップ（スタックの一番上）の次のアドレスを指すようにしてください。</p>",
      "title": "Dをプッシュ"
    },
    "STACK_POP_D": {
      "title": "Dへとポップ",
      "specification": "<p>スタックの一番上にある値を取得する操作を<b>ポップ</b>と呼びます。</p>\n<p>スタックの一番上にある値をポップして、それを<b>D</b>レジスタに書き込むコードを書いてください。</p>\n<p>値をポップするときには、スタックポインタ（SP）を1減少させてください。</p>\n<p>SPはスタックトップ（スタックの一番上）の次のアドレスを指すため、取得すべき値はSP - 1の位置にあります。</p>\n"
    },
    "STACK_POP_A": {
      "title": "Aへとポップ",
      "specification": "<p>スタックの一番上にある値をポップして、それを<b>A</b>レジスタに書き込むコードを書いてください。</p>\n<p><b>重要な条件</b>: この操作によって<b>D</b>レジスタが影響を受けないようにしてください。</p>"
    },
    "STACK_PUSH_VALUE": {
      "title": "値をプッシュ",
      "splash": "<p>ここで、新たに<u>プレースホルダ</u>を使用するマクロを導入します。</p>\n<p>今回のマクロは、キーワード<code>push.value</code>の後に数値を続けて指定する必要があります。例えば、<code>push.value 42</code>のようにするのです。</p>\n<p>マクロが使用されると、マクロコード内のプレースホルダキーワード<code>value</code>が、指定された数値、例えば<code>42</code>に置き換えられるものとします。</p>",
      "specification": "<p><code>value</code>をスタックにプッシュしてください。</p>\n<p><u>ヒント:</u> <code>value</code>の実際の値は、マクロが展開されるときになって初めてやってきて置き換えられるという性質のものですが、テスト時には「テストツール」のボックスから値を設定することもできます。（訳注：え、そんな機能ある？）</p>"
    },
    "STACK_ADD": {
      "title": "加算",
      "splash": "<p>スタックを使用することで、特定のレジスタに依存しない算術演算（加算、減算など）のマクロを書くことができます。この方法では、操作対象となる値をスタックからポップし、操作の結果を再びスタックにプッシュします。</p>\n<p>このアプローチにより、利用可能なレジスタの制約に縛られることなく、任意の複雑な計算を構築することが可能になります。</p>\n",
      "specification": "<p>スタックから2つの値をポップして加算し、その合計をスタックにプッシュしてください。</p>"
    },
    "STACK_SUB": {
      "title": "減算",
      "specification": "<p>スタックから2つの値をポップし、<b>2番目の値</b>から<b>最初の値</b>を引いて、その結果をスタックに戻してください。</p>"
    },
    "STACK_NEG": {
      "title": "符号反転",
      "specification": "<p>スタックの一番上にある値の符号を反転させてください。</p>\n<p>これは算術的な符号反転であるため、2の符号反転は-2になります。</p>"
    },
    "STACK_AND": {
      "title": "ビットAND",
      "specification": "<p>スタックから2つの値をポップし、ビットごとのAND演算を行い、その結果をスタックに戻してください。</p>"
    },
    "STACK_OR": {
      "title": "ビットOR",
      "specification": "<p>スタックから2つの値をポップし、ビットごとのOR演算を行い、その結果をスタックに戻してください。</p>"
    },
    "STACK_PUSH_MEMORY": {
      "title": "メモリをプッシュ",
      "specification": "<p>スタックの一番上にある値をメモリアドレスと見なします。</p>\n<p>そのアドレスをスタックからポップし、そのアドレスに入っている現在のメモリの内容を取得して、それをスタックにプッシュしてください。</p>\n"
    },
    "STACK_POP_MEMORY": {
      "specification": "<p>スタックから2つの値をポップします。2番目の値をメモリアドレスと見なします。</p>\n<p>最初の値を、指定されたアドレスに書き込んでください。</p>",
      "title": "メモリへとポップ"
    },
    "STACK_PUSH_STATIC": {
      "title": "固定のアドレスからプッシュ",
      "specification": "<p><code>address</code>プレースホルダで指定されたアドレスに入っている現在のメモリの内容を取得し、それをスタックにプッシュしてください。</p>"
    },
    "STACK_POP_STATIC": {
      "title": "固定のアドレスへとポップ",
      "specification": "<p>スタックの一番上にある値を取り出し、それを<code>address</code>プレースホルダで指定されたアドレスに保存してください。</p>"
    },
    "STACK_EQ": {
      "title": "イコール (eq)",
      "specification": "<p>スタックから2つの値をポップし、それらを比較してください。等しい場合は値-1（16進数で<code>FFFF</code>）をプッシュします。等しくない場合は<code>0</code>をプッシュします。</p>\n<p>条件分岐において、<code>FFFF</code>は<u>true</u>（真）、<code>0</code>は<u>false</u>（偽）を表すものとします。</p>"
    },
    "STACK_GT": {
      "title": "大なり (gt)",
      "specification": "<p>スタックから2つの値をポップし、それらを比較してください。最初の値が2番目の値より大きい場合は値-1（16進数で<code>FFFF</code>）をプッシュします。そうでない場合は<code>0</code>をプッシュします。</p>\n\n（訳注：gt は greater than「～より大きい」の略です。）"
    },
    "STACK_LT": {
      "title": "小なり (lt)",
      "specification": "<p>スタックから2つの値をポップし、それらを比較してください。最初の値が2番目の値より小さい場合は値-1（16進数で<code>FFFF</code>）をプッシュします。そうでない場合は<code>0</code>をプッシュします。</p>\n\n（訳注：lt は less than「～より小さい」の略です。）"
    },
    "STACK_NOT": {
      "title": "ビットNOT",
      "specification": "<p>スタックの一番上にある値を、ビット反転させてください。</p>"
    },
    "STACK_GOTO": {
      "title": "goto",
      "specification": "<p>プレースホルダで指定されたラベルにジャンプしてください。</p>"
    },
    "STACK_IF_GOTO": {
      "title": "if-goto",
      "specification": "<p>スタックの一番上にある値をポップしてください。</p>\n<p>その値がゼロでない場合、指定されたラベルにジャンプしてください。</p>"
    },
    "CALL": {
      "title": "関数呼び出し (call)",
      "splash": "<p><b>関数</b>は、ソフトウェアにおいておそらく最も重要な抽象化手法でしょう。</p>\n<p>関数とは、いくつかの入力（引数と呼ばれます）を受け取り、処理のためのローカルな記憶領域を持ち、値を返す、という機能を持ったひとかたまりのコードのことです。</p>\n<p>関数は、プログラムのどこからでも実行（呼び出し）することができます。関数が呼び出されると、その呼び出し元のアドレスがスタックに保存され、関数が完了すると、呼び出された場所に戻ります。</p>\n<p>引数やローカルな記憶領域もスタックに保存されます。</p>\n<p>関数を関数として機能させるためには、以下の3つの箇所が協調的に動作する必要があります。</p>\n<ul>\n<li>call: プログラムのどこかから関数を呼び出す場所</li>\n<li>function: 関数の開始地点</li>\n<li>return: 関数の終了地点</li>\n</ul>\n<p>関数へのデータの渡し方や関数からのデータの受け取り方について、共通の規約を設ける必要があります。そして、この規約を3つの箇所で共有し、それに従うことで、関数がきちんと動作するようになります。</p>\n",
      "specification": "<p><b>call</b>マクロは関数を呼び出します。呼び出しに備えてスタックを準備し、指定された関数のラベルにジャンプし、その後に状態を復元します。</p>\n<p>呼び出しの前に、0個以上の値がスタックに積まれています。プレースホルダ<b>argumentCount</b>は引数の数を表します。</p>\n<p>呼び出し規約では、3つの共有メモリスロットを必要とします。</p>\n<dl><dt>ARGS = 1</dt><dd>現在の関数に対する引数のアドレス</dd><dt>LOCALS = 2</dt><dd>関数用のローカルストレージのアドレス</dd><dt>RETVAL = 6</dt><dd>関数から返された値を一時的に保存するスロット。</dd></dl>\n<p>（これらのスロットアドレスは、便利なように共有定数として定義しておくことができます。）</p>\n<p>手順:</p>\n<ul>\n<li>現在のARGSの値をスタックにプッシュします。</li>\n<li>現在のLOCALSの値をスタックにプッシュします。</li>\n<li>関数のラベルにジャンプする命令の<b>直後</b>のアドレス（リターンアドレス）をスタックにプッシュします。</li>\n<li>新しいARGSアドレスを計算します。それは現在のSPから<b>argumentCount</b>と3を引いた値です（3というのは、今さっき3つの値をスタックにプッシュしたからです）。</li>\n<li><b>functionName</b>プレースホルダで指定されたアドレスにジャンプします。</li>\n</ul>\n<p>関数の呼び出しが実行された後、ジャンプ命令の直後にあるラベルに制御が戻ります。そうしたら、</p>\n<ul>\n<li>現在のARGSの値を一時スロットに保存します。</li>\n<li>スタックからLOCALSの値を復元します。</li>\n<li>スタックからARGSの値を復元します。</li>\n<li>SPを前のARGSの値に設定します。</li>\n<li>RETVALをスタックにプッシュします。</li>\n</ul>\n",
      "elaboration": "<p>関数が正しく動作するためには、3つの要素が協調的に動作する必要があります。関数の開始を定義する<code>function</code>、関数の終了を定義する<code>return</code>、そして関数を呼び出す<code>call</code>です。</p>\n<p>これらの3つは、関数内外でデータをどのように受け渡しするかについての共通の約束に従う必要があります。</p>\n<p>関数呼び出しがどのように実装されるかを規定する約束事を<b>呼び出し規約</b>といいます。</p>\n<p>プラットフォームやプログラミング言語に応じて、それぞれ多少異なる呼び出し規約がありますが、一般的にはすべてスタックを使用して関数呼び出しに特有の情報を保存します。関数呼び出しで使用されるスタックの部分を<b>スタックフレーム</b>と呼びます。</p>\n<p>スタックフレームには以下のものが含まれます。</p>\n<ul>\n<li>関数の実行を完了した後に戻るべきリターンアドレス</li>\n<li>関数に渡される引数</li>\n<li>関数内で使用されるローカル変数</li>\n<li>実行結果を表す戻り値</li>\n</ul>\n\n<h3>視覚的な例</h3>\n<p>2つの引数を取り、その積を返す関数「multiplication」を考えてみましょう。</p>\n<p>呼び出し元のコードが、スタックに2つの引数をプッシュし、<b>call</b>を実行します。</p>\n<div class=stacks>\n<div class=stack><div>6</div><div>7</div></div>\n<div class=stack><div>6</div><div>7</div><div>LOCALS</div><div>リターンアドレス</div></div>"
    },
    "FUNCTION": {
      "specification": "<p><b>Function</b>マクロは、関数ブロックの開始を定義します。ローカル変数を格納するためのスペースを確保するためにスタックを調整します。格納領域のサイズは、プレースホルダ<b>localsCount</b>で指定された値です。</p>\n<ul>\n<li>ブロックの先頭には、プレースホルダ<b>functionName</b>で指定された名前のラベルを置きます。</li>\n<li>現在のSPをLOCALSに設定します。</li>\n<li>現在の<b>SP</b>値に<b>localsCount</b>を加えることで、スタック上にローカルデータのためのスペースを確保します。</li>\n</ul>",
      "title": "関数"
    },
    "RETURN": {
      "specification": "<p><b>Return</b>マクロは、関数ブロックの終了を定義します。戻り値をメモリアドレスRETVALに格納し、スタックを元に戻します。</p>\n<ul>\n<li>スタックの一番上の値をポップし、それをRETVALメモリスロットに格納します。</li>\n<li>SPをLOCALSの値に設定します。</li>\n<li>スタックからリターンアドレスをポップし、そこにジャンプします。</li>\n</ul>\n",
      "title": "リターン"
    },
    "STACK_PUSH_ARG": {
      "title": "引数をプッシュ",
      "specification": "<p><code>ARGS</code> + <b>index</b>プレースホルダで指定されたメモリアドレスの現在の内容を取得し、それをスタックにプッシュしてください。</p>"
    },
    "STACK_POP_ARG": {
      "title": "引数へとポップ",
      "specification": "<p>スタックの一番上の値を取り、それを<code>ARGS</code> + <b>index</b>プレースホルダで指定されたメモリアドレスに格納してください。</p>"
    },
    "STACK_PUSH_LOCAL": {
      "title": "ローカル変数をプッシュ",
      "specification": "<p><code>LOCALS</code> + <b>index</b>プレースホルダで指定されたメモリアドレスの現在の内容を取得し、それをスタックにプッシュしてください。</p>"
    },
    "STACK_POP_LOCAL": {
      "title": "ローカル変数へとポップ",
      "specification": "<p>スタックの一番上の値を取り、それを<code>LOCALS</code> + <b>index</b>プレースホルダで指定されたメモリアドレスに格納してください。</p>"
    },
    "TOKENIZE_EXPRESSION": {
      "splash": "<p>これから高級プログラミング言語を構築していきます。高級言語は、人間にとって親しみやすく柔軟な構文を持ちます。それを機械語命令に<u>コンパイル</u>することで、機械で実行できるようにできるのです。例えば、高級言語のコード<code>2 + 2</code>は、低級コードにコンパイルされると以下のようになるかもしれません。</p>\n<pre class='code'>push.value 2<br>push.value 2<br>add<br></pre>\n<p>コンパイルには次の3つの段階があります。</p>\n<ol>\n<li>(1) トークン化（トークナイズ）</li>\n<li>(2) パース（構文解析）</li>\n<li>(3) コード生成</li>\n</ol>\n<p>最初のステップであるトークン化（トークナイズ）では、テキストを分割して、数値・キーワード・記号を表すかたまり（<u>トークン</u>と呼ばれます）の列へと変換します。</p>\n",
      "title": "トークナイズ",
      "specification": "<p>トークナイザは、数値と記号「+」を認識するように事前に設定されています。</p>\n<p>これに加えて、記号のマイナス「-」および括弧「(」と「)」も認識するようにトークナイザを設定してください。</p>\n<p>ソースコードエリアでコードを編集して、どのようにトークン化されるかをテストできます。</p>\n"
    },
    "GRAMMAR_EXPRESSION": {
      "specification": "<p>数値、括弧、および演算子<code>+</code>と<code>-</code>を含む式のための<b>文法</b>を定義してください。</p>\n<p>開始記号は<code>Expression</code>です。</p>\n<p>式は次のいずれかに対応するようにします。</p>\n<ul>\n<li><code>Number</code>トークン</li>\n<li><i>Expression</i> <code>+</code> <i>Expression</i></li>\n<li><i>Expression</i> <code>-</code> <i>Expression</i></li>\n<li><code>-</code> <i>Expression</i></li>\n<li><code>(</code> <i>Expression</i> <code>)</code></li>\n</ul>",
      "title": "文法",
      "splash": "<p>次にすべきことは、トークンの列を構文木にパースすることです。</p>",
      "elaboration": "<p>高級言語の構文は<b>文法</b>を通じて記述されます。</p>\n<p>文法とは、規則を集めたものです。それぞれの規則は、構文の部分部分に名前をつける役割を持ち、その名前がついた部分がどのように構成されるのかを定義します。</p>\n<p>例えば、「<code>2 + 2</code>」のような2つの数字の加算ができる非常にシンプルな言語の文法は、次のように定義できます。</p>\n<pre class='grammar'><code>Expression → Number + Number</code></pre>\n<p><code>Number</code>と<code>+</code>は、「トークン定義」の段階で定義されたトークンです。この構文では2つの数字の加算が許可されますが、<code>2 + 3 + 4</code>のように複数回の加算は許可しません。任意の数の加算をサポートするためには、規則の中で自分自身に言及するという方法を使います。</p>\n<pre class='grammar'><code>Program → Expression <br>Expression → Expression + Number <br>Expression → Number</code></pre>\n<p>この文法では、<code>+</code>の左側の<code>Expression</code>自体が加算である可能性があるため、無制限に加算が可能です。</p>\n\n<h3>用語</h3>\n<p>文法は「シンボル」という要素で構成されています。規則は、「矢印の左側にあるシンボル1つが、矢印の右側にある1つ以上のシンボルからどのように構成されるか」を定義します。矢印の右側に置くことができるのは、前のステップで定義された「トークンの仕様」で既に定義されているトークンか、または同じ文法内で他の規則によって定義されたシンボルです。</p>\n<p>トークンを表すシンボル（<code>Number</code>や<code>+</code>など）は<u>終端記号</u>と呼ばれ、文法内の他の規則によって定義されたプログラムや式のようなシンボルは<u>非終端記号</u>と呼ばれます。</p>\n<p>非終端記号として使用される名前は好きに選ぶことができ、自分にとって分かりやすくなるような名前を選んで使うことができます。ただし、全体のプログラムを表す「開始記号」として<code>Program</code>という名前が必要です。</p>\n\n<h3>構文解析アルゴリズム</h3>\n<p>このステージでは、「構文規則に基づいてソーステキストを処理し、構文木を生成する実際のパーサー」を書くわけではありません。パーサーアルゴリズムは計算機科学における一大分野であり、それを扱うとこのゲームの範囲を超えてしまいます。とはいえ、最も単純なパーサーである再帰下降パーサーは簡単に書くことができ、ほとんどの目的に十分です。パーサーを自分で書いてみたい場合は、再帰下降パーサーから始めてみるのがよいでしょう。</p>\n<p>このゲームではEarleyパーサーを使用しています。Earleyパーサーは最速ではありませんが、柔軟ですし、文法を記述するのも簡単です。</p>\n"
    },
    "CODEGEN_EXPRESSION": {
      "title": "コード生成",
      "splash": "<p>コンパイルの第3段階では、構文木から機械語を生成します。</p>\n<p>これは、各構文規則にアセンブリ言語のコード片をひもづけることで行われます。</p>\n<p>そうしたら、コンパイラは構文木を辿りながら各ノードに対応する規則に基づいてコードを生成していきます。</p>\n",
      "specification": "<p>加算と減算をサポートするために、この言語の構文規則に対するコード生成を定義してください。前のステージで定義されたスタック操作（ADDやSUBなど）を使用できます。</p>\n<p>コード生成テンプレートには、規則内の他のシンボルのコードを含める必要があることが多いです。これらは、シンボル名を角括弧で囲むことで挿入できます。</p>\n<p>例えば、次の規則</p>\n<pre class='grammar'>Expression → Expression + Number</pre>\n<p>には、次のようなコードテンプレートが使えるかもしれません:</p>\n<pre class='code'>[Expression]<br>push.value [Number]<br>add</pre>\n<p>[Number] のようなトークン名は実際のトークン値に置き換えられます。[Expression] のような非終端記号は、その規則に対応するテンプレートに置き換えられます（そして、そのまま再帰的に置き換えが進んでいきます）。</p>\n"
    },
    "CS_MODE": {
      "specification": "<p>モードコントローラーには、1ビットのモードレジスタが含まれています。</p>\n<ul>\n<li>モード = 0 は <u>カーネルモード</u> と呼ばれます</li>\n<li>モード = 1 は <u>ユーザーモード</u> と呼ばれます</li>\n</ul>\n\n<h3>入力</h3>\n<b>sw</b> 入力によってモードが変更されます。\n<p><b>tt</b> はタイマートリガー信号です。ユーザーモード時であればモードの変更を引き起こしますが、カーネルモード時には無視されます。</p>\n<p>ユーザーモード時にモードを変更することは<u>割り込み</u>と呼ばれます。</p>\n<p>カーネルモード時にモードを変更することは<u>復帰</u>と呼ばれます。</p>\n\n<h3>出力</h3>\n<p><b>sw</b> はモードが変更された場合に1になります（sw入力とtr入力のどちらによって引き起こされたかを問わない）。</p>\n<p><b>md</b>: 現在のモード</p>\n<p><b>IR</b>: 割り込みの原因を示す16ビットの数値です（sw=1のときにのみ意味を持ちます）。2進数で書くと、</p>\n<ul>\n<li><code>01</code> = タイマートリガー</li>\n<li><code>10</code> = スワップ</li>\n</ul>\n<p>です。</p>",
      "title": "モードコントローラー"
    },
    "CS_REGISTER": {
      "specification": "<p>16ビットレジスタ<b>R</b>があり、それにペアとなるバックアップレジスタ<b>Rb</b>が付随しています。出力はレジスタの現在の状態を反映します。</p>\n<p><b>st</b>=1の場合、<b>X</b>入力が<b>R</b>に保存されます。<b>st</b>=1かつ<b>sb</b>=1の場合は、<b>X</b>は代わりに<b>Rb</b>に保存されます。</p>\n\n<h3>割り込み</h3>\n<p><b>sw</b>=1かつ<b>md</b>=1のとき、<b>R</b>が<b>Rb</b>に保存され、<b>X0</b>入力が<b>R</b>に保存されます。</p>\n\n<h3>復帰</h3>\n<p><b>sw</b>=1かつ<b>md</b>=0のとき、レジスタが入れ替わります。つまり<b>R</b>の内容が<b>Rb</b>に保存され、<b>Rb</b>の内容が<b>R</b>に保存されます。</p>\n<p><b>sb</b>は、<b>sw</b>=1のときには影響を与えません。</p>\n\n<p><b>cl</b>はクロック信号です。</p>\n\n<p>入力フラグの組み合わせに応じて、何がどこに保存されるようになるのか]</p>\n<table class=truth>\n<colgroup class=input>\n<col span=4 />\n</colgroup>\n<colgroup class=input>\n<col span=2 />\n</colgroup>\n<tbody>\n<tr><th colspan=4>フラグ</th><th colspan=2>保存先</th></tr>\n<tr><th>st</th><th>sb</th><th>sw</th><th>md</th><th>R</th><th>Rb</th></tr>\n<tr><td>0</td><td>-</td><td>0</td><td>-</td><td>-</td><td>-</td></tr>\n<tr><td>1</td><td>0</td><td>0</td><td>-</td><td>X</td><td>-</td></tr>\n<tr><td>1</td><td>1</td><td>0</td><td>-</td><td>-</td><td>X</td></tr>\n<tr><td>0</td><td>-</td><td>1</td><td>0</td><td>Rb</td><td>R</td></tr>\n<tr><td>0</td><td>-</td><td>1</td><td>1</td><td>X0</td><td>R</td></tr>\n<tr><td>1</td><td>0</td><td>1</td><td>1</td><td>X0</td><td>X</td></tr>\n</tbody>\n</table>\n",
      "title": "バックアップ付きレジスタ"
    },
    "CS_PROGRAM_COUNTER": {
      "title": "プログラムカウンタ",
      "specification": "<p>バックアップ付きのレジスタ（<b>PC</b> と <b>PCb</b>）に、2つの機能が追加されています。</p>\n<p><b>st</b>=0の場合、PCがインクリメントされます。つまり、現在のPCに1を加えた値がPCに保存されます。</p>\n<p>割り込み時（<b>sw</b>=1かつ<b>md</b>=1のとき）、数値<code>0</code>がPCに保存されます。</p>"
    },
    "CS_REGISTER_BLOCK": {
      "title": "レジスタバンク",
      "specification": "<p>4つの16ビットレジスタ、A・D・M・PCが、それぞれバックアップレジスタと組み合わされています。</p>\n<p><b>a</b>=1: <b>X</b>をAに保存する <br><b>d</b>=1: <b>X</b>をDに保存する <br><b>m</b>=1: <b>X</b>をMに保存する <br><b>j</b>=1: <b>PC</b>入力をPCレジスタに保存する</p>\n<p><b>sb</b>=1の場合は、対応するバックアップレジスタに保存されます。</p>\n<h3>モード変更</h3>\n<p><b>md</b>は現在のモードです。<b>sw</b>はモード変更を表します。</p>\n<h3>割り込み</h3>\n<p><b>sw</b>=1かつ<b>mode</b>=1のとき、以下のように値がレジスタに保存されます。</p>\n<ul>\n<li>Ab が <b>A</b> に保存される</li>\n<li>IR入力が <b>D</b> に保存される</li>\n<li>数値<code>0</code>が <b>M</b> に保存される</li>\n</ul>"
    },
    "CS_TRIGGER": {
      "splash": "<h1>マルチタスク</h1>\n<p>これまでに構築したプロセッサは、一度に1つのプログラムしか実行できません。しかし、現代のプロセッサはマルチタスク、つまり複数のプログラム（プロセスと呼ばれます）を同時に実行することが可能です。このセクションでは、マルチタスクが可能なプロセッサを構築していきます。</p>\n<p>マルチタスクは、プロセッサが異なるプロセスを順番に切り替え、それぞれを短時間ずつ実行することで達成されます。切り替えが十分に速く行われれば、複数のプログラムが同時に実行されているように感じられます。</p>\n<p>マルチタスクには、<u>メモリ安全性</u>と<u>プロセスの分離</u>が必要です。1つのプロセスがプロセッサ全体を占有して他のプロセスの実行を妨げることがあってはならず、また、1つのプロセスが他のプロセスに属するデータやコードを読み取ったり変更したりすることがあってはなりません。</p>\n<p>これらを実現するために、以下の要素が必要です。</p>\n<ul>\n<li>1つのプロセスがアクセスできるメモリ領域を区切る方法。</li>\n<li>メモリを管理し、プロセス間の切り替えを制御する監督プロセス。このプロセスを<u>カーネル</u>または<u>オペレーティングシステム</u>と呼びます。</li>\n<li>実行中のプロセスを定期的に割り込み、カーネルプロセスに制御を切り替えるためのタイマー。一旦カーネルプロセスに制御が切り替わってくれれば、今度はカーネルが他のプロセスを続行させることができます。このタイマーイベントは<u>コンテキストスイッチ</u>と呼ばれます。</li>\n<li>実行中のプロセスの状態を保存し、後で復元できるようにする方法。</li>\n<li>通常のプロセスが持たない、「メモリ操作に関する特権」をカーネルプロセスに与える方法。</li>\n<li>状態を保存・復元し、メモリ保護を設定する操作（命令セットを拡張し、このような操作を追加する必要があります。）</li>\n</ul>",
      "title": "タイマートリガー",
      "specification": "<p><b>tr</b>は256クロックサイクルごとに1を出力するようにしてください。</p> \n<p><b>cl</b>はクロック信号です。</p>"
    },
    "CS_GENERAL_MEMORY": {
      "title": "汎用メモリ",
      "splash": "<p>最初のプロセッサでは、命令メモリ（ROM）とデータメモリ（RAM）が完全に分離されていました。これはシンプルな設計ですが、これでは新しいプログラムのインストールや既存プログラムの更新が一切できません。この制約を解消するためには、「命令メモリとデータメモリの両方の用途に使うことができ、読み取りも書き込みもできる」というメモリを用意することが必要です。</p>\n<p>まずは、4つのセルだけを持つメモリブロックから始めますが、同じ設計で簡単にアドレス範囲を拡張することができます。</p>\n",
      "specification": "<p>1つのアドレスに対して読み取り/書き込みアクセスを行い、それと同時に別のアドレスに対して読み取りアクセスを行うことができるメモリ</p>\n<p>このメモリ内には、4つの16ビットレジスタが含まれており、2ビットのアドレスでアクセスします。</p>\n<p><b>a1</b>と<b>a0</b>は合わせてAアドレスを表します。出力<b>*A</b>は、Aアドレスに格納されている値です。<b>st</b>=1の場合、<b>X</b>入力がAアドレスに格納されます。</p>\n<p>出力<b>I</b>は、<b>pc0</b>と<b>pc1</b>で指定されたPCアドレスに格納されている値です。</p>\n<p><b>cl</b>はクロック信号です。</p>\n"
    },
    "CS_MAPPED_MEMORY": {
      "title": "仮想メモリ",
      "splash": "<p>各プロセスに対して、他のプロセスから読み取られたり上書きされたりしない専用のメモリ領域を割り当てる必要があります。また、2つのプロセス間でメモリを共有できるようにする機能も必要です。</p>\n<p>これを解決するために、8つのメモリセグメント（各々64KB）を作成し、セグメントをアクティブなプロセスに割り当てます。アクティブなプロセスが16ビットのメモリアドレスにアクセスする際に、セグメントの設定に応じて、そのアドレスに適したセグメントを選択します。</p>\n<p>柔軟性を持たせるため、低アドレスと高アドレスで異なるセグメント設定を使用できるようにし、これらが異なるセグメントに配置されるようにします。また、命令メモリとデータメモリに対しても異なるセグメント設定を使用するようにします。</p>\n",
      "specification": "<p>16ビットのアドレス A および PC に対して、M からの 3 ビットを前置することで 18 ビットのアドレスに拡張していきます。（訳注：16 と 3 を足したら 18 ではなく19になりますが、そのことについては後で説明があります。）入力アドレスの第15ビットに応じて、（セグメントのうちの）どの 3 ビットブロックが使用されるかが決定されます。</p>\n<table class=truth><colgroup span=2 class=input></colgroup><colgroup span=2  class=input></colgroup> \n<tr><th>入力</th><th>第15ビット</th><th>セグメント</th><th>読み取り専用フラグ</th></tr>   \n<tr><td>PC</td><td>0</td><td>ビット 0-2</td><td>-</td></tr>  \n<tr><td>PC</td><td>1</td><td>ビット 4-6</td><td>-</td></tr>  \n<tr><td>A</td><td>0</td><td>ビット 8-10</td><td>ビット 11</td></tr>  \n<tr><td>A</td><td>1</td><td>ビット 12-14</td><td>ビット 15</td></tr>  \n</table>\n\n<p>入力アドレスの最上位ビットは破棄され、代わりに選択された 3 ビットが前置され、18 ビットのアドレスが生成されます。</p>\n<p>「読み取り専用フラグ」（A アドレスにのみ適用）は、データを格納できるかどうかを決定します。0 の場合、<b>st</b> フラグを使用して通常通りにデータを格納できます。1 の場合、<b>st</b> フラグは無視されます。</p>\n"
    },
    "CS_CONTROL_UNIT": {
      "specification": "<p><b>I</b>入力をデコードして命令に変換します。</p>\n<p>第15ビットと第14ビットにより、どのような命令であるかを規定します。</p>\n<table class=data>\n<tr><th>第15ビット</th><th>第14ビット</th><th>命令の種類</th></tr>\n<tr><td>0</td><td>-</td><td>データ命令</td></tr>\n<tr><td>1</td><td>1</td><td>ALU命令</td></tr>\n<tr><td>1</td><td>0</td><td>以下を参照</td></tr>\n</table>\n\n<table class=data>\n<tr><th>ビット</th><th>グループ</th><th>フラグ</th></tr>\n<tr><td>13</td><td></td><td>スワップ</td></tr>\n<tr><td>12～9</td><td>未使用</td><td>-</td></tr>\n<tr><td>8</td><td rowspan=3>入力元<br>レジスタ<br>選択</td><td>s1</td></tr>\n<tr><td>7</td><td>s0</td></tr>\n<tr><td>6</td><td>sb</td></tr>\n<tr><td>5</td><td rowspan=6>出力先<br>レジスタ<br>選択</td><td>a</td></tr>\n<tr><td>4</td><td>d</td></tr>\n<tr><td>3</td><td>*a</td></tr>\n<tr><td>2</td><td>m</td></tr>\n<tr><td>1</td><td>j</td></tr>\n<tr><td>0</td><td>b</td></tr>\n</table>\n\n<p>フラグs1、s0、sbは、レジスタを選択する役割を持ちます。</p>\n<table class=data>\n<colgroup>\n<col />\n<col span=2 />\n</colgroup>\n<tbody>\n<tr><th colspan=2>フラグ</th><th>レジスタ</th></tr>\n<tr><th>s1</th><th>s0</th><th></th></tr>\n<tr><td>0</td><td>0</td><td>A</td></tr>\n<tr><td>0</td><td>1</td><td>D</td></tr>\n<tr><td>1</td><td>0</td><td>M</td></tr>\n<tr><td>1</td><td>1</td><td>PC</td></tr>\n</tbody>\n</table>\n\n<p><b>sb</b>=1の場合、バックアップレジスタが選択されます。</p>\n",
      "title": "制御装置"
    },
    "CS_COMBINE": {
      "specification": "<p>コンポーネントを接続して、マルチタスクをサポートするプロセッサを作成してください。</p>",
      "title": "プロセッサ"
    }
  },
  "ui": {
    "donate": "寄付する",
    "about": "このサイトについて",
    "custom_components": "カスタムコンポーネント",
    "btn_reset_state": "状態をリセット",
    "btn_clear_levels": "全てのステージの進捗を削除",
    "btn_skip_level": "このステージを飛ばす",
    "btn_next_level": "次のステージ",
    "btn_ok": "OK",
    "btn_close": "閉じる",
    "stay": "このステージに留まる",
    "click_to_reveal": "(クリックして表示)",
    "about_translation": "翻訳文に修正すべき箇所を見つけた方は、お手数ですが <a href=\"https://github.com/hsjoihs/nandgame-translate-ja/issues/new\">https://github.com/hsjoihs/nandgame-translate-ja</a> までご報告ください。",
    "btn_level_complete": "解答をチェック",
    "level_help": "ステージのヒント",
    "solve_level": "ステージを解く",
    "level_complete": "ステージクリア！",
    "confirm_clear_levels": "全進捗が消えることになります。全てのステージの解答を削除して本当に最初からやり直しますか？",
    "btn_clear_canvas": "盤面をリセット",
    "level_error_header": "正しくありません。",
    "level_error": "現状の解答は仕様を満たしていません。",
    "custom_components_start": "カスタムコンポーネントは、自由に設計できます。特定のステージを解くための部品として使用することもできますし、単に楽しんで試行錯誤するために使っても構いません。",
    "component_error_output_unstable": "コンポーネントが安定状態に落ち着きませんでした。出力が1と0の間で振動しています。",
    "component_error_short_curcuit": "グラウンド（0）をV（1）に直接接続したため、回路の短絡が発生しました。",
    "assembler_quick_reference": "<p><b>アセンブリ言語の早見表</b></p>\n\n<p>\n<code><u>書き込み先</u> = <u>計算</u> ; <u>ジャンプ条件</u></code> という構文からなり、書き込み先とジャンプ条件は省略可能です。（訳注：書き込み先を省略したときには、その直後の <code>=</code> も省略します。ジャンプ条件を省略するときは、その直前の <code>;</code> も省略します。）\n</p>\n\n<p>\n    <code>D</code> と <code>A</code> はレジスタを表します。\n    <code>*A</code> は <code>A</code> レジスタに格納されているアドレスにある RAM の値を示します。\n</p>\n\n<b>例:</b>\n\n<table>\n    <tbody>\n        <tr>\n            <td>\n                <code>D = D + 1</code>\n            </td>\n            <td>\n                D + 1 を計算し、その結果を D に格納します。\n            </td>\n        </tr>\n        <tr>\n            <td>\n                <code>D - 1 ; JGE</code>\n            </td>\n            <td>D - 1 を計算し、結果が 0 より大きい場合にジャンプします。（計算結果はどこにも格納されません。）</td>\n        </tr>\n        <tr>\n            <td>\n                <code>A = 1234</code>\n            </td>\n            <td>A レジスタに数値 1234 を格納します。</td>\n        </tr>\n        <tr>\n            <td>\n                <code># Hello</code>\n            </td>\n            <td>コメントであり、アセンブラによって無視されます。</td>\n        </tr>\n    </tbody>\n</table>\n\n<b>計算:</b>\n<table>\n    <tbody>\n        <tr>\n            <td>\n                <code>D + A</code>\n            </td>\n        </tr>\n        <tr>\n            <td>\n                <code>D - A</code> または <code>A - D</code>\n            </td>\n        </tr>\n        <tr>\n            <td>\n                <code>D &amp; A</code>\n            </td>\n            <td>(ビットごとの AND)</td>\n        </tr>\n        <tr>\n            <td>\n                <code>D | A</code>\n            </td>\n            <td>(ビットごとの OR)</td>\n        </tr>\n        <tr>\n            <td>\n                <code>A+1</code> または <code>D+1</code>\n            </td>\n        </tr>\n        <tr>\n            <td>\n                <code>A-1</code> または <code>D-1</code>\n            </td>\n        </tr>\n        <tr>\n            <td>\n                <code>-A</code> または <code>-D</code>\n            </td>\n        </tr>\n        <tr>\n            <td>\n                <code>~A</code> または <code>~D</code>\n            </td>\n            <td>(ビットごとの反転)</td>\n        </tr>\n        <tr>\n            <td>\n                <code>1</code> または <code>0</code> または <code>-1</code>\n            </td>\n        </tr>\n    </tbody>\n</table>\n\n<p>\n    <code>A</code> が出てくるものについては、すべて <code>*A</code> に置き換えることもできます。\n</p>\n\n<b>書き込み先:</b>\n<p>\n    <code>D</code>、<code>A</code>、<code>*A</code>の任意の組み合わせを書き込み先として使用できます。書き込み先が複数あるときはカンマで区切ります。例: <code>D, A = 1</code>\n</p>\n\n<b>ジャンプ条件:</b>\n<table>\n    <tbody>\n        <tr>\n            <td></td>\n            <td>計算結果が以下の条件を満たす場合にジャンプします。</td>\n        </tr>\n        <tr>\n            <td>\n                <code>JEQ</code>\n            </td>\n            <td>0 と等しい場合</td>\n        </tr>\n        <tr>\n            <td>\n                <code>JNE</code>\n            </td>\n            <td>0 と等しくない場合</td>\n        </tr>\n        <tr>\n            <td>\n                <code>JGT</code>\n            </td>\n            <td>0 より大きい場合</td>\n        </tr>\n        <tr>\n            <td>\n                <code>JGE</code>\n            </td>\n            <td>0 以上の場合</td>\n        </tr>\n        <tr>\n            <td>\n                <code>JLT</code>\n            </td>\n            <td>0 より小さい場合</td>\n        </tr>\n        <tr>\n            <td>\n                <code>JLE</code>\n            </td>\n            <td>0 以下の場合</td>\n        </tr>\n        <tr>\n            <td>\n                <code>JMP</code>\n            </td>\n            <td>（計算結果によらず）無条件ジャンプ</td>\n        </tr>\n    </tbody>\n</table>\n\n<b>数値命令:</b>\n<p>\n    <code>A</code> には数値を直接代入できます。例: <code>A = 47</code>。\n    <br />\n    16進数の数値には <code>0x</code> を付けます。例: <code>A = 0x7FFF</code>\n    <br />\n    2進数の数値には <code>0b</code> を付けます。例: <code>A = 0b010111</code>。桁区切りの文字としてアンダースコアを使用できます。例: <code>A = 0b_0101_1100</code>。\n</p>\n\n<p></p>\n\n<b>コメント:</b>\n<p>\n    <code>#</code> で始まる行はアセンブラによって無視されます。コメントを書き、コードに関する説明をするために使用できます。\n</p>\n\n<b>ラベル:</b>\n<p>\n    <code>LABEL</code> キーワードに続けて名前を指定すると、その名前は直後の命令のアドレスを表すものになります。そうして名付けたアドレスを、ジャンプする前に <code>A</code> に代入しておくとよいでしょう。例: <code>A = LOOP</code>\n</p>\n\n<b>定義:</b>\n<p>\n    <code>DEFINE</code> キーワードに続けて名前と数値を指定すると、その名前が他の命令で使用される際に、指定した数値に置き換えられます。\n    たとえば、\n\n    <br /><code>DEFINE foo 0x7FFF</code>\n        <br /><code>A = foo</code>\n\n    <br />というコードは、\n    <code> A = 0x7FFF</code>\n    <br />という命令と等価です。\n</p>\n\n<b>複数の書き込み先</b>\n<p>結果を複数のレジスタに代入することが可能です。</p>\n<p>例: <code>D, A = D - *A</code> 計算結果が A と D の両方に書き込まれます。</p>\n<p>書き込み先としては、A、D、*A の任意の組み合わせを指定できます。</p>"
  },
  "texts": {
    "translation_credits": "翻訳: hsjoihs (<a href=\"https://github.com/hsjoihs\">GitHub: hsjoihs</a>, <a href=\"https://twitter.com/hsjoihs\">Twitter (X): @hsjoihs</a>)",
    "diagram_help": "<p>すべてのコンポーネントは、どの入力がどの出力につながるかという仕様に基づいて定義されています。\n コンポーネントの具体的な構築方法はあなた次第です。入力/出力が仕様に準拠していれば、シンプルさや効率性は問われません。\n 重要なのは正しく動作するかどうかです。<p>コンポーネントの仕様を確認するには、🛈アイコンをクリックしてください。\n\n <h3>ユーザーガイド</h3>\n\n <p>ステージの目的は、キャンバスの左側にあるボックスに必ず記載されています。\n キャンバスの下にあるテキスト（今読んでいるもの）は、追加情報やヒントが含まれています。\n\n <p>キャンバス左のツールボックスからコンポーネントをドラッグしてキャンバスに配置し、端子の三角形の部分をドラッグして丸いところに繋げることによって回路を作成します。\n\n <p>入力ボックス（小さなチェックボックス）を切り替えて、回路を手動でテストすることができます。\n\n <p>コンポーネントが正しく設計できたと思ったら、「解答をチェック」をクリックしてください。\n システムが設計した回路が仕様に一致しているか確認し、一致していれば次のステージに進むことができます。\n\n <div class=subject>\n <h3>0と1について</h3>\n <p>入力および出力信号は、0か1のどちらかです。\n 他の選択肢や中間状態はありません。これは、「二つの異なる状態のみを区別する」というデジタルシステムの基本原理を反映しています。\n 電気回路では、これは高電流と低電流に相当しますが、我々は物理的なレベルでの動作には目を向けず、単に「0か1か」というところにのみ着目することとします。\n </div>\n\n <div class=subject>\n <h3>NANDゲートはどこからやってくるの？</h3>\n <p>このゲームでは、<b>nand</b>ゲートを最も基本的な構成要素として使用しています。nandゲート自体はトランジスタから構成されます。トランジスタというのは、要するに、電気的なスイッチのことです。\n nandゲートは、使用するトランジスタの種類に応じて、2つまたは4つのトランジスタで構成されます。\n </div>\n"
  },
  "components": {
    "NAND": {
      "name": "nand",
      "help": "<b>Nand</b>ゲート。両方の入力が1のときにのみ、出力が0になります。\n<table class='truth'>\n<tr><th colspan=2>入力</th><th>出力</th></tr>\n<tr><th>a</th><th>b</th><th></th></tr>\n<tr><td>0</td><td>0</td><td>1</td></tr>\n<tr><td>1</td><td>0</td><td>1</td></tr>\n<tr><td>0</td><td>1</td><td>1</td></tr>\n<tr><td>1</td><td>1</td><td>0</td></tr>\n</table>"
    },
    "INV": {
      "name": "inv",
      "help": "<b>inv</b>ゲート。入力を反転させます。\n<table class='truth'>\n<tr><th>入力</th><th>出力</th></tr>\n<tr><td>0</td><td>1</td></tr>\n<tr><td>1</td><td>0</td></tr>\n</table>"
    },
    "AND": {
      "name": "and",
      "help": "<b>and</b>ゲート。両方の入力が1の場合にのみ、出力が1になります。\n<table class='truth'>\n<tr><th colspan=2>入力</th><th>出力</th></tr>\n<tr><th>a</th><th>b</th><th></th></tr>\n<tr><td>0</td><td>0</td><td>0</td></tr>\n<tr><td>1</td><td>0</td><td>0</td></tr>\n<tr><td>0</td><td>1</td><td>0</td></tr>\n<tr><td>1</td><td>1</td><td>1</td></tr>\n</table>"
    },
    "OR": {
      "name": "or",
      "help": "<b>or</b>ゲート。少なくとも1つの入力が1の場合、出力が1になります。\n<table class='truth'>\n<tr><th colspan=2>入力</th><th>出力</th></tr>\n<tr><th>a</th><th>b</th><th></th></tr>\n<tr><td>0</td><td>0</td><td>0</td></tr>\n<tr><td>1</td><td>0</td><td>1</td></tr>\n<tr><td>0</td><td>1</td><td>1</td></tr>\n<tr><td>1</td><td>1</td><td>1</td></tr>\n</table>"
    },
    "RELAY-ON": {
      "help": "電磁リレー。通常は<b>in</b>から出力に接続されていますが、<b>c</b>に電流が流れると接続が切れます。\n"
    },
    "RELAY-OFF": {
      "help": "電磁リレー。<b>c</b>に電流が流れると、<b>in</b>から出力に接続されます。"
    },
    "XOR": {
      "name": "xor",
      "help": "<b>xor</b>ゲート。2つの入力が異なる場合、出力が1になります。\n <table class='truth'>\n <tr><th colspan=2>入力</th><th>出力</th></tr>\n <tr><th>a</th><th>b</th><th></th></tr>\n <tr><td>0</td><td>0</td><td>0</td></tr>\n <tr><td>1</td><td>0</td><td>1</td></tr>\n <tr><td>0</td><td>1</td><td>1</td></tr>\n <tr><td>1</td><td>1</td><td>0</td></tr>\n </table>"
    },
    "INV16": {
      "name": "inv 16",
      "help": "16ビット<b>inv</b>ゲート。各ビットを反転させます。\n <table class='truth'>\n <tr><th>入力</th><th>出力</th></tr>\n <tr><td>0</td><td>1</td></tr>\n <tr><td>1</td><td>0</td></tr>\n </table>"
    },
    "AND16": {
      "name": "and 16",
      "help": "16ビット<b>and</b>ゲート。2つの16ビット値のそれぞれの桁に対して、同じ桁のペアごとに<b>and</b>を実行します。\n <table class='truth'>\n <tr><th colspan=2>入力</th><th>出力</th></tr>\n <tr><th>A</th><th>B</th><th></th></tr>\n <tr><td>0</td><td>0</td><td>0</td></tr>\n <tr><td>1</td><td>0</td><td>0</td></tr>\n <tr><td>0</td><td>1</td><td>0</td></tr>\n <tr><td>1</td><td>1</td><td>1</td></tr>\n </table>"
    },
    "HALFADD": {
      "name": "add",
      "help": "半加算器。1ビットの数値を2つ足し算します。\n\n <table class='truth'>\n <tr><th colspan=2>入力</th><th colspan=2>出力</th></tr>\n <tr><th>a</th><th>b</th><th>h</th><th>l</th></tr>\n <tr><td>0</td><td>0</td><td>0</td><td>0</td></tr>\n <tr><td>1</td><td>0</td><td>0</td><td>1</td></tr>\n <tr><td>0</td><td>1</td><td>0</td><td>1</td></tr>\n <tr><td>1</td><td>1</td><td>1</td><td>0</td></tr>\n </table>"
    },
    "ADDC": {
      "name": "add",
      "help": "全加算器。1ビットの数値を3つ足し算します。\n <table class='truth'>\n <tr><th colspan=3>入力</th><th colspan=2>出力</th></tr>\n <tr><th>a</th><th>b</th><th>c</th><th>h</th><th>l</th></tr>\n <tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>\n <tr><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td></tr>\n <tr><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td></tr>\n <tr><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td></tr>\n <tr><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td></tr>\n <tr><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td></tr>\n <tr><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td></tr>\n <tr><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr>\n </table>\n"
    },
    "ADD16": {
      "name": "add 16",
      "help": "<b>16ビット加算</b> 2つの16ビット数を加算します。\n オーバーフローは無視されるため、結果が65536を超えると「一周して」ゼロに戻ります。"
    },
    "ADDC16": {
      "name": "add 16",
      "help": "<b>16ビット加算</b> 2つの16ビット数と1ビットのキャリーを加算します。\n 16ビットの出力<b>S</b>は、合計を表します。出力<b>c</b>は、合計が16ビットを超えた場合のキャリーです。"
    },
    "INC16": {
      "name": "inc 16",
      "help": "<b>インクリメント</b>\n <p>16ビットの値に<b>1</b>を加算します。</p>"
    },
    "SUB16": {
      "name": "sub 16",
      "help": "<b>16ビット減算</b> ある16ビット数から別の16ビット数を減算します。\n <p>結果が負の場合、2の補数表現で表されます。</p>"
    },
    "ZERO": {
      "name": "0",
      "help": "定数<b>0</b>です。"
    },
    "ZERO16": {
      "help": "定数<b>0</b>です。",
      "name": "0"
    },
    "ISZERO": {
      "name": "is zero",
      "help": "入力された16ビットの数が0の場合、1を出力します。"
    },
    "ISNEG": {
      "name": "is neg",
      "help": "入力された16ビットの数が負の場合、1を出力します。\n<p>負の数は2の補数表現で表されるため、第15ビットが1になります。</p>"
    },
    "SPLIT16": {
      "name": "スプリッタ",
      "help": "<b>スプリッタ</b> 16ビットのバスを16個の個別の端子に分割します。"
    },
    "BUNDLE16": {
      "name": "バンドラ",
      "help": "<b>バンドラ</b> 16個の個別の端子を16ビットのバスにまとめます。"
    },
    "SELECT": {
      "name": "select",
      "help": "<b>セレクト</b>コンポーネントは、2つの入力ビットのうちの片方を出力として選択します。\n<table class='truth'>\n<tr><th>入力</th><th>出力</th></tr>\n<tr><th>s</th><th></th></tr>\n<tr><td>0</td><td>d0</td></tr>\n<tr><td>1</td><td>d1</td></tr>\n</table>\n"
    },
    "DECODER": {
      "name": "decoder",
      "help": "<b>デコーダ</b>は、制御ビットに基づいて1つの出力チャネルを1に設定します。\n<table class='truth'>\n<tr><th>入力</th><th colspan=2>出力</th></tr>\n<tr><th></th><th>c1</th><th>c0</th></tr>\n<tr><td>0</td><td>0</td><td>1</td></tr>\n<tr><td>1</td><td>1</td><td>0</td></tr>\n</table>"
    },
    "SELECT16": {
      "name": "select 16",
      "help": "<b>セレクタ</b>。アドレスビットに基づいて2つの16ビット入力チャネルのうち1つを選択します。\n<table class='truth'>\n<tr><th>入力</th><th>出力</th></tr>\n<tr><th>s</th><th></th></tr>\n<tr><td>0</td><td>D0</td></tr>\n<tr><td>1</td><td>D1</td></tr>\n</table>"
    },
    "DEMUX": {
      "name": "switch",
      "help": "<b>スイッチ</b>。データビットを2つの出力チャネルのうち1つに送ります。\n<table class='truth'>\n<tr><th colspan=2>入力</th><th colspan=2>出力</th></tr>\n<tr><th>s</th><th>d</th><th>c1</th><th>c0</th></tr>\n<tr><td>0</td><td>0</td><td>0</td><td>0</td></tr>\n<tr><td>0</td><td>1</td><td>0</td><td>1</td></tr>\n<tr><td>1</td><td>0</td><td>0</td><td>0</td></tr>\n<tr><td>1</td><td>1</td><td>1</td><td>0</td></tr>\n</table>"
    },
    "ALU_PRESET": {
      "name": "unary alu",
      "help": "<b>単項ALU</b>は、フラグに基づいて入力値<b>X</b>を変更します。\n\n<b>z</b>（ゼロ）が1であれば、入力の代わりに0が使用されます。\n<b>n</b>（反転）が1であれば、入力がビット反転されます。\n\n<table class='truth'>\n<tr><th colspan=2>入力</th><th>出力</th></tr>\n<tr><th>z</th><th>n</th><th></th></tr>\n<tr><td>0</td><td>0</td><td>X</td></tr>\n<tr><td>1</td><td>0</td><td>0</td></tr>\n<tr><td>0</td><td>1</td><td>Xを反転</td></tr>\n<tr><td>1</td><td>1</td><td>0を反転</td></tr>\n</table>\n"
    },
    "ALU": {
      "name": "alu",
      "help": "算術論理演算装置（ALU）。2つの入力<b>X</b>と<b>Y</b>に対して算術または論理演算を行います。\n6ビットの<b>op</b>（操作コード）フラグにより、どの操作を行うかを選択できます。"
    },
    "CONDITION": {
      "name": "condition",
      "help": "入力<b>X</b>が<b>cd</b>フラグで指定された条件を満たす場合、1を出力します。"
    },
    "SR_LATCH": {
      "name": "sr latch",
      "help": "<b>セット/リセットラッチ</b> ビットを保持し、出力します。\n<table class='truth'>\n<colgroup class=input><col><col></colgroup>\n<colgroup class=input><col></colgroup>\n<colgroup class=output><col></colgroup>\n<tr><th colspan=2>入力</th><th>出力</th></tr>\n<tr><th>s</th><th>r</th><th></th></tr>\n<tr><td>1</td><td>0</td><td>1</td></tr>\n<tr><td>0</td><td>1</td><td>0</td></tr>\n<tr><td>1</td><td>1</td><td>前回の出力</td></tr>\n<tr><td>0</td><td>0</td><td><i>未定義</i></td></tr>\n</table>\n"
    },
    "LATCH": {
      "name": "d latch",
      "help": "<b>データラッチ</b> ビットを保持し、出力します。\n<p><b>st</b>（ストア）が1の場合、<b>d</b>ビットが保持され、出力されます。</p>\n<p><b>st</b>が0の場合、最後に保持されたビットが出力され、現在の<b>d</b>の値は無視されます。</p>"
    },
    "DFF": {
      "help": "<b>データフリップフロップ</b> ビットを保持し、出力します。クロック信号によって同期されています。\n\n<table class='truth'>\n<tr><th colspan=3>入力</th><th>副作用</th><th>出力</th></tr>\n<tr><th>st</th><th>d</th><th>cl</th><th></th><th></th></tr>\n<tr><td>0</td><td>-</td><td>0</td><td>-</td><td><b>out</b></td></tr>\n<tr><td>1</td><td>0</td><td>0</td><td><b>in</b>を0に設定</td><td><b>out</b></td></tr>\n<tr><td>1</td><td>1</td><td>0</td><td><b>in</b>を1に設定</td><td><b>out</b></td></tr>\n<tr><td>-</td><td>-</td><td>1</td><td><b>out</b>を<b>in</b>に設定</td><td><b>out</b></td></tr>\n</table>\n\n<p>この表では、<b>in</b>と<b>out</b>は保持されたビットを指します。<b>cl</b>が0のときは、<b>in</b>を変更しても構いません。</p>\n<p><b>cl</b>が1に変わると、<b>out</b>は<b>in</b>の値に設定されます。</p>\n",
      "name": "dff"
    },
    "DFF16": {
      "name": "register",
      "help": "<b>16ビットDFFレジスタ</b> 16ビットのワードを保持し、出力します。クロック信号によって同期されています。\n\n<table class='truth'>\n<tr><th colspan=3>入力</th><th>副作用</th><th>出力</th></tr>\n<tr><th>st</th><th>X</th><th>cl</th><th></th><th></th></tr>\n<tr><td>0</td><td>-</td><td>0</td><td>-</td><td><b>out</b></td></tr>\n<tr><td>1</td><td>-</td><td>0</td><td><b>in</b>をXに設定</td><td><b>out</b></td></tr>\n<tr><td>-</td><td>-</td><td>1</td><td><b>out</b>を<b>in</b>に設定</td><td><b>out</b></td></tr>\n</table>\n"
    },
    "RAM2": {
      "name": "ram2",
      "help": "<b>RAM 2</b> 16ビットの値を2つ保持します。\n<p><b>ad</b>: 読み出し用の1ビットアドレス（<b>st</b>が1の場合は書き込みにも使用されます）</p>\n<p><b>X</b>: 保存するデータ（<b>st</b>が1の場合）</p>\n<p><b>st</b>: 1の場合、アドレス<b>ad</b>に<b>D</b>を保存します</p>\n<p><b>cl</b>: クロック信号。</p>\n<p>出力は、<b>ad</b>で指定されたアドレスに保存された16ビットの値です。</p>"
    },
    "COUNTER": {
      "name": "counter",
      "help": "<b>16ビットカウンタ</b> 16ビットのワードを保持し、出力します。\n<p>カウンタは、<b>cl</b>（クロック信号）が0に変わるときに変更されます。\n\n<table class='truth'>\n<tr><th>st</th><th></th></tr>\n<tr><td>0</td><td>カウンタは現在の数値に1を加えた値に設定されます。</td></tr>\n<tr><td>1</td><td>カウンタは<b>X</b>に設定されます。</td></tr>\n</table>"
    },
    "RAM": {
      "name": "ram",
      "help": "<b>RAM</b> 65536個の16ビット値を保持します。\n<p><b>Ad</b>: 読み出し用のアドレス（<b>st</b>が1の場合は書き込みにも使用されます）</p>\n<p><b>X</b>: 保存するデータ（<b>st</b>が1の場合）</p>\n<p><b>st</b>: 1の場合、アドレス<b>Ad</b>に<b>D</b>を保存します</p>\n<p><b>cl</b>: クロック信号。</p>\n<p>出力は、<b>Ad</b>で指定されたアドレスに保存された16ビットの値です。</p>\n"
    },
    "STATE": {
      "name": "memory",
      "help": "CPUが用いる記憶装置を統合したものです。\n<p>2つのレジスタ<b>A</b>と<b>D</b>、およびRAMメモリユニットで構成されています。</p>\n<p><b>*A</b>出力は、<b>A</b>で指定されたアドレスに対応するRAMセルです。</p>"
    },
    "ROM": {
      "name": "rom",
      "help": "<b>プログラムメモリ</b>（読み取り専用メモリ） 最大で65536個の16ビットワードを保存します。読み取りは可能ですが、変更はできません。\n<p><b>Ad</b>: 読み出し用のアドレス</p>\n<p>出力は、<b>A</b>で指定されたアドレスに保存された16ビットの値です。</p>"
    },
    "BUTTON": {
      "name": "button",
      "help": "ハードウェアボタン。押されている間は1を出力し、それ以外のときは0を出力します。"
    },
    "LAMP": {
      "name": "lamp",
      "help": "ハードウェアランプ。<b>on</b>に1が入力されると点灯し、<b>off</b>に1が入力されると消灯します。（0から1への変化があった場合にのみ反応します。）"
    },
    "ROBOT": {
      "name": "robot",
      "help": "<b>ロボットコントローラー</b> ロボットのハードウェア機器やセンサーと連携します。\n\n<p>各入力が1に設定されると、それぞれのアクションが開始されます。</p>\n<p><b>lo</b>: ランプを点灯する\n<br><b>lf</b>: ランプを消灯する\n<br><b>mv</b>: 前進を開始する\n<br><b>stp</b>: 前進を停止する\n<br><b>tl</b>: 90度左に回転する\n<br><b>tr</b>: 90度右に回転する\n<br><b>zp</b>: 破壊光線を発射する</p>\n<p>ロボットがすでに移動中または回転中の場合、移動/回転信号は無視されます。</p>\n\n<p>出力:</p>\n<p><b>mv</b> ロボットが現在前進中であれば1\n<br><b>tn</b> ロボットが現在回転中であれば1\n<br><b>ob</b> 障害物を検出した場合は1\n<br><b>lf</b> 生命を検出した場合は1</p>"
    },
    "CLOCK": {
      "name": "clock",
      "help": "<b>クロック</b> 回路全体で状態の変化を同期させるために使用されるクロック信号を生成するコンポーネントです。<b>Pulse</b>ボタンをクリックすると、1回のクリックにつき1サイクル生成されます。\n"
    },
    "SHL": {
      "name": "shl",
      "help": "<b>左シフト</b> すべてのビットを左に1ポジションずつシフトします。入力の最上位ビット（ビット15）は破棄され、出力の最下位ビット（ビット0）は0に設定されます。\n"
    },
    "SWITCH": {
      "name": "switch",
      "help": "電気スイッチ。<b>off</b>が0のときに<b>i</b>を<b>o</b>に接続します。<b>off</b>が1のときは切断します。"
    },
    "PMOS": {
      "name": "pmos",
      "help": "PMOSトランジスタ。<b>off</b>が0のときには<b>i</b>が<b>o</b>に接続され、<b>off</b>が1のときには切断されます。"
    },
    "WIRE_JUNCTION": {
      "help": "ジャンクション。複数のワイヤを接続します。"
    },
    "NMOS": {
      "help": "NMOSトランジスタ。<b>on</b>が1のときには<b>i</b>が<b>o</b>に接続され、<b>on</b>が0のときには切断されます。",
      "name": "nmos"
    },
    "TRINARY_LOGIC_WIRE_JUNCTION": {
      "help": "ジャンクション。複数の出力を接続します。"
    },
    "CONST": {
      "name": "const",
      "help": "固定の16ビットの値を出力する基本的なコンポーネントです。"
    },
    "ADD_SIGNED_MAGNITUDE": {
      "help": "符号と絶対値形式で2つの数を加算します。<b>sgn</b> は符号を表し、0は正、1は負を意味します。<b>m</b> は絶対値です。"
    },
    "BARREL_SHR": {
      "help": "右シフト n: 16ビットの値を n ビット右にシフトします。<b>X</b> はシフトする値です。<b>n</b> はシフトするビット数です（0 の場合、X は変更されません）。右端のビットは破棄され、左から0がシフトインされます。"
    },
    "BARREL_SHL": {
      "help": "左シフト n: 16ビットの値を n ビット左にシフトします。<b>X</b> はシフトする値です。<b>n</b> はシフトするビット数です（0 の場合、X は変更されません）。左端のビットは破棄され、右から0がシフトインされます。\n"
    }
  }
}