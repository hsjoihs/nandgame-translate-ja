{
  "missions": {
    "RELAY_NAND": {
      "title": "Nand",
      "splash": "<p><b>Nand Game</b>へようこそ！</p>\n<p>このゲームでは、基本的な部品（コンポーネント）からスタートして、コンピュータを組み上げていきます。\n  <div><p>このゲームは、順番にステージをこなす構成となっています。\n 各ステージでは、仕様に従って動作するコンポーネントを作成することが求められます。\n 作成したコンポーネントは、以降のステージで、新たに物を組み立てるための部品として使用できます。\n\n<p>このゲームでは、コンピュータアーキテクチャやソフトウェアについての事前知識は<b>一切</b>必要ありませんし、足し算や引き算以外の数学的なスキルも必要ありません。\n （ただし、解くのに結構時間がかかりそうなタスクもそこそこあるので、忍耐力は必要ですよ～）\n\n </div> <p>最初のタスクは、<b>nand</b>という部品を作成することです。\n <p>図の左側に、このタスクで作り上げるべき部品の厳密な仕様が載っています。\n 「ステージのヒント」をクリックすると、追加のお役立ち情報を見ることができます。",
      "specification": "<p>今回のタスクは、入力 <b>a</b> と <b>b</b> が両方とも 1 のときに出力が 0 になるように、入力を出力へとワイヤーやリレーで接続することです。</p>\n\n<p><b>1</b> は電流が流れていることを表し、<b>0</b> は電流が流れていないことを表します。</p>\n<p><b>V</b> 入力は常に電流が流れている状態です。つまり、常に 1 を保っています。</p>\n<p>厳密な仕様は以下の通りです。",
      "elaboration": "<p><b>nand</b>コンポーネント（nand ゲートともいう）は、論理回路を構成する上で根幹をなす部品です。nand ゲートだけを使って、あらゆる計算をこなす論理回路を構築することができます。だからこそ、まず nand ゲートを作成することから始めるのです。</p>\n\n<p><b>リレー</b>は、電気で制御されるスイッチで、制御信号によってスイッチのオンとオフが切り替わります。制御電流が電磁石に流れたり流れなかったりすることで、その電磁石の力で接点がオンやオフの位置へと動きます。</p>\n\n<p>初期の電子計算機は電磁リレーで作られていましたが、今日のコンピュータはトランジスタで作られています。トランジスタは、リレーと同様、スイッチとして振る舞う装置です。ただし、トランジスタにはリレーと違い物理的・機械的に動くパーツが一切ないため、リレーよりも（はるかに）小型で、安価で、しかも高速に動作することができます。\n\nリレーの方が仕組みを説明しやすいので、Nandgameではリレーを使用していますが、機能としてはリレーとトランジスタは同様のものです。一度 nand コンポーネントを作成してしまえば、それがリレーで作られているかトランジスタで作られているかは気にしなくて良くなるのです。\n",
      "spoilers": {
        "0": "リレーを使って 2 段階の処理を行います。最初のリレーでは、入力 a と b が両方とも 1 のときに 1 を出力します。次に、2 つ目のリレーで最初のリレーの出力を反転させ、1 を 0 に、0 を 1 に変えます。"
      },
      "hints": {
        "drag": "<b>ステップ1:</b> ツールボックスからコンポーネントをドラッグして、青いエリアに配置します。\n",
        "tap": "<b>ステップ2:</b> 配線を繋げるには、三角形をタップまたはドラッグしましょう。",
        "tap-end": "コンポーネントの（丸い）端子をタップすると、配線が繋がります。",
        "truth": "作成すべきコンポーネントの仕様: <p>どの入力に対しても、正しい出力をすること。",
        "toggle": "チェックボックスをクリックして入力信号を切り替え、回路にどのように影響するかを確認しましょう。",
        "verify": "コンポーネントが正しく設計できたと思ったら、ここをクリックしてください。"
      },
      "debriefing": "<b>nand</b>コンポーネントがツールボックスに追加され、次のステージで組み立ての部品として使用できるようになりました。"
    },
    "INV": {
      "title": "反転",
      "splash": "<p>次のタスクは、<b>nand</b>コンポーネントを使って<b>インバータ</b>（否定回路）コンポーネントを作成することです。</p>\n<p></p> \n<p>このステージからは、根底にあるスイッチの仕組みを考慮する必要はありません。物理的な nand ゲートでは電源への接続が必要ですが、図にこれを示す必要はありません。すべてのコンポーネントは暗黙のうちに電源に接続されているものとします。これからは、論理的な入力と出力に集中しましょう。</p>\n",
      "specification": "<p>次のタスクは、否定回路（インバータ、<b>inv</b>) コンポーネントを作成することです。</p>\n\n<p><b>inv</b>コンポーネントは、単一の入力と単一の出力を持ちます。\n<p>出力は入力の反対になるようにしてください。つまり、1 の場合は 0 を、0 の場合は 1 を出力しましょう。\n",
      "hints": {
        "0": "<b>nand</b>コンポーネントがツールボックスに追加されました。"
      }
    },
    "AND": {
      "title": "AND",
      "splash": "<p>次のタスクは、<b>nand</b>コンポーネントと<b>inv</b>コンポーネントだけを使って<b>AND</b>ゲートを作成することです。\n （このタスクは、どちらか一方のコンポーネントだけで解けるかもしれません。）",
      "specification": "<p><b>AND</b>ゲートの出力は、両方の入力が 1 のときに 1 になります。",
      "spoilers": {
        "0": "実は、\"NAND\" は \"NOT AND\" の略です。\n\n（訳注：原文は「\"NAND\" は \"Negative AND\" の略である」と主張していますが、Oxford English Dictionary によると not + and が語源とのことです。）"
      }
    },
    "OR": {
      "title": "OR",
      "specification": "<p><b>OR</b>ゲートの出力は、少なくとも1つの入力が1のときに1になります。</p>"
    },
    "XOR": {
      "title": "XOR",
      "specification": "<p><b>XOR</b>ゲートの出力は、2つの入力が異なるときに1になります。</p>",
      "elaboration": "XOR は <u>Exclusive OR</u> の略です。Exclusive とは「排他的」という意味です。<u>a または b のどちらか一方が 1 であり（これが「OR」）、両方が 1 というわけでない（これが「排他的」）</u>ことを意味します。"
    },
    "HALFADD": {
      "title": "半加算器",
      "splash": "<p>おめでとうございます。基本となる論理ゲートを作成できました。</p>\n<p>次のステップは、算術演算です。プロセッサは、数値を加算および減算できる必要があります。</p>\n\n<p>最初のタスクは、1ビットの数値を2つ足し合わせることです。結果は2ビットの数値になります。</p>\n<p>これを解くには、2進法の仕組みを理解している必要があります。</p>",
      "specification": "<p>2つのビットを足し合わせて2ビットの値を出力する<b>加算（add）</b>コンポーネントです。</p>\n<p><b>h</b>出力は上位 (high) ビット、<b>l</b>は下位 (low) ビットです。</p>",
      "elaboration": "<div class=subject>\n\n <h3>2進法</h3>\n\n <p>コンピュータは<b>2進法</b>を使用して算術演算を行います。</p>\n\n <p>我々が普段慣れ親しんでいる、0 から 9 の数字を使って数を書く通常の書き方と異なり、2進法では、すべての数値が 0 と 1 という数字だけを使って表されます。</p>\n\n <p>例:</p>\n\n <table class=data>\n <tr><th>2進法</th><th>10進法</th></tr>\n <tr><td>00</td><td>0</td></tr>\n <tr><td>01</td><td>1</td></tr>\n <tr><td>10</td><td>2</td></tr>\n <tr><td>11</td><td>3</td></tr>\n </table>\n\n2進法を理解するには、まず10進法の仕組みを考えてみましょう。10種類の異なる数字がありますが、桁の位置を調整することで任意の大きな数字を表現できます。3桁の数では、一番右の桁が1の位、右から2番目が10の位、右から3番目が100の位、というように続きます。\nということで、たとえば 273 は 2 × 100 + 7 × 10 + 3 × 1 です。各桁は 10 の累乗に対応しているので、これは「<u>10進法</u>」で数を表現している、と言います。\n\n<p>2進法では、0 と 1 の2つの数字だけが使用されます。2進法では各桁が 2 の累乗に対応しており、1の位、2の位、4の位、8の位、と続きます。\nということで、たとえば 2進法で 101 と書いたら 10進法でいう 5 に相当します（1 × 4 + 0 × 2 + 1 × 1）。離散的システムにおける2種類の状態を数字の 0 と 1 に対応するようにさせることができるので、2進法はデジタル回路に最適なのです。</p>\n\n<p><a href=\"https://www.mathsisfun.com/binary-number-system.html\">詳しくはこちら（英語）</a></p>\n<p><a href=\"https://www.cc.kyoto-su.ac.jp/~kbys/kiso/number/number1.html\">詳しくはこちら（日本語）</a></p>\n\n</div>\n",
      "spoilers": {
        "0": "2つの出力に対応する列をそれぞれ個別に見て、何かパターンが見えてくるか確認してみましょう。"
      }
    },
    "FULLADD": {
      "title": "全加算器",
      "splash": "<p>これで、2つのビットを足し合わせる加算器を作成できました。</p>\n<p>しかし、より大きな数値を加算するには、下の桁の加算からの「繰り上がり」を考慮する必要があります。</p>\n<p>このミッションでは、3つのビット a、b、c を加算する加算器コンポーネントを作成します。ここで、c は繰り上がり (carry) ビットです。</p>\n",
      "specification": "<p>3つのビット、<b>a</b>、<b>b</b>、<b>c</b> を加算する<b>加算器（add）</b>コンポーネントです。</p>\n<p>出力は2ビットの値になります。<b>h</b>出力は上位 (high) ビット、<b>l</b>は下位 (low) ビットです。</p>\n",
      "elaboration": "目的は、どれだけ大きい数値でも加算できるようにすることです。まず a と b という 2 つのビットで足し算を行い、もし繰り上がりビットがあればそれも考慮してもう一度足し算を行います。\n"
    },
    "ADD2": {
      "title": "多ビット加算器",
      "splash": "<p>次に、2ビットの数 2 つ（と、1ビットの繰り上がり）を加算する加算器を作成しましょう。</p>\n<p>2ビット加算器は、繰り返し使用することで、より大きな数に対応する加算器を作ることができます。</p>",
      "specification": "<p>2ビットの数 2 つと、1 ビットの繰り上がりを加算する加算器を作成しましょう。</p>\n<h3>入力</h3>\n<p><b>a1 a0</b> は2ビットの数値です。</p>\n<p><b>b1 b0</b> は2ビットの数値です。</p>\n<p><b>c</b>（繰り上がり入力）は1ビットの数値です。</p>\n\n<h3>出力</h3>\n<p>入力された数値を加算し、3ビットの数値 <b>c s1 s0</b> を出力します。ここで、<b>c</b> は上位ビットです。</p>\n\n<h3>例</h3>\n\n<table class='data'>\n<colgroup class=input><col><col></colgroup>\n<colgroup class=input><col><col></colgroup>\n<colgroup class=input><col></colgroup>\n<colgroup class=output><col><col><col></colgroup>\n<colgroup class=output><col></colgroup>\n<tr><th colspan=5>入力</th><th colspan=3>出力</th></tr>\n<tr><th>a1</th><th>a0</th><th>b1</th><th>b0</th><th>c</th><th>c</th><th>s1</th><th>s0</th></tr>\n<tr><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td><td>2+2+1=5</td></tr>\n</table>\n",
      "debriefing": "<p>2桁の2進数を加算するコンポーネントの設計を繰り返し適用することで、任意の大きさの数を加算することができます。</p>\n\n<p>我々は 16 ビットプロセッサを構築しようとしているので、今回のコンポーネントを繰り返し使用して 16 ビット加算器コンポーネントを作成し、<b>add 16</b>という名前でツールボックスに追加しておきますね。</p>\n"
    },
    "INC": {
      "title": "インクリメント\n",
      "splash": "<p>これで、16ビットの数値を扱う準備が整いました。</p>\n\n<p>今回のミッションは、16ビットの数値に 1 を加算する<b>インクリメント</b>コンポーネントを作成することです。</p>\n\n<p>16ビットの数値を扱うことになるため、図上での表現を簡略化しました。16本のバラバラの配線と16個の端子を描くのではなく、それらをまとめて1つの端子として表示し、小さな「<b>16</b>」ラベルで示しています。</p>\n",
      "specification": "<p>16ビットの数値に<b>1</b>を加算しましょう。</p>\n<p>結果が16ビットを超える場合は、繰り上がりを無視してください。</p>\n",
      "hints": {
        "0": "16ビットの出力を1つのかたまりとして扱い、出力は16進数と符号付き10進数で表示されます。\n",
        "1": "16ビットの入力を1つのかたまりとして扱い、値は16進数または10進数で入力できます。"
      },
      "elaboration": "<p><b>インクリメント</b>とは、数値を1増やすことを意味します。<a href=\"https://ja.wikipedia.org/wiki/%E6%95%B0%E5%8F%96%E5%99%A8\">ボタンを押すたびに数が 1 増えるカウンター</a>をイメージすると分かりやすいでしょう。</p>\n\n<h3>16ビット</h3>\n\n<p>プロセッサは常に複数のビットを同時に処理します。いま構築していっているプロセッサは<b>16ビットプロセッサ</b>であり、16ビットのまとまりを一度に処理します。</p>\n\n<p>現代のプロセッサ（コンピュータやスマートフォンに搭載されているもの）は通常32ビットまたは64ビットです。電子レンジのような組み込みプロセッサは、8ビットや4ビットだったりするかもしれません。16ビットは実用的なことをするのに十分なサイズであるため、ここでは16ビットを選択しています。</p>\n\n<h3>ワードとバイト</h3>\n<p>16ビットのまとまりは<b>ワード</b>と呼ばれます。ワードのサイズはプロセッサによって異なります。<b>バイト</b>は常に8ビットで、どの機械を使っているのかに依存しない単位です。</p>\n\n<div>\n<h3>バス</h3>\n<p>接続のまとまりを1つの単位として扱うものは<b>バス</b>と呼ばれます。入力と出力はそれぞれ16ビットのバスです。16ビット加算器の<b>A</b>入力と<b>B</b>入力もそれぞれ16ビットのバスです。</p>\n</div>\n\n<div>\n<h3>16進数</h3>\n<p>大きな2進数は、人間にとって読み書きが不便です。そのため、より短くて扱いやすい<b>16進数</b>が使われます。16進数では、A, B, C, D, E, F の文字が10から15を表します。</p>\n<p>16進数（hexadecimal、略して<u>hex</u>と呼ばれる）は、2進データを表現するのに便利です。なぜなら、16進数の1桁は常に4ビットに対応するからです。16ビットのワードは16進数では4桁になります。一方、10進数は2進数の桁と直接対応しないため、2進データを扱うのにはあまり便利ではありません。</p>\n\n<p>例:</p>\n<table class='data numbers'>\n<tr><th>hex</th><th>符号なし10進数</th><th>2進数</th></tr>\n<tr><td>1</td><td>1</td><td>0000000000000001</td></tr>\n<tr><td>F</td><td>15</td><td>0000000000001111</td></tr>\n<tr><td>10</td><td>16</td><td>0000000000010000</td></tr>\n<tr><td>2A</td><td>42</td><td>0000000000101010</td></tr>\n<tr><td>0100</td><td>256</td><td>0000000100000000</td></tr>\n<tr><td>FFFF</td><td>65535</td><td>1111111111111111</td></tr>\n</table>\n\n<p>便利機能として、16ビットの入力端子と出力端子では、数値が2進数と並んで16進数でも表示されるようにしておきました。16進数の値を入力すると、自動的に2進数に変換されます。</p>\n\n<p><a href=\"https://www.mathsisfun.com/hexadecimals.html\">16進数のチュートリアル（英語）</a>（おすすめのチュートリアルがある場合は原作者にお伝えください。）</p>\n<p><a href=\"https://zenn.dev/masahiro_toba/books/b42ef6fe522b38/viewer/72dbdd\">16進数のチュートリアル（日本語）</a>（おすすめのチュートリアルがある場合は https://x.com/hsjoihs までお知らせください。）</p>\n\n\n</div>\n",
      "spoilers": {
        "0": "入力端子は何にも接続されていなくても構いません。接続されていない入力は常に0です。",
        "1": "入力に何も接続されていない<b>inv</b>ゲートは、常に1を出力します。",
        "2": "<b>add</b>コンポーネントの繰り上がり入力<b>c</b>は、1ビットの入力であり、0または1の2進数を受け付けます。"
      }
    },
    "SUB": {
      "title": "減算",
      "splash": "<p>次に、16ビットの数から16ビットの数を<b>減算</b>するコンポーネントを作成しましょう。",
      "specification": "<p>A から B を引いた結果を16ビットの数値として出力します。</p>\n<p>結果が0未満（つまり、マイナスの数）の場合、65536を足した値で表現されます。</p>\n<p>例:</p>\n\n<table class='data numbers'>\n<tr><th>結果</th><th>16ビット2進数</th><th>符号なし10進数</th></tr>\n<tr><td>1</td><td>0000000000000001</td><td>1</td></tr>\n<tr><td>0</td><td>0000000000000000</td><td>0</td></tr>\n<tr><td>-1</td><td>1111111111111111</td><td>65535</td></tr>\n<tr><td>-2</td><td>1111111111111110</td><td>65534</td></tr>\n<tr><td>-3</td><td>1111111111111101</td><td>65533</td></tr>\n</table>\n\n<p>（これは2の補数表現に相当します）</p>",
      "elaboration": "<div class=subject>\n\n <h3>2の補数</h3>\n <p>2の補数は、符号付き（正および負）の数を2進数で表現する標準的な方法です。</p>\n <p>右から15番目のビット（一番左のビット）は符号を示します。\n右から15番目のビットが0ならその数は正の数、1なら負の数です。負の数は、65536からその数を引いた値として表されます。\n 例えば、-127 なら 65536 - 127 = 65409 と計算することで符号なしの数値 65409に対応することが分かります。</p>\n\n <p>いくつかの例を示します。</p>\n <table class='data numbers'>\n <tr><th>符号付き10進数</th><th>符号なし10進数</th><th>16ビット2進数</th><th>16進数</th></tr>\n <tr><td>32767</td><td>32767</td><td>0111111111111111</td><td>7FFF</td></tr>\n <tr><td>1</td><td>1</td><td>0000000000000001</td><td>0001</td></tr>\n <tr><td>0</td><td>0</td><td>0000000000000000</td><td>0000</td></tr>\n <tr><td>-1</td><td>65535</td><td>1111111111111111</td><td>FFFF</td></tr>\n <tr><td>-2</td><td>65534</td><td>1111111111111110</td><td>FFFE</td></tr>\n <tr><td>-3</td><td>65533</td><td>1111111111111101</td><td>FFFD</td></tr>\n <tr><td>-32768</td><td>32768</td><td>1000000000000000</td><td>8000</td></tr>\n </table>\n\n <p>\n </div>\n",
      "spoilers": {
        "0": "ビットごとの反転（<b>inv16</b>）が数値にどのような影響を与えるか調べてみましょう。\n\n\n\n",
        "1": "数値をビット反転したものは、65535からその数を引いた値と同じです。負の数は、65536からその数を引いた値として表されます。",
        "2": "A - B = A + INV(B) + 1"
      },
      "debriefing": "おめでとうございます。基本となる算術演算を行うためのコンポーネントを作成できました。\n<p>現代のプロセッサは、乗算や除算、浮動小数点数など、はるかに複雑な算術演算をサポートしていますが、このゲームでは、動作するプロセッサを作成するために必要最低限のものだけを作成します。</p>"
    },
    "ISZERO": {
      "title": "ゼロであるかどうかの判定",
      "splash": "<p>次に、数値がゼロであるかどうかを示すコンポーネントを作成しましょう。まず、4ビットの数値に対してこれを実装します。</p>",
      "specification": "<p>入力されたすべてのビットが0の場合に限り、1を出力するようにします。</p>",
      "debriefing": "このアプローチは簡単に16ビットに拡張できるので、16ビットの数値がゼロであるかどうかを確認するコンポーネントを作成しておきます。"
    },
    "SIGN": {
      "title": "ゼロより小さいかどうかの判定",
      "splash": "<p>次に、16ビットの数値が負であるかどうかを示すコンポーネントを設計しましょう。</p>",
      "specification": "<p>16ビットの数値の入力が負の場合は1を出力します。</p>\n\n<p>仕様:</p>\n<table class='data'>\n<colgroup class=input><col></colgroup>\n<colgroup class=output><col></colgroup>\n<tr><th>入力</th><th>出力</th></tr>\n<tr><td>入力 ≧ 0</td><td>0</td></tr>\n<tr><td>入力 < 0</td><td>1</td></tr>\n</table>\n\n第15ビットが1であれば、その数値はゼロ未満とみなされます。\n\n<h3>ビットの番号付け</h3>\nビットは右から左に向かって番号が付けられ、右端のビットを0として数えます。したがって、16ビットのワードでは第15ビットが左端のビットです。\n",
      "elaboration": "このコンポーネントにおいては、16ビットの値を符号付き整数として解釈し、左端のビットを符号とみなします。\n\n<p>ツールボックスに<b>スプリッタ</b>を追加しました。スプリッタは16ビットのバスを16個の個別の端子に分割します。\nスプリッタを使用すると、16ビットの入力の個々のビットを確認できます。スプリッタには内部ロジックは一切ありません。\n\n<div class=subject>\n<h3>符号付きと符号なしの数値</h3>\n\n<p>16ビットの値は、符号付き整数としても符号なし整数としても解釈できます。0付近のいくつかの数値の例を示します：</p>\n\n<table class='data numbers'>\n<tr><th>16ビット2進数</th><th>16進数</th><th>符号なし10進数</th><th>符号付き10進数</th></tr>\n<tr><td>0000000000000001</td><td>0001</td><td>1</td><td>1</td></tr>\n<tr><td>0000000000000000</td><td>0000</td><td>0</td><td>0</td></tr>\n<tr><td>1111111111111111</td><td>FFFF</td><td>65535</td><td>-1</td></tr>\n<tr><td>1111111111111110</td><td>FFFE</td><td>65534</td><td>-2</td></tr>\n<tr><td>1111111111111101</td><td>FFFD</td><td>65533</td><td>-3</td></tr>\n</table>\n\n<p>便利なことに、数値を符号付きとして解釈しても符号なしとして解釈しても、加算と減算はまったく同じように動作します。\nこれはつまり、プロセッサは実際には符号付きかどうかを知らなくてよいということです。</p>\n\n<a href=\"https://gihyo.jp/assets/files/book/2017/978-4-7741-8523-1/download/P027.pdf\">2 の補数のチュートリアル（日本語）</a>\n</div>\n",
      "spoilers": {
        "0": "このコンポーネントにおいては、論理コンポーネントは必要なく、スプリッタだけで十分です。"
      }
    },
    "MULTIPLEXER": {
      "title": "セレクタ",
      "specification": "<p><b>セレクト</b>コンポーネントは、2つの入力ビットのうち1つを選んで出力します。</p>\n\n<p>どちらの入力が選ばれるかを示すのが、<b>s</b>（セレクト）ビットです。\n0の場合は<b>d0</b>が選ばれ、1の場合は<b>d1</b>が選ばれます。</p>",
      "elaboration": "<p>このコンポーネントは、<b>マルチプレクサ</b>（multiplexer）としても知られています。</p>"
    },
    "DEMUX": {
      "title": "スイッチ",
      "splash": "次に、データビットを2つの出力チャネルのどちらかに通す<b>スイッチ</b>を作成しましょう。",
      "specification": "<p><b>スイッチ</b>コンポーネントは、データビットを2つの出力チャネルのどちらかに通します。</p>\n\n<p><b>s</b>（セレクタ）にどちらのビットが入ってくるかによって、<b>d</b>（データ）ビットが<b>c1</b>か<b>c0</b>のどちらを通るかが決まります。</p>"
    }
  }
}